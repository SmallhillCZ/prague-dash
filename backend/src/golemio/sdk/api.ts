/* tslint:disable */
/* eslint-disable */
/**
 * Golemio API
 * <p><img src=\"https://storage.golemio.cz/golemiocz/images/golemioapi_logos.png\" alt=\"Logos\" /></p> <p><b>Toto je dokumentace REST API projektu pra≈æsk√© datov√© platformy Golemio.</b></p> <p>Ve≈°ker√© dotazy pros√≠m smƒõ≈ôujte na <a href=\"mailto:golemio@operatorict.cz?subject=golemioapi\">golemio@operatorict.cz</a>.</p> <p>Dokumentace je v anglick√©m jazyce. V√≠ce informac√≠ o projektu naleznete na <a href=\"https://www.golemio.cz/\">www.golemio.cz</a>.</p> <H1>Description</H1> <p><b>This documentation covers the RESTful API of the Golemio Prague Data Platform project, specifically detailing the Output Gateway API.</b></p> <p>Support is accessible via <a href=\"mailto:golemio@operatorict.cz?subject=golemioapi\">golemio@operatorict.cz</a>.</p> <p>For more information about Golemio, please visit the website <a href=\"https://www.golemio.cz/\">www.golemio.cz</a>.</p> <H2>Golemio API documentation:</H2> <li>üëâ Main Golemio API</li> <li><a href=\"https://api.golemio.cz/docs/public-openapi/\">Open Data Golemio API</a></li> <li><a href=\"https://api.golemio.cz/input-gateway/docs/openapi/\">Golemio Input Gateway API</a></li> <li><a href=\"https://api.golemio.cz/pid/docs/openapi/\">Public Transport Golemio API</a></li> <li><a href=\"https://api.golemio.cz/pid/input-gateway/docs/openapi/\">Public Transport Golemio Input Gateway API</a></li> <H1>General info</H1> <H2>Authorization</H2> <p>Generate your token at <a href=\"https://api.golemio.cz/api-keys\">api.golemio.cz/api-keys</a>.</p> <p><b>Use the token as the value of the X-Access-Token header.</b></p> <H1>Usage</H1> <H2>Pagination</H2> <p>The API returns a maximum of 10,000 objects/rows per request. You can specify a lower number by adding the <code>?limit</code> URL parameter.</p> <p>     This limit may vary depending on the specific route; please refer to the description of parameters for each route. To retrieve more data, use multiple requests with the <code>?limit&offset</code> parameters.     Refer to the examples below. </p> <H2>Requests rate</H2> <p>By default, each API key has a rate limit of 20 requests per 8 seconds.</p> <H2>Compression</H2> <p>By default, the Content-Encoding header is set to gzip (if requested). If the raw response is less than 1 KB, the data is returned uncompressed, and the Content-Encoding header is not set.</p> <H2>Open Data</H2> <p><img src=\"https://img.shields.io/badge/opendata-available-green\" alt=\"golemioapi-opendata-badge\" /></p> <p>This badge indicates that the data is available for public use as Open Data.</p>
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: golemio@operatorict.cz
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import type { ConfigurationParameters } from './configuration';
import type { AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AirQualityStation
 */
export interface AirQualityStation {
    /**
     * 
     * @type {string}
     * @memberof AirQualityStation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AirQualityStation
     */
    'district'?: string;
    /**
     * 
     * @type {AirQualityStationMeasurement}
     * @memberof AirQualityStation
     */
    'measurement'?: AirQualityStationMeasurement;
    /**
     * 
     * @type {string}
     * @memberof AirQualityStation
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AirQualityStation
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface AirQualityStationComponent
 */
export interface AirQualityStationComponent {
    /**
     * 
     * @type {AirQualityStationComponentAveragedTime}
     * @memberof AirQualityStationComponent
     */
    'averaged_time'?: AirQualityStationComponentAveragedTime;
    /**
     * 
     * @type {string}
     * @memberof AirQualityStationComponent
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface AirQualityStationComponentAveragedTime
 */
export interface AirQualityStationComponentAveragedTime {
    /**
     * 
     * @type {number}
     * @memberof AirQualityStationComponentAveragedTime
     */
    'averaged_hours'?: number;
    /**
     * 
     * @type {number}
     * @memberof AirQualityStationComponentAveragedTime
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface AirQualityStationComponentType
 */
export interface AirQualityStationComponentType {
    /**
     * 
     * @type {number}
     * @memberof AirQualityStationComponentType
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof AirQualityStationComponentType
     */
    'component_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AirQualityStationComponentType
     */
    'unit'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AirQualityStationComponentType
     */
    'description_cs'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AirQualityStationComponentType
     */
    'description_en'?: string | null;
}
/**
 * 
 * @export
 * @interface AirQualityStationHistory
 */
export interface AirQualityStationHistory {
    /**
     * 
     * @type {string}
     * @memberof AirQualityStationHistory
     */
    'id': string;
    /**
     * 
     * @type {AirQualityStationMeasurement}
     * @memberof AirQualityStationHistory
     */
    'measurement'?: AirQualityStationMeasurement;
    /**
     * 
     * @type {string}
     * @memberof AirQualityStationHistory
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface AirQualityStationIndexType
 */
export interface AirQualityStationIndexType {
    /**
     * 
     * @type {number}
     * @memberof AirQualityStationIndexType
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof AirQualityStationIndexType
     */
    'index_code'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AirQualityStationIndexType
     */
    'limit_gte'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AirQualityStationIndexType
     */
    'limit_lt'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AirQualityStationIndexType
     */
    'color'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AirQualityStationIndexType
     */
    'color_text'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AirQualityStationIndexType
     */
    'description_cs'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AirQualityStationIndexType
     */
    'description_en'?: string | null;
}
/**
 * 
 * @export
 * @interface AirQualityStationMeasurement
 */
export interface AirQualityStationMeasurement {
    /**
     * 
     * @type {number}
     * @memberof AirQualityStationMeasurement
     */
    'AQ_hourly_index'?: number;
    /**
     * 
     * @type {Array<AirQualityStationComponent>}
     * @memberof AirQualityStationMeasurement
     */
    'components'?: Array<AirQualityStationComponent>;
}
/**
 * 
 * @export
 * @interface AverageOccupancyDay
 */
export interface AverageOccupancyDay {
    /**
     * 
     * @type {number}
     * @memberof AverageOccupancyDay
     */
    '0'?: number;
    /**
     * 
     * @type {number}
     * @memberof AverageOccupancyDay
     */
    '1'?: number;
    /**
     * 
     * @type {number}
     * @memberof AverageOccupancyDay
     */
    '2'?: number;
    /**
     * 
     * @type {number}
     * @memberof AverageOccupancyDay
     */
    '3'?: number;
    /**
     * 
     * @type {number}
     * @memberof AverageOccupancyDay
     */
    '4'?: number;
    /**
     * 
     * @type {number}
     * @memberof AverageOccupancyDay
     */
    '5'?: number;
    /**
     * 
     * @type {number}
     * @memberof AverageOccupancyDay
     */
    '6'?: number;
    /**
     * 
     * @type {number}
     * @memberof AverageOccupancyDay
     */
    '7'?: number;
    /**
     * 
     * @type {number}
     * @memberof AverageOccupancyDay
     */
    '8'?: number;
    /**
     * 
     * @type {number}
     * @memberof AverageOccupancyDay
     */
    '9'?: number;
    /**
     * 
     * @type {number}
     * @memberof AverageOccupancyDay
     */
    '10'?: number;
    /**
     * 
     * @type {number}
     * @memberof AverageOccupancyDay
     */
    '11'?: number;
    /**
     * 
     * @type {number}
     * @memberof AverageOccupancyDay
     */
    '12'?: number;
    /**
     * 
     * @type {number}
     * @memberof AverageOccupancyDay
     */
    '13'?: number;
    /**
     * 
     * @type {number}
     * @memberof AverageOccupancyDay
     */
    '14'?: number;
    /**
     * 
     * @type {number}
     * @memberof AverageOccupancyDay
     */
    '15'?: number;
    /**
     * 
     * @type {number}
     * @memberof AverageOccupancyDay
     */
    '16'?: number;
    /**
     * 
     * @type {number}
     * @memberof AverageOccupancyDay
     */
    '17'?: number;
    /**
     * 
     * @type {number}
     * @memberof AverageOccupancyDay
     */
    '18'?: number;
    /**
     * 
     * @type {number}
     * @memberof AverageOccupancyDay
     */
    '19'?: number;
    /**
     * 
     * @type {number}
     * @memberof AverageOccupancyDay
     */
    '20'?: number;
    /**
     * 
     * @type {number}
     * @memberof AverageOccupancyDay
     */
    '21'?: number;
    /**
     * 
     * @type {number}
     * @memberof AverageOccupancyDay
     */
    '22'?: number;
    /**
     * 
     * @type {number}
     * @memberof AverageOccupancyDay
     */
    '23'?: number;
}
/**
 * The day of the week (0 - 6; Sunday is 0)
 * @export
 * @interface AverageOccupancyWeek
 */
export interface AverageOccupancyWeek {
    /**
     * 
     * @type {AverageOccupancyDay}
     * @memberof AverageOccupancyWeek
     */
    '0'?: AverageOccupancyDay;
    /**
     * 
     * @type {AverageOccupancyDay}
     * @memberof AverageOccupancyWeek
     */
    '1'?: AverageOccupancyDay;
    /**
     * 
     * @type {AverageOccupancyDay}
     * @memberof AverageOccupancyWeek
     */
    '2'?: AverageOccupancyDay;
    /**
     * 
     * @type {AverageOccupancyDay}
     * @memberof AverageOccupancyWeek
     */
    '3'?: AverageOccupancyDay;
    /**
     * 
     * @type {AverageOccupancyDay}
     * @memberof AverageOccupancyWeek
     */
    '4'?: AverageOccupancyDay;
    /**
     * 
     * @type {AverageOccupancyDay}
     * @memberof AverageOccupancyWeek
     */
    '5'?: AverageOccupancyDay;
    /**
     * 
     * @type {AverageOccupancyDay}
     * @memberof AverageOccupancyWeek
     */
    '6'?: AverageOccupancyDay;
}
/**
 * 
 * @export
 * @interface BicycleCounter
 */
export interface BicycleCounter {
    /**
     * 
     * @type {string}
     * @memberof BicycleCounter
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BicycleCounter
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BicycleCounter
     */
    'route'?: string;
    /**
     * 
     * @type {string}
     * @memberof BicycleCounter
     */
    'updated_at'?: string;
    /**
     * 
     * @type {Array<BicycleCounterDirection>}
     * @memberof BicycleCounter
     */
    'directions'?: Array<BicycleCounterDirection>;
}
/**
 * 
 * @export
 * @interface BicycleCounterDetections
 */
export interface BicycleCounterDetections {
    /**
     * direction_id
     * @type {string}
     * @memberof BicycleCounterDetections
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof BicycleCounterDetections
     */
    'value'?: number;
    /**
     * 
     * @type {number}
     * @memberof BicycleCounterDetections
     */
    'value_pedestrians'?: number;
    /**
     * 
     * @type {string}
     * @memberof BicycleCounterDetections
     */
    'locations_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BicycleCounterDetections
     */
    'measured_from'?: string;
    /**
     * 
     * @type {string}
     * @memberof BicycleCounterDetections
     */
    'measured_to'?: string;
    /**
     * 
     * @type {number}
     * @memberof BicycleCounterDetections
     */
    'measurement_count'?: number;
}
/**
 * 
 * @export
 * @interface BicycleCounterDirection
 */
export interface BicycleCounterDirection {
    /**
     * direction ID
     * @type {string}
     * @memberof BicycleCounterDirection
     */
    'id': string;
    /**
     * direction name
     * @type {string}
     * @memberof BicycleCounterDirection
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface BicycleCounterTemperatures
 */
export interface BicycleCounterTemperatures {
    /**
     * location_id
     * @type {string}
     * @memberof BicycleCounterTemperatures
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof BicycleCounterTemperatures
     */
    'value'?: number;
    /**
     * 
     * @type {string}
     * @memberof BicycleCounterTemperatures
     */
    'measured_from'?: string;
    /**
     * 
     * @type {string}
     * @memberof BicycleCounterTemperatures
     */
    'measured_to'?: string;
    /**
     * 
     * @type {number}
     * @memberof BicycleCounterTemperatures
     */
    'measurement_count'?: number;
}
/**
 * 
 * @export
 * @interface BulkyContainer
 */
export interface BulkyContainer {
    /**
     * 
     * @type {BulkyContainerGeometry}
     * @memberof BulkyContainer
     */
    'geometry'?: BulkyContainerGeometry;
    /**
     * 
     * @type {BulkyContainerProperties}
     * @memberof BulkyContainer
     */
    'properties'?: BulkyContainerProperties;
    /**
     * 
     * @type {string}
     * @memberof BulkyContainer
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface BulkyContainerGeometry
 */
export interface BulkyContainerGeometry {
    /**
     * 
     * @type {Array<number>}
     * @memberof BulkyContainerGeometry
     */
    'coordinates'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof BulkyContainerGeometry
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface BulkyContainerProperties
 */
export interface BulkyContainerProperties {
    /**
     * station id
     * @type {string}
     * @memberof BulkyContainerProperties
     */
    'customId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkyContainerProperties
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkyContainerProperties
     */
    'timeFrom'?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkyContainerProperties
     */
    'timeTo'?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkyContainerProperties
     */
    'street'?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkyContainerProperties
     */
    'serviceName'?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkyContainerProperties
     */
    'payer'?: string;
    /**
     * 
     * @type {number}
     * @memberof BulkyContainerProperties
     */
    'numberOfContainers'?: number;
    /**
     * 
     * @type {string}
     * @memberof BulkyContainerProperties
     */
    'cityDistrict'?: string;
}
/**
 * 
 * @export
 * @interface BulkyStationsCollection
 */
export interface BulkyStationsCollection {
    /**
     * 
     * @type {Array<BulkyContainer>}
     * @memberof BulkyStationsCollection
     */
    'features'?: Array<BulkyContainer>;
    /**
     * 
     * @type {string}
     * @memberof BulkyStationsCollection
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface CityDistrictFeature
 */
export interface CityDistrictFeature {
    /**
     * 
     * @type {CityDistrictFeatureGeometry}
     * @memberof CityDistrictFeature
     */
    'geometry'?: CityDistrictFeatureGeometry;
    /**
     * 
     * @type {CityDistrictFeatureProperties}
     * @memberof CityDistrictFeature
     */
    'properties'?: CityDistrictFeatureProperties;
    /**
     * 
     * @type {string}
     * @memberof CityDistrictFeature
     */
    'type'?: string;
}
/**
 * GeoJson geometry
 * @export
 * @interface CityDistrictFeatureGeometry
 */
export interface CityDistrictFeatureGeometry {
    /**
     * 
     * @type {CityDistrictFeatureGeometryCoordinates}
     * @memberof CityDistrictFeatureGeometry
     */
    'coordinates'?: CityDistrictFeatureGeometryCoordinates;
    /**
     * 
     * @type {string}
     * @memberof CityDistrictFeatureGeometry
     */
    'type'?: CityDistrictFeatureGeometryTypeEnum;
}

export const CityDistrictFeatureGeometryTypeEnum = {
    Polygon: 'Polygon',
    MultiPolygon: 'MultiPolygon'
} as const;

export type CityDistrictFeatureGeometryTypeEnum = typeof CityDistrictFeatureGeometryTypeEnum[keyof typeof CityDistrictFeatureGeometryTypeEnum];

/**
 * @type CityDistrictFeatureGeometryCoordinates
 * @export
 */
export type CityDistrictFeatureGeometryCoordinates = Array<Array<Array<Array<number>>>> | Array<Array<Array<number>>>;
/**
 * 
 * @export
 * @interface CityDistrictFeatureProperties
 */
export interface CityDistrictFeatureProperties {
    /**
     * 
     * @type {number}
     * @memberof CityDistrictFeatureProperties
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CityDistrictFeatureProperties
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CityDistrictFeatureProperties
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof CityDistrictFeatureProperties
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface EnergeticsAddress
 */
export interface EnergeticsAddress {
    /**
     * 
     * @type {string}
     * @memberof EnergeticsAddress
     */
    'street'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsAddress
     */
    'house_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsAddress
     */
    'city'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsAddress
     */
    'country'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsAddress
     */
    'mail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsAddress
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsAddress
     */
    'web_address'?: string | null;
}
/**
 * 
 * @export
 * @interface EnergeticsBuildingFull
 */
export interface EnergeticsBuildingFull {
    /**
     * 
     * @type {number}
     * @memberof EnergeticsBuildingFull
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFull
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFull
     */
    'main_use'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFull
     */
    'method_of_protection'?: string | null;
    /**
     * 
     * @type {EnergeticsBuildingFullAddress}
     * @memberof EnergeticsBuildingFull
     */
    'address'?: EnergeticsBuildingFullAddress | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFull
     */
    'allotment_number'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EnergeticsBuildingFull
     */
    'beds_count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFull
     */
    'building_address_code'?: string | null;
    /**
     * 
     * @type {EnergeticsBuildingFullBuildingEnvelope}
     * @memberof EnergeticsBuildingFull
     */
    'building_envelope'?: EnergeticsBuildingFullBuildingEnvelope | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFull
     */
    'label'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EnergeticsBuildingFull
     */
    'built_up_area'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof EnergeticsBuildingFull
     */
    'classrooms_count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFull
     */
    'csu_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFull
     */
    'current_note'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFull
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EnergeticsBuildingFull
     */
    'employees_count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFull
     */
    'energetic_management'?: string | null;
    /**
     * 
     * @type {EnergeticsBuildingFullEnergyAudits}
     * @memberof EnergeticsBuildingFull
     */
    'energy_audits'?: EnergeticsBuildingFullEnergyAudits | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFull
     */
    'eno_id'?: string | null;
    /**
     * 
     * @type {EnergeticsBuildingFullFuelAndEnergy}
     * @memberof EnergeticsBuildingFull
     */
    'fuel_and_energy'?: EnergeticsBuildingFullFuelAndEnergy | null;
    /**
     * 
     * @type {number}
     * @memberof EnergeticsBuildingFull
     */
    'heated_bulding_volume'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFull
     */
    'ku_code'?: string | null;
    /**
     * 
     * @type {EnergeticsBuildingFullLocation}
     * @memberof EnergeticsBuildingFull
     */
    'location'?: EnergeticsBuildingFullLocation | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFull
     */
    'link'?: string;
    /**
     * 
     * @type {EnergeticsBuildingFullOzeEnergyProduction}
     * @memberof EnergeticsBuildingFull
     */
    'oze_energy_production'?: EnergeticsBuildingFullOzeEnergyProduction | null;
    /**
     * 
     * @type {EnergeticsBuildingFullPenb}
     * @memberof EnergeticsBuildingFull
     */
    'penb'?: EnergeticsBuildingFullPenb | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFull
     */
    'registration_unit'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFull
     */
    'secondary_use'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EnergeticsBuildingFull
     */
    'students_count'?: number | null;
    /**
     * 
     * @type {EnergeticsBuildingFullTechnicalEquipment}
     * @memberof EnergeticsBuildingFull
     */
    'technical_equipment'?: EnergeticsBuildingFullTechnicalEquipment | null;
    /**
     * 
     * @type {EnergeticsBuildingFullWasteAndEmissions}
     * @memberof EnergeticsBuildingFull
     */
    'waste_and_emissions'?: EnergeticsBuildingFullWasteAndEmissions | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFull
     */
    'weekend_opening_hours'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFull
     */
    'opening_hours'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EnergeticsBuildingFull
     */
    'year_of_construction'?: number | null;
}
/**
 * 
 * @export
 * @interface EnergeticsBuildingFullAddress
 */
export interface EnergeticsBuildingFullAddress {
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullAddress
     */
    'city'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullAddress
     */
    'country'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullAddress
     */
    'house_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullAddress
     */
    'mail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullAddress
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullAddress
     */
    'street'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullAddress
     */
    'web_address'?: string | null;
}
/**
 * 
 * @export
 * @interface EnergeticsBuildingFullBuildingEnvelope
 */
export interface EnergeticsBuildingFullBuildingEnvelope {
    /**
     * 
     * @type {EnergeticsBuildingFullBuildingEnvelopeFillingOfHole}
     * @memberof EnergeticsBuildingFullBuildingEnvelope
     */
    'filling_of_hole'?: EnergeticsBuildingFullBuildingEnvelopeFillingOfHole | null;
    /**
     * 
     * @type {EnergeticsBuildingFullBuildingEnvelopeFloorOfTheLowestHeatedFloor}
     * @memberof EnergeticsBuildingFullBuildingEnvelope
     */
    'floor_of_the_lowest_heated_floor'?: EnergeticsBuildingFullBuildingEnvelopeFloorOfTheLowestHeatedFloor | null;
    /**
     * 
     * @type {EnergeticsBuildingFullBuildingEnvelopeRoof}
     * @memberof EnergeticsBuildingFullBuildingEnvelope
     */
    'roof'?: EnergeticsBuildingFullBuildingEnvelopeRoof | null;
    /**
     * 
     * @type {EnergeticsBuildingFullBuildingEnvelopeSideWall}
     * @memberof EnergeticsBuildingFullBuildingEnvelope
     */
    'side_wall'?: EnergeticsBuildingFullBuildingEnvelopeSideWall | null;
}
/**
 * 
 * @export
 * @interface EnergeticsBuildingFullBuildingEnvelopeFillingOfHole
 */
export interface EnergeticsBuildingFullBuildingEnvelopeFillingOfHole {
    /**
     * 
     * @type {number}
     * @memberof EnergeticsBuildingFullBuildingEnvelopeFillingOfHole
     */
    'area'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullBuildingEnvelopeFillingOfHole
     */
    'construction'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullBuildingEnvelopeFillingOfHole
     */
    'technical_condition'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullBuildingEnvelopeFillingOfHole
     */
    'year_of_adjustment'?: string | null;
}
/**
 * 
 * @export
 * @interface EnergeticsBuildingFullBuildingEnvelopeFloorOfTheLowestHeatedFloor
 */
export interface EnergeticsBuildingFullBuildingEnvelopeFloorOfTheLowestHeatedFloor {
    /**
     * 
     * @type {number}
     * @memberof EnergeticsBuildingFullBuildingEnvelopeFloorOfTheLowestHeatedFloor
     */
    'area'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullBuildingEnvelopeFloorOfTheLowestHeatedFloor
     */
    'construction'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullBuildingEnvelopeFloorOfTheLowestHeatedFloor
     */
    'year_of_adjustment'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullBuildingEnvelopeFloorOfTheLowestHeatedFloor
     */
    'technical_condition'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullBuildingEnvelopeFloorOfTheLowestHeatedFloor
     */
    'thermal_insulation'?: string | null;
}
/**
 * 
 * @export
 * @interface EnergeticsBuildingFullBuildingEnvelopeRoof
 */
export interface EnergeticsBuildingFullBuildingEnvelopeRoof {
    /**
     * 
     * @type {number}
     * @memberof EnergeticsBuildingFullBuildingEnvelopeRoof
     */
    'area'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullBuildingEnvelopeRoof
     */
    'construction'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullBuildingEnvelopeRoof
     */
    'technical_condition'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullBuildingEnvelopeRoof
     */
    'thermal_insulation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullBuildingEnvelopeRoof
     */
    'year_of_adjustment'?: string | null;
}
/**
 * 
 * @export
 * @interface EnergeticsBuildingFullBuildingEnvelopeSideWall
 */
export interface EnergeticsBuildingFullBuildingEnvelopeSideWall {
    /**
     * 
     * @type {number}
     * @memberof EnergeticsBuildingFullBuildingEnvelopeSideWall
     */
    'area'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullBuildingEnvelopeSideWall
     */
    'heat_insulation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullBuildingEnvelopeSideWall
     */
    'prevailing_construction'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullBuildingEnvelopeSideWall
     */
    'technical_condition'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullBuildingEnvelopeSideWall
     */
    'year_of_adjustment'?: string | null;
}
/**
 * 
 * @export
 * @interface EnergeticsBuildingFullEnergyAudits
 */
export interface EnergeticsBuildingFullEnergyAudits {
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullEnergyAudits
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullEnergyAudits
     */
    'ea_registration_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullEnergyAudits
     */
    'energy_audit'?: string | null;
}
/**
 * 
 * @export
 * @interface EnergeticsBuildingFullFuelAndEnergy
 */
export interface EnergeticsBuildingFullFuelAndEnergy {
    /**
     * 
     * @type {boolean}
     * @memberof EnergeticsBuildingFullFuelAndEnergy
     */
    'coal'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof EnergeticsBuildingFullFuelAndEnergy
     */
    'czt'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof EnergeticsBuildingFullFuelAndEnergy
     */
    'electricity'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof EnergeticsBuildingFullFuelAndEnergy
     */
    'gas'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof EnergeticsBuildingFullFuelAndEnergy
     */
    'other'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof EnergeticsBuildingFullFuelAndEnergy
     */
    'oze'?: boolean | null;
}
/**
 * 
 * @export
 * @interface EnergeticsBuildingFullLocation
 */
export interface EnergeticsBuildingFullLocation {
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullLocation
     */
    'type': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof EnergeticsBuildingFullLocation
     */
    'coordinates': Array<number>;
}
/**
 * 
 * @export
 * @interface EnergeticsBuildingFullOzeEnergyProduction
 */
export interface EnergeticsBuildingFullOzeEnergyProduction {
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullOzeEnergyProduction
     */
    'heat_pump'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullOzeEnergyProduction
     */
    'integrated_turbines_wind_energy'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullOzeEnergyProduction
     */
    'solar_energy_photothermal'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullOzeEnergyProduction
     */
    'solar_energy_photovoltaic'?: string | null;
}
/**
 * 
 * @export
 * @interface EnergeticsBuildingFullPenb
 */
export interface EnergeticsBuildingFullPenb {
    /**
     * 
     * @type {number}
     * @memberof EnergeticsBuildingFullPenb
     */
    'building_envelope'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullPenb
     */
    'building_envelope_category'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EnergeticsBuildingFullPenb
     */
    'cooling'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullPenb
     */
    'cooling_category'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EnergeticsBuildingFullPenb
     */
    'heating'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullPenb
     */
    'heating_category'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EnergeticsBuildingFullPenb
     */
    'humidity_adjustment'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullPenb
     */
    'humidity_adjustment_category'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullPenb
     */
    'issue_date'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EnergeticsBuildingFullPenb
     */
    'lighting'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullPenb
     */
    'lighting_category'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EnergeticsBuildingFullPenb
     */
    'penb_number'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof EnergeticsBuildingFullPenb
     */
    'primary_non_renewable_energy'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullPenb
     */
    'primary_non_renewable_energy_category'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EnergeticsBuildingFullPenb
     */
    'total_building_envelope_area'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof EnergeticsBuildingFullPenb
     */
    'total_energy_reference_area'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof EnergeticsBuildingFullPenb
     */
    'total_provided_energy'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullPenb
     */
    'total_provided_energy_category'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EnergeticsBuildingFullPenb
     */
    'ventilation'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullPenb
     */
    'ventilation_category'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullPenb
     */
    'volume_factor_of_av_shape'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EnergeticsBuildingFullPenb
     */
    'warm_water'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullPenb
     */
    'warm_water_category'?: string | null;
}
/**
 * 
 * @export
 * @interface EnergeticsBuildingFullTechnicalEquipment
 */
export interface EnergeticsBuildingFullTechnicalEquipment {
    /**
     * 
     * @type {EnergeticsBuildingFullTechnicalEquipmentCooling}
     * @memberof EnergeticsBuildingFullTechnicalEquipment
     */
    'cooling'?: EnergeticsBuildingFullTechnicalEquipmentCooling | null;
    /**
     * 
     * @type {EnergeticsBuildingFullTechnicalEquipmentHeating}
     * @memberof EnergeticsBuildingFullTechnicalEquipment
     */
    'heating'?: EnergeticsBuildingFullTechnicalEquipmentHeating | null;
    /**
     * 
     * @type {EnergeticsBuildingFullTechnicalEquipmentHotWater}
     * @memberof EnergeticsBuildingFullTechnicalEquipment
     */
    'hot_water'?: EnergeticsBuildingFullTechnicalEquipmentHotWater | null;
    /**
     * 
     * @type {EnergeticsBuildingFullTechnicalEquipmentHumidityAdjustment}
     * @memberof EnergeticsBuildingFullTechnicalEquipment
     */
    'humidity_adjustment'?: EnergeticsBuildingFullTechnicalEquipmentHumidityAdjustment | null;
    /**
     * 
     * @type {EnergeticsBuildingFullTechnicalEquipmentLighting}
     * @memberof EnergeticsBuildingFullTechnicalEquipment
     */
    'lighting'?: EnergeticsBuildingFullTechnicalEquipmentLighting | null;
    /**
     * 
     * @type {EnergeticsBuildingFullTechnicalEquipmentVentilation}
     * @memberof EnergeticsBuildingFullTechnicalEquipment
     */
    'ventilation'?: EnergeticsBuildingFullTechnicalEquipmentVentilation | null;
}
/**
 * 
 * @export
 * @interface EnergeticsBuildingFullTechnicalEquipmentCooling
 */
export interface EnergeticsBuildingFullTechnicalEquipmentCooling {
    /**
     * 
     * @type {number}
     * @memberof EnergeticsBuildingFullTechnicalEquipmentCooling
     */
    'cooling_area_percentage'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullTechnicalEquipmentCooling
     */
    'cooling_system'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullTechnicalEquipmentCooling
     */
    'technical_condition'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullTechnicalEquipmentCooling
     */
    'year'?: string | null;
}
/**
 * 
 * @export
 * @interface EnergeticsBuildingFullTechnicalEquipmentHeating
 */
export interface EnergeticsBuildingFullTechnicalEquipmentHeating {
    /**
     * 
     * @type {number}
     * @memberof EnergeticsBuildingFullTechnicalEquipmentHeating
     */
    'heat_percentage'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullTechnicalEquipmentHeating
     */
    'heating_system'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullTechnicalEquipmentHeating
     */
    'main_source_of_heat'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullTechnicalEquipmentHeating
     */
    'secondary_source_of_heat'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullTechnicalEquipmentHeating
     */
    'technical_condition'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullTechnicalEquipmentHeating
     */
    'year'?: string | null;
}
/**
 * 
 * @export
 * @interface EnergeticsBuildingFullTechnicalEquipmentHotWater
 */
export interface EnergeticsBuildingFullTechnicalEquipmentHotWater {
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullTechnicalEquipmentHotWater
     */
    'hot_water_source'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullTechnicalEquipmentHotWater
     */
    'predominant_way_of_heating_tv'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullTechnicalEquipmentHotWater
     */
    'technical_condition'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullTechnicalEquipmentHotWater
     */
    'year'?: string | null;
}
/**
 * 
 * @export
 * @interface EnergeticsBuildingFullTechnicalEquipmentHumidityAdjustment
 */
export interface EnergeticsBuildingFullTechnicalEquipmentHumidityAdjustment {
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullTechnicalEquipmentHumidityAdjustment
     */
    'humidity_adjustment'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullTechnicalEquipmentHumidityAdjustment
     */
    'technical_condition'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullTechnicalEquipmentHumidityAdjustment
     */
    'year'?: string | null;
}
/**
 * 
 * @export
 * @interface EnergeticsBuildingFullTechnicalEquipmentLighting
 */
export interface EnergeticsBuildingFullTechnicalEquipmentLighting {
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullTechnicalEquipmentLighting
     */
    'lighting'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullTechnicalEquipmentLighting
     */
    'measurement_method'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullTechnicalEquipmentLighting
     */
    'other_technological_elements'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullTechnicalEquipmentLighting
     */
    'technical_condition'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullTechnicalEquipmentLighting
     */
    'year'?: string | null;
}
/**
 * 
 * @export
 * @interface EnergeticsBuildingFullTechnicalEquipmentVentilation
 */
export interface EnergeticsBuildingFullTechnicalEquipmentVentilation {
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullTechnicalEquipmentVentilation
     */
    'technical_condition'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullTechnicalEquipmentVentilation
     */
    'ventilation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullTechnicalEquipmentVentilation
     */
    'year'?: string | null;
}
/**
 * 
 * @export
 * @interface EnergeticsBuildingFullWasteAndEmissions
 */
export interface EnergeticsBuildingFullWasteAndEmissions {
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullWasteAndEmissions
     */
    'operating_co2_emissions'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullWasteAndEmissions
     */
    'solid_waste_production'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullWasteAndEmissions
     */
    'sox_emissions'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingFullWasteAndEmissions
     */
    'tied_co2_emissions'?: string | null;
}
/**
 * 
 * @export
 * @interface EnergeticsBuildingShort
 */
export interface EnergeticsBuildingShort {
    /**
     * 
     * @type {number}
     * @memberof EnergeticsBuildingShort
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingShort
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingShort
     */
    'building_address_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsBuildingShort
     */
    'link'?: string;
}
/**
 * 
 * @export
 * @interface EnergeticsDevice
 */
export interface EnergeticsDevice {
    /**
     * 
     * @type {number}
     * @memberof EnergeticsDevice
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsDevice
     */
    'addr'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsDevice
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsDevice
     */
    'meter_number'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EnergeticsDevice
     */
    'meter_index'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsDevice
     */
    'location_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsDevice
     */
    'location_description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsDevice
     */
    'include_in_evaluation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsDevice
     */
    'meter_type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsDevice
     */
    'category'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsDevice
     */
    'unit'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsDevice
     */
    'replaced_meter_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsDevice
     */
    'deleted'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EnergeticsDevice
     */
    'building_id'?: number | null;
}
/**
 * 
 * @export
 * @interface EnergeticsMeasurement
 */
export interface EnergeticsMeasurement {
    /**
     * 
     * @type {string}
     * @memberof EnergeticsMeasurement
     */
    'time'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsMeasurement
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsMeasurement
     */
    'addr'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsMeasurement
     */
    'meter'?: string | null;
    /**
     * 
     * @type {EnergeticsTypes}
     * @memberof EnergeticsMeasurement
     */
    'type'?: EnergeticsTypes;
    /**
     * 
     * @type {EnergeticsVariables}
     * @memberof EnergeticsMeasurement
     */
    'var'?: EnergeticsVariables;
}


/**
 * 
 * @export
 * @interface EnergeticsOrganizationFull
 */
export interface EnergeticsOrganizationFull {
    /**
     * 
     * @type {number}
     * @memberof EnergeticsOrganizationFull
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsOrganizationFull
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsOrganizationFull
     */
    'label'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsOrganizationFull
     */
    'category'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsOrganizationFull
     */
    'created_by_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsOrganizationFull
     */
    'grafana_url'?: string | null;
    /**
     * 
     * @type {EnergeticsAddress}
     * @memberof EnergeticsOrganizationFull
     */
    'address'?: EnergeticsAddress;
    /**
     * 
     * @type {Array<EnergeticsUser>}
     * @memberof EnergeticsOrganizationFull
     */
    'responsible_user'?: Array<EnergeticsUser> | null;
    /**
     * 
     * @type {Array<EnergeticsBuildingShort>}
     * @memberof EnergeticsOrganizationFull
     */
    'buildings'?: Array<EnergeticsBuildingShort> | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsOrganizationFull
     */
    'link'?: string | null;
}
/**
 * 
 * @export
 * @interface EnergeticsOrganizationShort
 */
export interface EnergeticsOrganizationShort {
    /**
     * 
     * @type {number}
     * @memberof EnergeticsOrganizationShort
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsOrganizationShort
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsOrganizationShort
     */
    'link'?: string | null;
}
/**
 * monthly_reading - hodnoty sƒç√≠tan√© po mƒõs√≠c√≠ch z 15 minutov√Ωch spot≈ôeb poskytovan√Ωch firmou PRE<br /> provider_value - data z√≠skan√° od poskytovatel≈Ø energi√≠<br /> dotcontrols_value - data z√≠skan√° ze syst√©m≈Ø VisApp firmy DotControls<br />
 * @export
 * @enum {string}
 */

export const EnergeticsTypes = {
    MonthlyReading: 'monthly_reading',
    ProviderValue: 'provider_value',
    DotcontrolsValue: 'dotcontrols_value'
} as const;

export type EnergeticsTypes = typeof EnergeticsTypes[keyof typeof EnergeticsTypes];

/**
 * 
 * @export
 * @interface EnergeticsUser
 */
export interface EnergeticsUser {
    /**
     * 
     * @type {string}
     * @memberof EnergeticsUser
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsUser
     */
    'last_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsUser
     */
    'position'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsUser
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsUser
     */
    'mail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnergeticsUser
     */
    'company'?: string | null;
}
/**
 * core - Kumulovan√Ω objem [m3]<br /> core2 - Kumulovan√Ω p≈ôepoƒç√≠tan√Ω objem [Nm3]<br /> EFwActi - Odbƒõr ƒçinn√© energie [kWh]<br /> EFwActiVT - Odbƒõr ƒçinn√© energie, vysok√Ω tarif [kVArh]<br /> ERvReact - Dod√°vka jalov√© energie [kVArh]<br /> EFwReact - Odbƒõr jalov√© energie [kVArh]<br /> raw - ƒå√≠seln√≠k impulz≈Ø [imp]<br /> RSSI - S√≠la sign√°lu [dBm]<br /> T - Teplota [¬∞C]<br /> CO2 - Koncentrace CO2 [ppm]<br /> RH - Relativn√≠ vlhkost [%]<br /> EFwActiNT - Odbƒõr ƒçinn√© energie, n√≠zk√Ω tarif [kVArh]<br /> VOC - M√≠ra koncentrace tƒõkav√Ωch l√°tek [%]<br /> VT - Vysok√Ω tarif [kWh]<br /> NT - N√≠zk√Ω tarif [kWh]<br />
 * @export
 * @enum {string}
 */

export const EnergeticsVariables = {
    Core: 'core',
    Core2: 'core2',
    EfwActi: 'EFwActi',
    EfwActiVt: 'EFwActiVT',
    ErvReact: 'ERvReact',
    EfwReact: 'EFwReact',
    Raw: 'raw',
    T: 'T',
    Co2: 'CO2',
    Rh: 'RH',
    EfwActiNt: 'EFwActiNT',
    Voc: 'VOC'
} as const;

export type EnergeticsVariables = typeof EnergeticsVariables[keyof typeof EnergeticsVariables];

/**
 * 
 * @export
 * @interface Error1
 */
export interface Error1 {
    /**
     * 
     * @type {string}
     * @memberof Error1
     */
    'error_message': string;
    /**
     * 
     * @type {number}
     * @memberof Error1
     */
    'error_status': number;
}
/**
 * 
 * @export
 * @interface FCDElaboratedData
 */
export interface FCDElaboratedData {
    /**
     * 
     * @type {string}
     * @memberof FCDElaboratedData
     */
    'measurementOrCalculationTime': string;
    /**
     * 
     * @type {string}
     * @memberof FCDElaboratedData
     */
    'sourceIdentification': string;
    /**
     * 
     * @type {string}
     * @memberof FCDElaboratedData
     */
    'supplierCalculatedDataQuality': string;
    /**
     * 
     * @type {string}
     * @memberof FCDElaboratedData
     */
    'numberOfInputValuesUsed': string;
    /**
     * 
     * @type {string}
     * @memberof FCDElaboratedData
     */
    'predefinedLocationId': string;
    /**
     * 
     * @type {string}
     * @memberof FCDElaboratedData
     */
    'trafficLevel': string;
    /**
     * 
     * @type {string}
     * @memberof FCDElaboratedData
     */
    'averageVehicleSpeed': string;
    /**
     * 
     * @type {string}
     * @memberof FCDElaboratedData
     */
    'travelTime': string;
    /**
     * 
     * @type {string}
     * @memberof FCDElaboratedData
     */
    'freeFlowTravelTime': string;
    /**
     * 
     * @type {string}
     * @memberof FCDElaboratedData
     */
    'freeFlowSpeed': string;
    /**
     * 
     * @type {string}
     * @memberof FCDElaboratedData
     */
    'queueExists'?: string;
    /**
     * 
     * @type {string}
     * @memberof FCDElaboratedData
     */
    'queueLength'?: string;
    /**
     * 
     * @type {string}
     * @memberof FCDElaboratedData
     */
    'fromPoint'?: string;
    /**
     * 
     * @type {string}
     * @memberof FCDElaboratedData
     */
    'toPoint'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof FCDElaboratedData
     */
    'osmPath'?: Array<number> | null;
}
/**
 * 
 * @export
 * @interface FeaturePoint
 */
export interface FeaturePoint {
    /**
     * 
     * @type {FeaturePointGeometry}
     * @memberof FeaturePoint
     */
    'geometry': FeaturePointGeometry;
    /**
     * 
     * @type {AirQualityStation}
     * @memberof FeaturePoint
     */
    'properties': AirQualityStation;
    /**
     * 
     * @type {string}
     * @memberof FeaturePoint
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface FeaturePoint1
 */
export interface FeaturePoint1 {
    /**
     * 
     * @type {FeaturePoint1Geometry}
     * @memberof FeaturePoint1
     */
    'geometry': FeaturePoint1Geometry;
    /**
     * 
     * @type {BicycleCounter}
     * @memberof FeaturePoint1
     */
    'properties': BicycleCounter;
    /**
     * 
     * @type {string}
     * @memberof FeaturePoint1
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface FeaturePoint1Geometry
 */
export interface FeaturePoint1Geometry {
    /**
     * 
     * @type {string}
     * @memberof FeaturePoint1Geometry
     */
    'type': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof FeaturePoint1Geometry
     */
    'coordinates': Array<number>;
}
/**
 * 
 * @export
 * @interface FeaturePointGeometry
 */
export interface FeaturePointGeometry {
    /**
     * 
     * @type {string}
     * @memberof FeaturePointGeometry
     */
    'type': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof FeaturePointGeometry
     */
    'coordinates': Array<number>;
}
/**
 * 
 * @export
 * @interface FloatingCarDataPublication
 */
export interface FloatingCarDataPublication {
    /**
     * 
     * @type {string}
     * @memberof FloatingCarDataPublication
     */
    'modelBaseVersion'?: string;
    /**
     * 
     * @type {FloatingCarDataPublicationSituationPublicationLight}
     * @memberof FloatingCarDataPublication
     */
    'situationPublicationLight'?: FloatingCarDataPublicationSituationPublicationLight;
}
/**
 * 
 * @export
 * @interface FloatingCarDataPublicationSituationPublicationLight
 */
export interface FloatingCarDataPublicationSituationPublicationLight {
    /**
     * 
     * @type {string}
     * @memberof FloatingCarDataPublicationSituationPublicationLight
     */
    'lang'?: string;
    /**
     * 
     * @type {string}
     * @memberof FloatingCarDataPublicationSituationPublicationLight
     */
    'publicationTime'?: string;
    /**
     * 
     * @type {FloatingCarDataPublicationSituationPublicationLightPublicationCreator}
     * @memberof FloatingCarDataPublicationSituationPublicationLight
     */
    'publicationCreator'?: FloatingCarDataPublicationSituationPublicationLightPublicationCreator;
    /**
     * 
     * @type {Array<FCDElaboratedData>}
     * @memberof FloatingCarDataPublicationSituationPublicationLight
     */
    'elaboratedData'?: Array<FCDElaboratedData>;
}
/**
 * 
 * @export
 * @interface FloatingCarDataPublicationSituationPublicationLightPublicationCreator
 */
export interface FloatingCarDataPublicationSituationPublicationLightPublicationCreator {
    /**
     * 
     * @type {string}
     * @memberof FloatingCarDataPublicationSituationPublicationLightPublicationCreator
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof FloatingCarDataPublicationSituationPublicationLightPublicationCreator
     */
    'nationalIdentifier'?: string;
}
/**
 * 
 * @export
 * @interface FreeVehicleStatusMVTS
 */
export interface FreeVehicleStatusMVTS {
    /**
     * 
     * @type {number}
     * @memberof FreeVehicleStatusMVTS
     */
    'version'?: number;
    /**
     * 
     * @type {string}
     * @memberof FreeVehicleStatusMVTS
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof FreeVehicleStatusMVTS
     */
    'extent'?: number;
    /**
     * 
     * @type {number}
     * @memberof FreeVehicleStatusMVTS
     */
    'length'?: number;
    /**
     * 
     * @type {FreeVehicleStatusMVTSPbf}
     * @memberof FreeVehicleStatusMVTS
     */
    '_pbf'?: FreeVehicleStatusMVTSPbf;
    /**
     * 
     * @type {Array<string>}
     * @memberof FreeVehicleStatusMVTS
     */
    '_keys'?: Array<string>;
    /**
     * 
     * @type {Array<FreeVehicleStatusMVTSValuesInner>}
     * @memberof FreeVehicleStatusMVTS
     */
    '_values'?: Array<FreeVehicleStatusMVTSValuesInner>;
    /**
     * 
     * @type {Array<number>}
     * @memberof FreeVehicleStatusMVTS
     */
    '_features'?: Array<number>;
}
/**
 * 
 * @export
 * @interface FreeVehicleStatusMVTSPbf
 */
export interface FreeVehicleStatusMVTSPbf {
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof FreeVehicleStatusMVTSPbf
     */
    'buf'?: { [key: string]: number; };
    /**
     * 
     * @type {number}
     * @memberof FreeVehicleStatusMVTSPbf
     */
    'pos'?: number;
    /**
     * 
     * @type {number}
     * @memberof FreeVehicleStatusMVTSPbf
     */
    'type'?: number;
    /**
     * 
     * @type {number}
     * @memberof FreeVehicleStatusMVTSPbf
     */
    'length'?: number;
}
/**
 * @type FreeVehicleStatusMVTSValuesInner
 * @export
 */
export type FreeVehicleStatusMVTSValuesInner = boolean | number | string;
/**
 * Describes the vehicles that are available for rent (as of v2.1-RC2).
 * @export
 * @interface GBFSFreeBikeStatusJson
 */
export interface GBFSFreeBikeStatusJson {
    /**
     * 
     * @type {Array<GBFSFreeBikeStatusJsonBikesInner>}
     * @memberof GBFSFreeBikeStatusJson
     */
    'bikes': Array<GBFSFreeBikeStatusJsonBikesInner>;
}
/**
 * 
 * @export
 * @interface GBFSFreeBikeStatusJsonBikesInner
 */
export interface GBFSFreeBikeStatusJsonBikesInner {
    /**
     * Rotating (as of v2.0) identifier of a vehicle.
     * @type {string}
     * @memberof GBFSFreeBikeStatusJsonBikesInner
     */
    'bike_id': string;
    /**
     * The latitude of the vehicle.
     * @type {number}
     * @memberof GBFSFreeBikeStatusJsonBikesInner
     */
    'lat'?: number;
    /**
     * The longitude of the vehicle.
     * @type {number}
     * @memberof GBFSFreeBikeStatusJsonBikesInner
     */
    'lon'?: number;
    /**
     * Is the vehicle currently reserved?
     * @type {boolean}
     * @memberof GBFSFreeBikeStatusJsonBikesInner
     */
    'is_reserved': boolean;
    /**
     * Is the vehicle currently disabled (broken)?
     * @type {boolean}
     * @memberof GBFSFreeBikeStatusJsonBikesInner
     */
    'is_disabled': boolean;
    /**
     * 
     * @type {GBFSFreeBikeStatusJsonBikesInnerRentalUris}
     * @memberof GBFSFreeBikeStatusJsonBikesInner
     */
    'rental_uris'?: GBFSFreeBikeStatusJsonBikesInnerRentalUris;
    /**
     * The vehicle_type_id of this vehicle (added in v2.1-RC).
     * @type {string}
     * @memberof GBFSFreeBikeStatusJsonBikesInner
     */
    'vehicle_type_id'?: string;
    /**
     * The last time this vehicle reported its status to the operator\'s backend in POSIX time (added in v2.1-RC).
     * @type {number}
     * @memberof GBFSFreeBikeStatusJsonBikesInner
     */
    'last_reported'?: number;
    /**
     * The furthest distance in meters that the vehicle can travel without recharging or refueling with the vehicle\'s current charge or fuel (added in v2.1-RC).
     * @type {number}
     * @memberof GBFSFreeBikeStatusJsonBikesInner
     */
    'current_range_meters'?: number;
    /**
     * REQUIRED only if the vehicle is using nonhuman fuel type and measures the remaining fuel capacity.
     * @type {number}
     * @memberof GBFSFreeBikeStatusJsonBikesInner
     */
    'charge_percent'?: number;
    /**
     * Identifier referencing the station_id if the vehicle is currently at a station (added in v2.1-RC2).
     * @type {string}
     * @memberof GBFSFreeBikeStatusJsonBikesInner
     */
    'station_id'?: string;
    /**
     * The plan_id of the pricing plan this vehicle is eligible for (added in v2.1-RC2).
     * @type {string}
     * @memberof GBFSFreeBikeStatusJsonBikesInner
     */
    'pricing_plan_id'?: string;
    /**
     * The name of the vehicle manufacturer. (added in OICT fork)
     * @type {string}
     * @memberof GBFSFreeBikeStatusJsonBikesInner
     */
    'make'?: string;
    /**
     * The name of the vehicle model. (added in OICT fork)
     * @type {string}
     * @memberof GBFSFreeBikeStatusJsonBikesInner
     */
    'model'?: string;
    /**
     * The color of the vehicle. (added in OICT fork)
     * @type {string}
     * @memberof GBFSFreeBikeStatusJsonBikesInner
     */
    'color'?: string;
}
/**
 * 
 * @export
 * @interface GBFSFreeBikeStatusJsonBikesInnerAnyOf
 */
export interface GBFSFreeBikeStatusJsonBikesInnerAnyOf {
    /**
     * 
     * @type {any}
     * @memberof GBFSFreeBikeStatusJsonBikesInnerAnyOf
     */
    'lat'?: any;
    /**
     * 
     * @type {any}
     * @memberof GBFSFreeBikeStatusJsonBikesInnerAnyOf
     */
    'lon'?: any;
}
/**
 * Contains rental uris for Android, iOS, and web in the android, ios, and web fields (added in v1.1).
 * @export
 * @interface GBFSFreeBikeStatusJsonBikesInnerRentalUris
 */
export interface GBFSFreeBikeStatusJsonBikesInnerRentalUris {
    /**
     * URI that can be passed to an Android app with an intent (added in v1.1).
     * @type {string}
     * @memberof GBFSFreeBikeStatusJsonBikesInnerRentalUris
     */
    'android'?: string;
    /**
     * URI that can be used on iOS to launch the rental app for this vehicle (added in v1.1).
     * @type {string}
     * @memberof GBFSFreeBikeStatusJsonBikesInnerRentalUris
     */
    'ios'?: string;
    /**
     * URL that can be used by a web browser to show more information about renting this vehicle (added in v1.1).
     * @type {string}
     * @memberof GBFSFreeBikeStatusJsonBikesInnerRentalUris
     */
    'web'?: string;
}
/**
 * Describes geofencing zones and their associated rules and attributes (added in v2.1-RC).
 * @export
 * @interface GBFSGeofencingZonesJson
 */
export interface GBFSGeofencingZonesJson {
    /**
     * 
     * @type {GBFSGeofencingZonesJsonGeofencingZones}
     * @memberof GBFSGeofencingZonesJson
     */
    'geofencing_zones'?: GBFSGeofencingZonesJsonGeofencingZones;
}
/**
 * Each geofenced zone and its associated rules and attributes is described as an object within the array of features.
 * @export
 * @interface GBFSGeofencingZonesJsonGeofencingZones
 */
export interface GBFSGeofencingZonesJsonGeofencingZones {
    /**
     * FeatureCollection as per IETF RFC 7946.
     * @type {string}
     * @memberof GBFSGeofencingZonesJsonGeofencingZones
     */
    'type': GBFSGeofencingZonesJsonGeofencingZonesTypeEnum;
    /**
     * Array of objects.
     * @type {Array<GeoJSONFeature>}
     * @memberof GBFSGeofencingZonesJsonGeofencingZones
     */
    'features': Array<GeoJSONFeature>;
}

export const GBFSGeofencingZonesJsonGeofencingZonesTypeEnum = {
    FeatureCollection: 'FeatureCollection'
} as const;

export type GBFSGeofencingZonesJsonGeofencingZonesTypeEnum = typeof GBFSGeofencingZonesJsonGeofencingZonesTypeEnum[keyof typeof GBFSGeofencingZonesJsonGeofencingZonesTypeEnum];

/**
 * property names pattern ^[a-z]{2,3}(-[A-Z]{2})?$
 * @export
 * @interface GBFSJsonValue
 */
export interface GBFSJsonValue {
    /**
     * An array of all of the feeds that are published by the auto-discovery file. Each element in the array is an object with the keys below.
     * @type {Array<GBFSJsonValueFeedsInner>}
     * @memberof GBFSJsonValue
     */
    'feeds': Array<GBFSJsonValueFeedsInner>;
}
/**
 * 
 * @export
 * @interface GBFSJsonValueFeedsInner
 */
export interface GBFSJsonValueFeedsInner {
    /**
     * Key identifying the type of feed this is. The key must be the base file name defined in the spec for the corresponding feed type.
     * @type {string}
     * @memberof GBFSJsonValueFeedsInner
     */
    'name': GBFSJsonValueFeedsInnerNameEnum;
    /**
     * URL for the feed.
     * @type {string}
     * @memberof GBFSJsonValueFeedsInner
     */
    'url': string;
}

export const GBFSJsonValueFeedsInnerNameEnum = {
    Gbfs: 'gbfs',
    GbfsVersions: 'gbfs_versions',
    SystemInformation: 'system_information',
    VehicleTypes: 'vehicle_types',
    StationInformation: 'station_information',
    StationStatus: 'station_status',
    FreeBikeStatus: 'free_bike_status',
    SystemHours: 'system_hours',
    SystemAlerts: 'system_alerts',
    SystemCalendar: 'system_calendar',
    SystemRegions: 'system_regions',
    SystemPricingPlans: 'system_pricing_plans',
    GeofencingZones: 'geofencing_zones'
} as const;

export type GBFSJsonValueFeedsInnerNameEnum = typeof GBFSJsonValueFeedsInnerNameEnum[keyof typeof GBFSJsonValueFeedsInnerNameEnum];

/**
 * Details including system operator, system location, year implemented, URL, contact info, time zone.
 * @export
 * @interface GBFSStationInformationJson
 */
export interface GBFSStationInformationJson {
    /**
     * 
     * @type {Array<GBFSStationInformationJsonStationsInner>}
     * @memberof GBFSStationInformationJson
     */
    'stations': Array<GBFSStationInformationJsonStationsInner>;
}
/**
 * 
 * @export
 * @interface GBFSStationInformationJsonStationsInner
 */
export interface GBFSStationInformationJsonStationsInner {
    /**
     * Identifier of a station.
     * @type {string}
     * @memberof GBFSStationInformationJsonStationsInner
     */
    'station_id': string;
    /**
     * Public name of the station.
     * @type {string}
     * @memberof GBFSStationInformationJsonStationsInner
     */
    'name': string;
    /**
     * Short name or other type of identifier.
     * @type {string}
     * @memberof GBFSStationInformationJsonStationsInner
     */
    'short_name'?: string;
    /**
     * The latitude of the station.
     * @type {number}
     * @memberof GBFSStationInformationJsonStationsInner
     */
    'lat': number;
    /**
     * The longitude fo the station.
     * @type {number}
     * @memberof GBFSStationInformationJsonStationsInner
     */
    'lon': number;
    /**
     * Address where station is located.
     * @type {string}
     * @memberof GBFSStationInformationJsonStationsInner
     */
    'address'?: string;
    /**
     * Cross street or landmark where the station is located.
     * @type {string}
     * @memberof GBFSStationInformationJsonStationsInner
     */
    'cross_street'?: string;
    /**
     * Identifier of the region where the station is located.
     * @type {string}
     * @memberof GBFSStationInformationJsonStationsInner
     */
    'region_id'?: string;
    /**
     * Postal code where station is located.
     * @type {string}
     * @memberof GBFSStationInformationJsonStationsInner
     */
    'post_code'?: string;
    /**
     * Payment methods accepted at this station.
     * @type {Array<string>}
     * @memberof GBFSStationInformationJsonStationsInner
     */
    'rental_methods'?: Array<GBFSStationInformationJsonStationsInnerRentalMethodsEnum>;
    /**
     * Is this station a location with or without physical infrastructure? (added in v2.1-RC)
     * @type {boolean}
     * @memberof GBFSStationInformationJsonStationsInner
     */
    'is_virtual_station'?: boolean;
    /**
     * 
     * @type {GBFSStationInformationJsonStationsInnerStationArea}
     * @memberof GBFSStationInformationJsonStationsInner
     */
    'station_area'?: GBFSStationInformationJsonStationsInnerStationArea;
    /**
     * Number of total docking points installed at this station, both available and unavailable.
     * @type {number}
     * @memberof GBFSStationInformationJsonStationsInner
     */
    'capacity'?: number;
    /**
     * An object where each key is a vehicle_type_id and the value is a number presenting the total number of vehicles of this type that can park within the station_area (added in v2.1-RC).
     * @type {{ [key: string]: number; }}
     * @memberof GBFSStationInformationJsonStationsInner
     */
    'vehicle_capacity'?: { [key: string]: number; };
    /**
     * Are valet services provided at this station? (added in v2.1-RC)
     * @type {boolean}
     * @memberof GBFSStationInformationJsonStationsInner
     */
    'is_valet_station'?: boolean;
    /**
     * 
     * @type {GBFSStationInformationJsonStationsInnerRentalUris}
     * @memberof GBFSStationInformationJsonStationsInner
     */
    'rental_uris'?: GBFSStationInformationJsonStationsInnerRentalUris;
    /**
     * An object where each key is a vehicle_type_id and the value is a number representing the total docking points installed at this station for each vehicle type (added in v2.1-RC).
     * @type {{ [key: string]: number; }}
     * @memberof GBFSStationInformationJsonStationsInner
     */
    'vehicle_type_capacity'?: { [key: string]: number; };
}

export const GBFSStationInformationJsonStationsInnerRentalMethodsEnum = {
    Key: 'key',
    Creditcard: 'creditcard',
    Paypass: 'paypass',
    Applepay: 'applepay',
    Androidpay: 'androidpay',
    Transitcard: 'transitcard',
    Accountnumber: 'accountnumber',
    Phone: 'phone'
} as const;

export type GBFSStationInformationJsonStationsInnerRentalMethodsEnum = typeof GBFSStationInformationJsonStationsInnerRentalMethodsEnum[keyof typeof GBFSStationInformationJsonStationsInnerRentalMethodsEnum];

/**
 * Contains rental uris for Android, iOS, and web in the android, ios, and web fields (added in v1.1).
 * @export
 * @interface GBFSStationInformationJsonStationsInnerRentalUris
 */
export interface GBFSStationInformationJsonStationsInnerRentalUris {
    /**
     * URI that can be passed to an Android app with an intent (added in v1.1).
     * @type {string}
     * @memberof GBFSStationInformationJsonStationsInnerRentalUris
     */
    'android'?: string;
    /**
     * URI that can be used on iOS to launch the rental app for this station (added in v1.1).
     * @type {string}
     * @memberof GBFSStationInformationJsonStationsInnerRentalUris
     */
    'ios'?: string;
    /**
     * URL that can be used by a web browser to show more information about renting a vehicle at this station (added in v1.1).
     * @type {string}
     * @memberof GBFSStationInformationJsonStationsInnerRentalUris
     */
    'web'?: string;
}
/**
 * A multipolygon that describes the area of a virtual station (added in v2.1-RC).
 * @export
 * @interface GBFSStationInformationJsonStationsInnerStationArea
 */
export interface GBFSStationInformationJsonStationsInnerStationArea {
    /**
     * 
     * @type {string}
     * @memberof GBFSStationInformationJsonStationsInnerStationArea
     */
    'type': GBFSStationInformationJsonStationsInnerStationAreaTypeEnum;
    /**
     * 
     * @type {Array<Array<Array<Array<number>>>>}
     * @memberof GBFSStationInformationJsonStationsInnerStationArea
     */
    'coordinates': Array<Array<Array<Array<number>>>>;
}

export const GBFSStationInformationJsonStationsInnerStationAreaTypeEnum = {
    MultiPolygon: 'MultiPolygon'
} as const;

export type GBFSStationInformationJsonStationsInnerStationAreaTypeEnum = typeof GBFSStationInformationJsonStationsInnerStationAreaTypeEnum[keyof typeof GBFSStationInformationJsonStationsInnerStationAreaTypeEnum];

/**
 * Describes the capacity and rental availability of the station
 * @export
 * @interface GBFSStationStatusJson
 */
export interface GBFSStationStatusJson {
    /**
     * 
     * @type {Array<GBFSStationStatusJsonStationsInner>}
     * @memberof GBFSStationStatusJson
     */
    'stations': Array<GBFSStationStatusJsonStationsInner>;
}
/**
 * 
 * @export
 * @interface GBFSStationStatusJsonStationsInner
 */
export interface GBFSStationStatusJsonStationsInner {
    /**
     * Identifier of a station.
     * @type {string}
     * @memberof GBFSStationStatusJsonStationsInner
     */
    'station_id': string;
    /**
     * Number of vehicles of any type physically available for rental at the station.
     * @type {number}
     * @memberof GBFSStationStatusJsonStationsInner
     */
    'num_bikes_available': number;
    /**
     * Array of objects displaying the total number of each vehicle type at the station (added in v2.1-RC).
     * @type {Array<GBFSStationStatusJsonStationsInnerVehicleTypesAvailableInner>}
     * @memberof GBFSStationStatusJsonStationsInner
     */
    'vehicle_types_available'?: Array<GBFSStationStatusJsonStationsInnerVehicleTypesAvailableInner>;
    /**
     * Number of disabled vehicles of any type at the station.
     * @type {number}
     * @memberof GBFSStationStatusJsonStationsInner
     */
    'num_bikes_disabled'?: number;
    /**
     * Number of functional docks physically at the station.
     * @type {number}
     * @memberof GBFSStationStatusJsonStationsInner
     */
    'num_docks_available'?: number;
    /**
     * Number of empty but disabled docks at the station.
     * @type {number}
     * @memberof GBFSStationStatusJsonStationsInner
     */
    'num_docks_disabled'?: number;
    /**
     * Is the station currently on the street?
     * @type {boolean}
     * @memberof GBFSStationStatusJsonStationsInner
     */
    'is_installed': boolean;
    /**
     * Is the station currently renting vehicles?
     * @type {boolean}
     * @memberof GBFSStationStatusJsonStationsInner
     */
    'is_renting': boolean;
    /**
     * Is the station accepting vehicle returns?
     * @type {boolean}
     * @memberof GBFSStationStatusJsonStationsInner
     */
    'is_returning': boolean;
    /**
     * The last time this station reported its status to the operator\'s backend in POSIX time.
     * @type {number}
     * @memberof GBFSStationStatusJsonStationsInner
     */
    'last_reported': number;
    /**
     * Object displaying available docks by vehicle type (added in v2.1-RC).
     * @type {Array<GBFSStationStatusJsonStationsInnerVehicleDocksAvailableInner>}
     * @memberof GBFSStationStatusJsonStationsInner
     */
    'vehicle_docks_available'?: Array<GBFSStationStatusJsonStationsInnerVehicleDocksAvailableInner>;
}
/**
 * 
 * @export
 * @interface GBFSStationStatusJsonStationsInnerVehicleDocksAvailableInner
 */
export interface GBFSStationStatusJsonStationsInnerVehicleDocksAvailableInner {
    /**
     * An array of strings where each string represents a vehicle_type_id that is able to use a particular type of dock at the station (added in v2.1-RC).
     * @type {Array<string>}
     * @memberof GBFSStationStatusJsonStationsInnerVehicleDocksAvailableInner
     */
    'vehicle_type_ids': Array<string>;
    /**
     * A number representing the total number of available docks for the defined vehicle type (added in v2.1-RC).
     * @type {number}
     * @memberof GBFSStationStatusJsonStationsInnerVehicleDocksAvailableInner
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface GBFSStationStatusJsonStationsInnerVehicleTypesAvailableInner
 */
export interface GBFSStationStatusJsonStationsInnerVehicleTypesAvailableInner {
    /**
     * The vehicle_type_id of vehicle at the station (added in v2.1-RC).
     * @type {string}
     * @memberof GBFSStationStatusJsonStationsInnerVehicleTypesAvailableInner
     */
    'vehicle_type_id': string;
    /**
     * A number representing the total amount of this vehicle type at the station (added in v2.1-RC).
     * @type {number}
     * @memberof GBFSStationStatusJsonStationsInnerVehicleTypesAvailableInner
     */
    'count': number;
}
/**
 * Details including system operator, system location, year implemented, URL, contact info, time zone.
 * @export
 * @interface GBFSSystemInformationJson
 */
export interface GBFSSystemInformationJson {
    /**
     * Identifier for this vehicle share system. This should be globally unique (even between different systems).
     * @type {string}
     * @memberof GBFSSystemInformationJson
     */
    'system_id': string;
    /**
     * The language that will be used throughout the rest of the files. It must match the value in the gbfs.json file.
     * @type {string}
     * @memberof GBFSSystemInformationJson
     */
    'language': string;
    /**
     * Logo of the system.
     * @type {string}
     * @memberof GBFSSystemInformationJson
     */
    'logo': string;
    /**
     * Name of the system to be displayed to customers.
     * @type {string}
     * @memberof GBFSSystemInformationJson
     */
    'name': string;
    /**
     * Optional abbreviation for a system.
     * @type {string}
     * @memberof GBFSSystemInformationJson
     */
    'short_name'?: string;
    /**
     * Name of the operator
     * @type {string}
     * @memberof GBFSSystemInformationJson
     */
    'operator'?: string;
    /**
     * The URL of the vehicle share system.
     * @type {string}
     * @memberof GBFSSystemInformationJson
     */
    'url'?: string;
    /**
     * URL where a customer can purchase a membership.
     * @type {string}
     * @memberof GBFSSystemInformationJson
     */
    'purchase_url'?: string;
    /**
     * Date that the system began operations.
     * @type {string}
     * @memberof GBFSSystemInformationJson
     */
    'start_date'?: string;
    /**
     * A single voice telephone number for the specified system that presents the telephone number as typical for the system\'s service area.
     * @type {string}
     * @memberof GBFSSystemInformationJson
     */
    'phone_number'?: string;
    /**
     * Email address actively monitored by the operator\'s customer service department.
     * @type {string}
     * @memberof GBFSSystemInformationJson
     */
    'email'?: string;
    /**
     * A single contact email address for consumers of this feed to report technical issues (added in v1.1).
     * @type {string}
     * @memberof GBFSSystemInformationJson
     */
    'feed_contact_email'?: string;
    /**
     * The time zone where the system is located.
     * @type {string}
     * @memberof GBFSSystemInformationJson
     */
    'timezone': string;
    /**
     * REQUIRED if the dataset is provided under a standard license. An identifier for a standard license from the SPDX License List. Provide license_id rather than license_url if the license is included in the SPDX License List. See the GBFS wiki for a comparison of a subset of standard licenses. If the license_id and license_url fields are blank or omitted, this indicates that the feed is provided under the Creative Commons Universal Public Domain Dedication.
     * @type {string}
     * @memberof GBFSSystemInformationJson
     */
    'license_id'?: string;
    /**
     * A fully qualified URL of a page that defines the license terms for the GBFS data for this system.
     * @type {string}
     * @memberof GBFSSystemInformationJson
     */
    'license_url'?: string;
    /**
     * If the feed license requires attribution, name of the organization to which attribution should be provided.
     * @type {string}
     * @memberof GBFSSystemInformationJson
     */
    'attribution_organization_name'?: string;
    /**
     * URL of the organization to which attribution should be provided.
     * @type {string}
     * @memberof GBFSSystemInformationJson
     */
    'attribution_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof GBFSSystemInformationJson
     */
    'terms_of_use_url'?: string;
    /**
     * 
     * @type {GBFSSystemInformationJsonRentalApps}
     * @memberof GBFSSystemInformationJson
     */
    'rental_apps'?: GBFSSystemInformationJsonRentalApps;
}
/**
 * Contains rental app information in the android and ios JSON objects (added in v1.1).
 * @export
 * @interface GBFSSystemInformationJsonRentalApps
 */
export interface GBFSSystemInformationJsonRentalApps {
    /**
     * 
     * @type {GBFSSystemInformationJsonRentalAppsAndroid}
     * @memberof GBFSSystemInformationJsonRentalApps
     */
    'android'?: GBFSSystemInformationJsonRentalAppsAndroid;
    /**
     * 
     * @type {GBFSSystemInformationJsonRentalAppsIos}
     * @memberof GBFSSystemInformationJsonRentalApps
     */
    'ios'?: GBFSSystemInformationJsonRentalAppsIos;
}
/**
 * Contains rental app download and app discovery information for the Android platform. (added in v1.1)
 * @export
 * @interface GBFSSystemInformationJsonRentalAppsAndroid
 */
export interface GBFSSystemInformationJsonRentalAppsAndroid {
    /**
     * URI where the rental Android app can be downloaded from (added in v1.1).
     * @type {string}
     * @memberof GBFSSystemInformationJsonRentalAppsAndroid
     */
    'store_uri': string;
    /**
     * URI that can be used to discover if the rental Android app is installed on the device (added in v1.1).
     * @type {string}
     * @memberof GBFSSystemInformationJsonRentalAppsAndroid
     */
    'discovery_uri': string;
}
/**
 * Contains rental information for the iOS platform (added in v1.1).
 * @export
 * @interface GBFSSystemInformationJsonRentalAppsIos
 */
export interface GBFSSystemInformationJsonRentalAppsIos {
    /**
     * URI where the rental iOS app can be downloaded from (added in v1.1).
     * @type {string}
     * @memberof GBFSSystemInformationJsonRentalAppsIos
     */
    'store_uri': string;
    /**
     * URI that can be used to discover if the rental iOS app is installed on the device (added in v1.1).
     * @type {string}
     * @memberof GBFSSystemInformationJsonRentalAppsIos
     */
    'discovery_uri': string;
}
/**
 * Describes the pricing schemes of the system.
 * @export
 * @interface GBFSSystemPricingPlansJson
 */
export interface GBFSSystemPricingPlansJson {
    /**
     * 
     * @type {Array<GBFSSystemPricingPlansJsonPlansInner>}
     * @memberof GBFSSystemPricingPlansJson
     */
    'plans': Array<GBFSSystemPricingPlansJsonPlansInner>;
}
/**
 * 
 * @export
 * @interface GBFSSystemPricingPlansJsonPlansInner
 */
export interface GBFSSystemPricingPlansJsonPlansInner {
    /**
     * Identifier of a pricing plan in the system.
     * @type {string}
     * @memberof GBFSSystemPricingPlansJsonPlansInner
     */
    'plan_id': string;
    /**
     * Link to system.
     * @type {string}
     * @memberof GBFSSystemPricingPlansJsonPlansInner
     */
    'system_id'?: string;
    /**
     * URL where the customer can learn more about this pricing plan.
     * @type {string}
     * @memberof GBFSSystemPricingPlansJsonPlansInner
     */
    'url'?: string;
    /**
     * Name of this pricing plan.
     * @type {string}
     * @memberof GBFSSystemPricingPlansJsonPlansInner
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof GBFSSystemPricingPlansJsonPlansInner
     */
    'last_updated'?: number;
    /**
     * Currency used to pay the fare in ISO 4217 code.
     * @type {string}
     * @memberof GBFSSystemPricingPlansJsonPlansInner
     */
    'currency': string;
    /**
     * Fare price.
     * @type {number}
     * @memberof GBFSSystemPricingPlansJsonPlansInner
     */
    'price': number;
    /**
     * Will additional tax be added to the base price?
     * @type {boolean}
     * @memberof GBFSSystemPricingPlansJsonPlansInner
     */
    'is_taxable': boolean;
    /**
     * Customer-readable description of the pricing plan.
     * @type {string}
     * @memberof GBFSSystemPricingPlansJsonPlansInner
     */
    'description': string;
    /**
     * Array of segments when the price is a function of distance travelled, displayed in kilometers (added in v2.1-RC2).
     * @type {Array<GBFSSystemPricingPlansJsonPlansInnerPerKmPricingInner>}
     * @memberof GBFSSystemPricingPlansJsonPlansInner
     */
    'per_km_pricing'?: Array<GBFSSystemPricingPlansJsonPlansInnerPerKmPricingInner>;
    /**
     * Array of segments when the price is a function of time travelled, displayed in minutes (added in v2.1-RC2).
     * @type {Array<GBFSSystemPricingPlansJsonPlansInnerPerMinPricingInner>}
     * @memberof GBFSSystemPricingPlansJsonPlansInner
     */
    'per_min_pricing'?: Array<GBFSSystemPricingPlansJsonPlansInnerPerMinPricingInner>;
    /**
     * Array of segments when the price is a function of time travelled, displayed in minutes (added in v2.1-RC2).
     * @type {Array<GBFSSystemPricingPlansJsonPlansInnerPerMinReservationPricingInner>}
     * @memberof GBFSSystemPricingPlansJsonPlansInner
     */
    'per_min_reservation_pricing'?: Array<GBFSSystemPricingPlansJsonPlansInnerPerMinReservationPricingInner>;
    /**
     * Array of segments when the price is a function of time travelled, displayed in minutes (added in v2.1-RC2).
     * @type {Array<GBFSSystemPricingPlansJsonPlansInnerPerMinReservationPricingInner>}
     * @memberof GBFSSystemPricingPlansJsonPlansInner
     */
    'per_min_parking_pricing'?: Array<GBFSSystemPricingPlansJsonPlansInnerPerMinReservationPricingInner>;
    /**
     * Pokuta za zaparkovani mimo stanici pokud ma provozoval nejake stanice. If this array is not provided, there are no variable prices based on time.
     * @type {Array<GBFSSystemPricingPlansJsonPlansInnerPerMinReservationPricingInner>}
     * @memberof GBFSSystemPricingPlansJsonPlansInner
     */
    'off_station_parking'?: Array<GBFSSystemPricingPlansJsonPlansInnerPerMinReservationPricingInner>;
    /**
     * Is there currently an increase in price in response to increased demand in this pricing plan? (added in v2.1-RC2)
     * @type {boolean}
     * @memberof GBFSSystemPricingPlansJsonPlansInner
     */
    'surge_pricing'?: boolean;
}
/**
 * 
 * @export
 * @interface GBFSSystemPricingPlansJsonPlansInnerPerKmPricingInner
 */
export interface GBFSSystemPricingPlansJsonPlansInnerPerKmPricingInner {
    /**
     * Number of kilometers that have to elapse before this segment starts applying (added in v2.1-RC2).
     * @type {number}
     * @memberof GBFSSystemPricingPlansJsonPlansInnerPerKmPricingInner
     */
    'start': number;
    /**
     * Rate that is charged for each kilometer interval after the start (added in v2.1-RC2).
     * @type {number}
     * @memberof GBFSSystemPricingPlansJsonPlansInnerPerKmPricingInner
     */
    'rate': number;
    /**
     * Interval in kilometers at which the rate of this segment is either reapplied indefinitely, or if defined, up until (but not including) end kilometer (added in v2.1-RC2).
     * @type {number}
     * @memberof GBFSSystemPricingPlansJsonPlansInnerPerKmPricingInner
     */
    'interval': number;
    /**
     * The kilometer at which the rate will no longer apply (added in v2.1-RC2).
     * @type {number}
     * @memberof GBFSSystemPricingPlansJsonPlansInnerPerKmPricingInner
     */
    'end'?: number;
    /**
     * {day}-{day} {time} ƒças zah√°jen√≠ platnosti √∫ƒçtov√°n√≠ pro uveden√© dny v t√Ωdnu, null -> unlimited
     * @type {string}
     * @memberof GBFSSystemPricingPlansJsonPlansInnerPerKmPricingInner
     */
    'start_time_of_period'?: string;
    /**
     * {day}-{day} {time} ƒças ukonƒçen√≠ platnosti √∫ƒçtov√°n√≠ pro uveden√© dny v t√Ωdnu, null -> unlimited
     * @type {string}
     * @memberof GBFSSystemPricingPlansJsonPlansInnerPerKmPricingInner
     */
    'end_time_of_period'?: string;
}
/**
 * 
 * @export
 * @interface GBFSSystemPricingPlansJsonPlansInnerPerMinPricingInner
 */
export interface GBFSSystemPricingPlansJsonPlansInnerPerMinPricingInner {
    /**
     * Number of minutes that have to elapse before this segment starts applying (added in v2.1-RC2).
     * @type {number}
     * @memberof GBFSSystemPricingPlansJsonPlansInnerPerMinPricingInner
     */
    'start': number;
    /**
     * Rate that is charged for each minute interval after the start (added in v2.1-RC2).
     * @type {number}
     * @memberof GBFSSystemPricingPlansJsonPlansInnerPerMinPricingInner
     */
    'rate': number;
    /**
     * Interval in minutes at which the rate of this segment is either reapplied (added in v2.1-RC2).
     * @type {number}
     * @memberof GBFSSystemPricingPlansJsonPlansInnerPerMinPricingInner
     */
    'interval': number;
    /**
     * The minute at which the rate will no longer apply (added in v2.1-RC2).
     * @type {number}
     * @memberof GBFSSystemPricingPlansJsonPlansInnerPerMinPricingInner
     */
    'end'?: number;
    /**
     * {day}-{day} {time} ƒças zah√°jen√≠ platnosti √∫ƒçtov√°n√≠ pro uveden√© dny v t√Ωdnu, null -> unlimited
     * @type {string}
     * @memberof GBFSSystemPricingPlansJsonPlansInnerPerMinPricingInner
     */
    'start_time_of_period'?: string;
    /**
     * {day}-{day} {time} ƒças ukonƒçen√≠ platnosti √∫ƒçtov√°n√≠ pro uveden√© dny v t√Ωdnu, null -> unlimited
     * @type {string}
     * @memberof GBFSSystemPricingPlansJsonPlansInnerPerMinPricingInner
     */
    'end_time_of_period'?: string;
}
/**
 * 
 * @export
 * @interface GBFSSystemPricingPlansJsonPlansInnerPerMinReservationPricingInner
 */
export interface GBFSSystemPricingPlansJsonPlansInnerPerMinReservationPricingInner {
    /**
     * Number of minutes that have to elapse before this segment starts applying (added in v2.1-RC2).
     * @type {number}
     * @memberof GBFSSystemPricingPlansJsonPlansInnerPerMinReservationPricingInner
     */
    'start': number;
    /**
     * Rate that is charged for each minute interval after the start (added in v2.1-RC2).
     * @type {number}
     * @memberof GBFSSystemPricingPlansJsonPlansInnerPerMinReservationPricingInner
     */
    'rate': number;
    /**
     * Interval in minutes at which the rate of this segment is either reapplied (added in v2.1-RC2).
     * @type {number}
     * @memberof GBFSSystemPricingPlansJsonPlansInnerPerMinReservationPricingInner
     */
    'interval': number;
    /**
     * The minute at which the rate will no longer apply (added in v2.1-RC2).
     * @type {number}
     * @memberof GBFSSystemPricingPlansJsonPlansInnerPerMinReservationPricingInner
     */
    'end'?: number;
    /**
     * {day}-{day} {time} ƒças zah√°jen√≠ platnosti √∫ƒçtov√°n√≠ pro uveden√© dny v t√Ωdnu, null -> unlimited
     * @type {string}
     * @memberof GBFSSystemPricingPlansJsonPlansInnerPerMinReservationPricingInner
     */
    'start_time_of_period'?: string;
    /**
     * {day}-{day} {time} ƒças ukonƒçen√≠ platnosti √∫ƒçtov√°n√≠ pro uveden√© dny v t√Ωdnu, null -> unlimited
     * @type {string}
     * @memberof GBFSSystemPricingPlansJsonPlansInnerPerMinReservationPricingInner
     */
    'end_time_of_period'?: string;
}
/**
 * List of all Systems
 * @export
 * @interface GBFSSystemsList
 */
export interface GBFSSystemsList {
    /**
     * 
     * @type {GBFSSystemsListSharedMobilityProviders}
     * @memberof GBFSSystemsList
     */
    'shared_mobility_providers'?: GBFSSystemsListSharedMobilityProviders;
}
/**
 * 
 * @export
 * @interface GBFSSystemsListSharedMobilityProviders
 */
export interface GBFSSystemsListSharedMobilityProviders {
    /**
     * 
     * @type {Array<string>}
     * @memberof GBFSSystemsListSharedMobilityProviders
     */
    'providers_url_list'?: Array<string>;
}
/**
 * Describes the types of vehicles that System operator has available for rent (added in v2.1-RC).
 * @export
 * @interface GBFSVehicleTypesJson
 */
export interface GBFSVehicleTypesJson {
    /**
     * Array that contains one object per vehicle type in the system as defined below.
     * @type {Array<GBFSVehicleTypesJsonVehicleTypesInner>}
     * @memberof GBFSVehicleTypesJson
     */
    'vehicle_types': Array<GBFSVehicleTypesJsonVehicleTypesInner>;
}
/**
 * 
 * @export
 * @interface GBFSVehicleTypesJsonVehicleTypesInner
 */
export interface GBFSVehicleTypesJsonVehicleTypesInner {
    /**
     * Unique identifier of a vehicle type.
     * @type {string}
     * @memberof GBFSVehicleTypesJsonVehicleTypesInner
     */
    'vehicle_type_id': string;
    /**
     * The vehicle\'s general form factor.
     * @type {string}
     * @memberof GBFSVehicleTypesJsonVehicleTypesInner
     */
    'form_factor': GBFSVehicleTypesJsonVehicleTypesInnerFormFactorEnum;
    /**
     * The primary propulsion type of the vehicle.
     * @type {string}
     * @memberof GBFSVehicleTypesJsonVehicleTypesInner
     */
    'propulsion_type': GBFSVehicleTypesJsonVehicleTypesInnerPropulsionTypeEnum;
    /**
     * The furthest distance in meters that the vehicle can travel without recharging or refueling when it has the maximum amount of energy potential.
     * @type {number}
     * @memberof GBFSVehicleTypesJsonVehicleTypesInner
     */
    'max_range_meters'?: number;
    /**
     * The public name of this vehicle type.
     * @type {string}
     * @memberof GBFSVehicleTypesJsonVehicleTypesInner
     */
    'name'?: string;
}

export const GBFSVehicleTypesJsonVehicleTypesInnerFormFactorEnum = {
    Bicycle: 'bicycle',
    Car: 'car',
    Moped: 'moped',
    Other: 'other',
    Scooter: 'scooter'
} as const;

export type GBFSVehicleTypesJsonVehicleTypesInnerFormFactorEnum = typeof GBFSVehicleTypesJsonVehicleTypesInnerFormFactorEnum[keyof typeof GBFSVehicleTypesJsonVehicleTypesInnerFormFactorEnum];
export const GBFSVehicleTypesJsonVehicleTypesInnerPropulsionTypeEnum = {
    Human: 'human',
    ElectricAssist: 'electric_assist',
    Electric: 'electric',
    Combustion: 'combustion'
} as const;

export type GBFSVehicleTypesJsonVehicleTypesInnerPropulsionTypeEnum = typeof GBFSVehicleTypesJsonVehicleTypesInnerPropulsionTypeEnum[keyof typeof GBFSVehicleTypesJsonVehicleTypesInnerPropulsionTypeEnum];

/**
 * Lists all feed endpoints published according to version sof the GBFS documentation. (added in v1.1)
 * @export
 * @interface GBFSVersionsJson
 */
export interface GBFSVersionsJson {
    /**
     * Contains one object, as defined below, for each of the available versions of a feed. The array must be sorted by increasing MAJOR and MINOR version number.
     * @type {Array<GBFSVersionsJsonVersionsInner>}
     * @memberof GBFSVersionsJson
     */
    'versions': Array<GBFSVersionsJsonVersionsInner>;
}
/**
 * 
 * @export
 * @interface GBFSVersionsJsonVersionsInner
 */
export interface GBFSVersionsJsonVersionsInner {
    /**
     * The semantic version of the feed in the form X.Y
     * @type {string}
     * @memberof GBFSVersionsJsonVersionsInner
     */
    'version': GBFSVersionsJsonVersionsInnerVersionEnum;
    /**
     * URL of the corresponding gbfs.json endpoint
     * @type {string}
     * @memberof GBFSVersionsJsonVersionsInner
     */
    'url': string;
}

export const GBFSVersionsJsonVersionsInnerVersionEnum = {
    _11: '1.1',
    _20: '2.0',
    _21: '2.1',
    _22: '2.2',
    _30: '3.0'
} as const;

export type GBFSVersionsJsonVersionsInnerVersionEnum = typeof GBFSVersionsJsonVersionsInnerVersionEnum[keyof typeof GBFSVersionsJsonVersionsInnerVersionEnum];

/**
 * 
 * @export
 * @interface GBFSWrapper
 */
export interface GBFSWrapper {
    /**
     * Last time the data in the feed was updated in POSIX time.
     * @type {number}
     * @memberof GBFSWrapper
     */
    'last_updated': number;
    /**
     * Number of seconds before the data in the feed will be updated again (0 if the data should always be refreshed).
     * @type {number}
     * @memberof GBFSWrapper
     */
    'ttl': number;
    /**
     * GBFS version number to which the feed conforms, according to the versioning framework (added in v1.1).
     * @type {string}
     * @memberof GBFSWrapper
     */
    'version': GBFSWrapperVersionEnum;
    /**
     * Response data in the form of name:value pairs.
     * @type {object}
     * @memberof GBFSWrapper
     */
    'data': object;
}

export const GBFSWrapperVersionEnum = {
    _30: '3.0'
} as const;

export type GBFSWrapperVersionEnum = typeof GBFSWrapperVersionEnum[keyof typeof GBFSWrapperVersionEnum];

/**
 * 
 * @export
 * @interface GETAllGardens200Response
 */
export interface GETAllGardens200Response {
    /**
     * 
     * @type {string}
     * @memberof GETAllGardens200Response
     */
    'type': string;
    /**
     * 
     * @type {Array<Garden>}
     * @memberof GETAllGardens200Response
     */
    'features'?: Array<Garden>;
}
/**
 * 
 * @export
 * @interface GETAllMedicalInstitutions200Response
 */
export interface GETAllMedicalInstitutions200Response {
    /**
     * 
     * @type {string}
     * @memberof GETAllMedicalInstitutions200Response
     */
    'type': string;
    /**
     * 
     * @type {Array<MedicalInstitution>}
     * @memberof GETAllMedicalInstitutions200Response
     */
    'features': Array<MedicalInstitution>;
}
/**
 * 
 * @export
 * @interface GETAllMunicipalAuthorities200Response
 */
export interface GETAllMunicipalAuthorities200Response {
    /**
     * 
     * @type {string}
     * @memberof GETAllMunicipalAuthorities200Response
     */
    'type': string;
    /**
     * 
     * @type {Array<MunicipalAuthority>}
     * @memberof GETAllMunicipalAuthorities200Response
     */
    'features'?: Array<MunicipalAuthority>;
}
/**
 * 
 * @export
 * @interface GETAllMunicipalLibraries200Response
 */
export interface GETAllMunicipalLibraries200Response {
    /**
     * 
     * @type {string}
     * @memberof GETAllMunicipalLibraries200Response
     */
    'type': string;
    /**
     * 
     * @type {Array<MunicipalLibrary>}
     * @memberof GETAllMunicipalLibraries200Response
     */
    'features': Array<MunicipalLibrary>;
}
/**
 * 
 * @export
 * @interface GETAllMunicipalPoliceStations200Response
 */
export interface GETAllMunicipalPoliceStations200Response {
    /**
     * 
     * @type {string}
     * @memberof GETAllMunicipalPoliceStations200Response
     */
    'type': string;
    /**
     * 
     * @type {Array<MunicipalPoliceStation>}
     * @memberof GETAllMunicipalPoliceStations200Response
     */
    'features'?: Array<MunicipalPoliceStation>;
}
/**
 * 
 * @export
 * @interface GETAllPlaygrounds200Response
 */
export interface GETAllPlaygrounds200Response {
    /**
     * 
     * @type {string}
     * @memberof GETAllPlaygrounds200Response
     */
    'type': string;
    /**
     * 
     * @type {Array<Playground>}
     * @memberof GETAllPlaygrounds200Response
     */
    'features'?: Array<Playground>;
}
/**
 * 
 * @export
 * @interface GETAllSharedBikes200Response
 */
export interface GETAllSharedBikes200Response {
    /**
     * 
     * @type {string}
     * @memberof GETAllSharedBikes200Response
     */
    'type': string;
    /**
     * 
     * @type {Array<SharedVehicle>}
     * @memberof GETAllSharedBikes200Response
     */
    'features'?: Array<SharedVehicle>;
}
/**
 * 
 * @export
 * @interface GETAllSharedCars200Response
 */
export interface GETAllSharedCars200Response {
    /**
     * 
     * @type {string}
     * @memberof GETAllSharedCars200Response
     */
    'type': string;
    /**
     * 
     * @type {Array<SharedCar>}
     * @memberof GETAllSharedCars200Response
     */
    'features'?: Array<SharedCar>;
}
/**
 * 
 * @export
 * @interface GETAllWasteCollectionYards200Response
 */
export interface GETAllWasteCollectionYards200Response {
    /**
     * 
     * @type {string}
     * @memberof GETAllWasteCollectionYards200Response
     */
    'type': string;
    /**
     * 
     * @type {Array<WasteCollectionYard>}
     * @memberof GETAllWasteCollectionYards200Response
     */
    'features'?: Array<WasteCollectionYard>;
}
/**
 * 
 * @export
 * @interface Garden
 */
export interface Garden {
    /**
     * 
     * @type {GardenGeometry}
     * @memberof Garden
     */
    'geometry'?: GardenGeometry;
    /**
     * 
     * @type {GardenProperties}
     * @memberof Garden
     */
    'properties'?: GardenProperties;
    /**
     * 
     * @type {string}
     * @memberof Garden
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface GardenGeometry
 */
export interface GardenGeometry {
    /**
     * 
     * @type {string}
     * @memberof GardenGeometry
     */
    'type'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof GardenGeometry
     */
    'coordinates'?: Array<number>;
}
/**
 * 
 * @export
 * @interface GardenProperties
 */
export interface GardenProperties {
    /**
     * 
     * @type {GardenPropertiesAddress}
     * @memberof GardenProperties
     */
    'address'?: GardenPropertiesAddress;
    /**
     * 
     * @type {string}
     * @memberof GardenProperties
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof GardenProperties
     */
    'district'?: string;
    /**
     * 
     * @type {string}
     * @memberof GardenProperties
     */
    'id': string;
    /**
     * 
     * @type {GardenPropertiesImage}
     * @memberof GardenProperties
     */
    'image'?: GardenPropertiesImage;
    /**
     * 
     * @type {string}
     * @memberof GardenProperties
     */
    'name': string;
    /**
     * 
     * @type {Array<GardenPropertiesPropertiesInner>}
     * @memberof GardenProperties
     */
    'properties'?: Array<GardenPropertiesPropertiesInner>;
    /**
     * 
     * @type {string}
     * @memberof GardenProperties
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof GardenProperties
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface GardenPropertiesAddress
 */
export interface GardenPropertiesAddress {
    /**
     * 
     * @type {string}
     * @memberof GardenPropertiesAddress
     */
    'address_formatted'?: string;
}
/**
 * 
 * @export
 * @interface GardenPropertiesImage
 */
export interface GardenPropertiesImage {
    /**
     * 
     * @type {string}
     * @memberof GardenPropertiesImage
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface GardenPropertiesPropertiesInner
 */
export interface GardenPropertiesPropertiesInner {
    /**
     * 
     * @type {string}
     * @memberof GardenPropertiesPropertiesInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GardenPropertiesPropertiesInner
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof GardenPropertiesPropertiesInner
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface GeoJSONFeature
 */
export interface GeoJSONFeature {
    /**
     * 
     * @type {string}
     * @memberof GeoJSONFeature
     */
    'type': GeoJSONFeatureTypeEnum;
    /**
     * 
     * @type {GeoJSONFeatureProperties}
     * @memberof GeoJSONFeature
     */
    'properties': GeoJSONFeatureProperties;
    /**
     * 
     * @type {GeoJSONMultiPolygon}
     * @memberof GeoJSONFeature
     */
    'geometry': GeoJSONMultiPolygon;
}

export const GeoJSONFeatureTypeEnum = {
    Feature: 'Feature'
} as const;

export type GeoJSONFeatureTypeEnum = typeof GeoJSONFeatureTypeEnum[keyof typeof GeoJSONFeatureTypeEnum];

/**
 * Describing travel allowances and limitations.
 * @export
 * @interface GeoJSONFeatureProperties
 */
export interface GeoJSONFeatureProperties {
    /**
     * Public name of the geofencing zone.
     * @type {string}
     * @memberof GeoJSONFeatureProperties
     */
    'name'?: string;
    /**
     * Start time of the geofencing zone in POSIX time.
     * @type {number}
     * @memberof GeoJSONFeatureProperties
     */
    'start'?: number;
    /**
     * End time of the geofencing zone in POSIX time.
     * @type {number}
     * @memberof GeoJSONFeatureProperties
     */
    'end'?: number;
    /**
     * Priorita: 0 je nejni≈æ≈°√≠ priorita. Vy≈°≈°√≠ priorita p≈ôepisuje ni≈æ≈°√≠ prioritu.
     * @type {number}
     * @memberof GeoJSONFeatureProperties
     */
    'priority'?: number;
    /**
     * Array that contains one object per rule.
     * @type {Array<GeoJSONFeaturePropertiesRulesInner>}
     * @memberof GeoJSONFeatureProperties
     */
    'rules'?: Array<GeoJSONFeaturePropertiesRulesInner>;
}
/**
 * 
 * @export
 * @interface GeoJSONFeaturePropertiesRulesInner
 */
export interface GeoJSONFeaturePropertiesRulesInner {
    /**
     * Array of vehicle type IDs for which these restrictions apply.
     * @type {Array<string>}
     * @memberof GeoJSONFeaturePropertiesRulesInner
     */
    'system_id'?: Array<string>;
    /**
     * Is the undocked ride allowed to stat and end in this zone?
     * @type {boolean}
     * @memberof GeoJSONFeaturePropertiesRulesInner
     */
    'ride_allowed': boolean;
    /**
     * Is the ride allowed to travel through this zone?
     * @type {boolean}
     * @memberof GeoJSONFeaturePropertiesRulesInner
     */
    'ride_through_allowed': boolean;
    /**
     * Povoleni parkovani v ramci jedn√© j√≠zdy.
     * @type {boolean}
     * @memberof GeoJSONFeaturePropertiesRulesInner
     */
    'parking_allowed'?: boolean;
    /**
     * What is the maximum speed allowed, in kilometers per hour?
     * @type {number}
     * @memberof GeoJSONFeaturePropertiesRulesInner
     */
    'maximum_speed_kph'?: number;
    /**
     * Cena za vr√°cen√≠ v polygonu, resp. parkov√°n√≠ za minutu v polygonu.
     * @type {number}
     * @memberof GeoJSONFeaturePropertiesRulesInner
     */
    'price'?: number;
}
/**
 * A polygon that describes where rides might not be able to start, end, go through, or have other limitations. Must follow the right-hand rule.
 * @export
 * @interface GeoJSONMultiPolygon
 */
export interface GeoJSONMultiPolygon {
    /**
     * 
     * @type {string}
     * @memberof GeoJSONMultiPolygon
     */
    'type': GeoJSONMultiPolygonTypeEnum;
    /**
     * 
     * @type {Array<Array<Array<Array<number>>>>}
     * @memberof GeoJSONMultiPolygon
     */
    'coordinates': Array<Array<Array<Array<number>>>>;
}

export const GeoJSONMultiPolygonTypeEnum = {
    MultiPolygon: 'MultiPolygon'
} as const;

export type GeoJSONMultiPolygonTypeEnum = typeof GeoJSONMultiPolygonTypeEnum[keyof typeof GeoJSONMultiPolygonTypeEnum];

/**
 * 
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    'location_id': number;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'loc_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'loc_orientation'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'loc_surface'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'address'?: string;
    /**
     * 
     * @type {Array<LocationPointsInner>}
     * @memberof Location
     */
    'points'?: Array<LocationPointsInner>;
}
/**
 * 
 * @export
 * @interface LocationPointsInner
 */
export interface LocationPointsInner {
    /**
     * 
     * @type {number}
     * @memberof LocationPointsInner
     */
    'point_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof LocationPointsInner
     */
    'point_name'?: string;
}
/**
 * 
 * @export
 * @interface Measurement
 */
export interface Measurement {
    /**
     * 
     * @type {number}
     * @memberof Measurement
     */
    'point_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Measurement
     */
    'location_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Measurement
     */
    'measured_at': string;
    /**
     * 
     * @type {string}
     * @memberof Measurement
     */
    'measure'?: string;
    /**
     * 
     * @type {number}
     * @memberof Measurement
     */
    'value'?: number;
    /**
     * 
     * @type {string}
     * @memberof Measurement
     */
    'unit'?: string;
}
/**
 * 
 * @export
 * @interface MedicalInstitution
 */
export interface MedicalInstitution {
    /**
     * 
     * @type {MedicalInstitutionGeometry}
     * @memberof MedicalInstitution
     */
    'geometry': MedicalInstitutionGeometry;
    /**
     * 
     * @type {MedicalInstitutionProperties}
     * @memberof MedicalInstitution
     */
    'properties'?: MedicalInstitutionProperties;
    /**
     * 
     * @type {string}
     * @memberof MedicalInstitution
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface MedicalInstitutionGeometry
 */
export interface MedicalInstitutionGeometry {
    /**
     * 
     * @type {string}
     * @memberof MedicalInstitutionGeometry
     */
    'type'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof MedicalInstitutionGeometry
     */
    'coordinates'?: Array<number>;
}
/**
 * 
 * @export
 * @interface MedicalInstitutionProperties
 */
export interface MedicalInstitutionProperties {
    /**
     * 
     * @type {MedicalInstitutionPropertiesAddress}
     * @memberof MedicalInstitutionProperties
     */
    'address'?: MedicalInstitutionPropertiesAddress;
    /**
     * 
     * @type {string}
     * @memberof MedicalInstitutionProperties
     */
    'district'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MedicalInstitutionProperties
     */
    'email'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof MedicalInstitutionProperties
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MedicalInstitutionProperties
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MedicalInstitutionProperties
     */
    'institution_code': string;
    /**
     * 
     * @type {string}
     * @memberof MedicalInstitutionProperties
     */
    'pharmacy_code'?: string;
    /**
     * 
     * @type {Array<MedicalInstitutionPropertiesOpeningHoursInner>}
     * @memberof MedicalInstitutionProperties
     */
    'opening_hours'?: Array<MedicalInstitutionPropertiesOpeningHoursInner>;
    /**
     * 
     * @type {Array<string>}
     * @memberof MedicalInstitutionProperties
     */
    'telephone'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof MedicalInstitutionProperties
     */
    'updated_at'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MedicalInstitutionProperties
     */
    'web'?: Array<string>;
    /**
     * 
     * @type {MedicalInstitutionPropertiesType}
     * @memberof MedicalInstitutionProperties
     */
    'type'?: MedicalInstitutionPropertiesType;
}
/**
 * 
 * @export
 * @interface MedicalInstitutionPropertiesAddress
 */
export interface MedicalInstitutionPropertiesAddress {
    /**
     * 
     * @type {string}
     * @memberof MedicalInstitutionPropertiesAddress
     */
    'address_formatted'?: string;
    /**
     * 
     * @type {string}
     * @memberof MedicalInstitutionPropertiesAddress
     */
    'street_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof MedicalInstitutionPropertiesAddress
     */
    'postal_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof MedicalInstitutionPropertiesAddress
     */
    'address_locality'?: string;
    /**
     * 
     * @type {string}
     * @memberof MedicalInstitutionPropertiesAddress
     */
    'address_region'?: string;
    /**
     * 
     * @type {string}
     * @memberof MedicalInstitutionPropertiesAddress
     */
    'address_country'?: string;
}
/**
 * 
 * @export
 * @interface MedicalInstitutionPropertiesOpeningHoursInner
 */
export interface MedicalInstitutionPropertiesOpeningHoursInner {
    /**
     * 
     * @type {string}
     * @memberof MedicalInstitutionPropertiesOpeningHoursInner
     */
    'closes'?: string;
    /**
     * 
     * @type {string}
     * @memberof MedicalInstitutionPropertiesOpeningHoursInner
     */
    'day_of_week'?: string;
    /**
     * 
     * @type {string}
     * @memberof MedicalInstitutionPropertiesOpeningHoursInner
     */
    'opens'?: string;
}
/**
 * 
 * @export
 * @interface MedicalInstitutionPropertiesType
 */
export interface MedicalInstitutionPropertiesType {
    /**
     * 
     * @type {string}
     * @memberof MedicalInstitutionPropertiesType
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof MedicalInstitutionPropertiesType
     */
    'group'?: MedicalInstitutionPropertiesTypeGroupEnum;
    /**
     * 
     * @type {string}
     * @memberof MedicalInstitutionPropertiesType
     */
    'id': string;
}

export const MedicalInstitutionPropertiesTypeGroupEnum = {
    Pharmacies: 'pharmacies',
    HealthCare: 'health_care'
} as const;

export type MedicalInstitutionPropertiesTypeGroupEnum = typeof MedicalInstitutionPropertiesTypeGroupEnum[keyof typeof MedicalInstitutionPropertiesTypeGroupEnum];

/**
 * 
 * @export
 * @interface MedicalInstitutionType
 */
export interface MedicalInstitutionType {
    /**
     * 
     * @type {Array<string>}
     * @memberof MedicalInstitutionType
     */
    'pharmacies'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof MedicalInstitutionType
     */
    'health_care'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'error_message': string;
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    'error_status': number;
}
/**
 * 
 * @export
 * @interface MunicipalAuthority
 */
export interface MunicipalAuthority {
    /**
     * 
     * @type {GardenGeometry}
     * @memberof MunicipalAuthority
     */
    'geometry'?: GardenGeometry;
    /**
     * 
     * @type {MunicipalAuthorityProperties}
     * @memberof MunicipalAuthority
     */
    'properties'?: MunicipalAuthorityProperties;
    /**
     * 
     * @type {string}
     * @memberof MunicipalAuthority
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface MunicipalAuthorityProperties
 */
export interface MunicipalAuthorityProperties {
    /**
     * 
     * @type {MunicipalAuthorityPropertiesImage}
     * @memberof MunicipalAuthorityProperties
     */
    'image'?: MunicipalAuthorityPropertiesImage;
    /**
     * 
     * @type {Array<string>}
     * @memberof MunicipalAuthorityProperties
     */
    'email'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof MunicipalAuthorityProperties
     */
    'telephone'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof MunicipalAuthorityProperties
     */
    'web'?: Array<string>;
    /**
     * 
     * @type {GardenPropertiesAddress}
     * @memberof MunicipalAuthorityProperties
     */
    'address'?: GardenPropertiesAddress;
    /**
     * 
     * @type {Array<MunicipalAuthorityPropertiesAgendasInner>}
     * @memberof MunicipalAuthorityProperties
     */
    'agendas'?: Array<MunicipalAuthorityPropertiesAgendasInner>;
    /**
     * 
     * @type {string}
     * @memberof MunicipalAuthorityProperties
     */
    'district'?: string;
    /**
     * 
     * @type {string}
     * @memberof MunicipalAuthorityProperties
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MunicipalAuthorityProperties
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MunicipalAuthorityProperties
     */
    'official_board'?: string;
    /**
     * 
     * @type {Array<MunicipalAuthorityPropertiesOpeningHoursInner>}
     * @memberof MunicipalAuthorityProperties
     */
    'opening_hours'?: Array<MunicipalAuthorityPropertiesOpeningHoursInner>;
    /**
     * 
     * @type {string}
     * @memberof MunicipalAuthorityProperties
     */
    'updated_at'?: string;
    /**
     * 
     * @type {MunicipalAuthorityPropertiesType}
     * @memberof MunicipalAuthorityProperties
     */
    'type'?: MunicipalAuthorityPropertiesType;
}
/**
 * 
 * @export
 * @interface MunicipalAuthorityPropertiesAgendasInner
 */
export interface MunicipalAuthorityPropertiesAgendasInner {
    /**
     * 
     * @type {Array<string>}
     * @memberof MunicipalAuthorityPropertiesAgendasInner
     */
    'keywords'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof MunicipalAuthorityPropertiesAgendasInner
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof MunicipalAuthorityPropertiesAgendasInner
     */
    'long_description'?: string;
}
/**
 * 
 * @export
 * @interface MunicipalAuthorityPropertiesImage
 */
export interface MunicipalAuthorityPropertiesImage {
    /**
     * 
     * @type {string}
     * @memberof MunicipalAuthorityPropertiesImage
     */
    'mimetype'?: string;
    /**
     * 
     * @type {number}
     * @memberof MunicipalAuthorityPropertiesImage
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof MunicipalAuthorityPropertiesImage
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface MunicipalAuthorityPropertiesOpeningHoursInner
 */
export interface MunicipalAuthorityPropertiesOpeningHoursInner {
    /**
     * 
     * @type {string}
     * @memberof MunicipalAuthorityPropertiesOpeningHoursInner
     */
    'closes'?: string;
    /**
     * 
     * @type {string}
     * @memberof MunicipalAuthorityPropertiesOpeningHoursInner
     */
    'opens'?: string;
    /**
     * 
     * @type {string}
     * @memberof MunicipalAuthorityPropertiesOpeningHoursInner
     */
    'day_of_week'?: string;
    /**
     * 
     * @type {string}
     * @memberof MunicipalAuthorityPropertiesOpeningHoursInner
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface MunicipalAuthorityPropertiesType
 */
export interface MunicipalAuthorityPropertiesType {
    /**
     * 
     * @type {string}
     * @memberof MunicipalAuthorityPropertiesType
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof MunicipalAuthorityPropertiesType
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface MunicipalAuthorityQueues
 */
export interface MunicipalAuthorityQueues {
    /**
     * 
     * @type {string}
     * @memberof MunicipalAuthorityQueues
     */
    'last_updated': string;
    /**
     * 
     * @type {string}
     * @memberof MunicipalAuthorityQueues
     */
    'municipal_authority_id': string;
    /**
     * 
     * @type {Array<MunicipalAuthorityQueuesServedActivitiesInner>}
     * @memberof MunicipalAuthorityQueues
     */
    'served_activities': Array<MunicipalAuthorityQueuesServedActivitiesInner>;
    /**
     * 
     * @type {string}
     * @memberof MunicipalAuthorityQueues
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof MunicipalAuthorityQueues
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface MunicipalAuthorityQueuesServedActivitiesInner
 */
export interface MunicipalAuthorityQueuesServedActivitiesInner {
    /**
     * 
     * @type {string}
     * @memberof MunicipalAuthorityQueuesServedActivitiesInner
     */
    'activity': string;
    /**
     * 
     * @type {number}
     * @memberof MunicipalAuthorityQueuesServedActivitiesInner
     */
    'number_of_person_in_queue': number;
    /**
     * 
     * @type {number}
     * @memberof MunicipalAuthorityQueuesServedActivitiesInner
     */
    'number_of_serving_counters': number;
}
/**
 * 
 * @export
 * @interface MunicipalLibrary
 */
export interface MunicipalLibrary {
    /**
     * 
     * @type {MedicalInstitutionGeometry}
     * @memberof MunicipalLibrary
     */
    'geometry'?: MedicalInstitutionGeometry;
    /**
     * 
     * @type {MunicipalLibraryProperties}
     * @memberof MunicipalLibrary
     */
    'properties'?: MunicipalLibraryProperties;
    /**
     * 
     * @type {string}
     * @memberof MunicipalLibrary
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface MunicipalLibraryProperties
 */
export interface MunicipalLibraryProperties {
    /**
     * 
     * @type {MunicipalLibraryPropertiesAddress}
     * @memberof MunicipalLibraryProperties
     */
    'address'?: MunicipalLibraryPropertiesAddress;
    /**
     * 
     * @type {string}
     * @memberof MunicipalLibraryProperties
     */
    'email'?: string;
    /**
     * 
     * @type {number}
     * @memberof MunicipalLibraryProperties
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof MunicipalLibraryProperties
     */
    'name'?: string;
    /**
     * 
     * @type {Array<MunicipalLibraryPropertiesOpeningHoursInner>}
     * @memberof MunicipalLibraryProperties
     */
    'opening_hours'?: Array<MunicipalLibraryPropertiesOpeningHoursInner>;
    /**
     * 
     * @type {Array<MunicipalLibraryPropertiesServicesInner>}
     * @memberof MunicipalLibraryProperties
     */
    'services'?: Array<MunicipalLibraryPropertiesServicesInner>;
    /**
     * 
     * @type {string}
     * @memberof MunicipalLibraryProperties
     */
    'telephone'?: string;
    /**
     * 
     * @type {string}
     * @memberof MunicipalLibraryProperties
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof MunicipalLibraryProperties
     */
    'web'?: string;
    /**
     * 
     * @type {string}
     * @memberof MunicipalLibraryProperties
     */
    'district'?: string;
}
/**
 * 
 * @export
 * @interface MunicipalLibraryPropertiesAddress
 */
export interface MunicipalLibraryPropertiesAddress {
    /**
     * 
     * @type {string}
     * @memberof MunicipalLibraryPropertiesAddress
     */
    'address_formatted'?: string;
    /**
     * 
     * @type {string}
     * @memberof MunicipalLibraryPropertiesAddress
     */
    'street_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof MunicipalLibraryPropertiesAddress
     */
    'postal_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof MunicipalLibraryPropertiesAddress
     */
    'address_locality'?: string;
    /**
     * 
     * @type {string}
     * @memberof MunicipalLibraryPropertiesAddress
     */
    'address_region'?: string;
    /**
     * 
     * @type {string}
     * @memberof MunicipalLibraryPropertiesAddress
     */
    'address_country'?: string;
}
/**
 * 
 * @export
 * @interface MunicipalLibraryPropertiesOpeningHoursInner
 */
export interface MunicipalLibraryPropertiesOpeningHoursInner {
    /**
     * 
     * @type {string}
     * @memberof MunicipalLibraryPropertiesOpeningHoursInner
     */
    'closes'?: string;
    /**
     * 
     * @type {string}
     * @memberof MunicipalLibraryPropertiesOpeningHoursInner
     */
    'day_of_week'?: string;
    /**
     * 
     * @type {string}
     * @memberof MunicipalLibraryPropertiesOpeningHoursInner
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MunicipalLibraryPropertiesOpeningHoursInner
     */
    'is_default'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MunicipalLibraryPropertiesOpeningHoursInner
     */
    'opens'?: string;
    /**
     * 
     * @type {string}
     * @memberof MunicipalLibraryPropertiesOpeningHoursInner
     */
    'valid_from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MunicipalLibraryPropertiesOpeningHoursInner
     */
    'valid_through'?: string | null;
}
/**
 * 
 * @export
 * @interface MunicipalLibraryPropertiesServicesInner
 */
export interface MunicipalLibraryPropertiesServicesInner {
    /**
     * 
     * @type {string}
     * @memberof MunicipalLibraryPropertiesServicesInner
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MunicipalLibraryPropertiesServicesInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof MunicipalLibraryPropertiesServicesInner
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface MunicipalPoliceStation
 */
export interface MunicipalPoliceStation {
    /**
     * 
     * @type {GardenGeometry}
     * @memberof MunicipalPoliceStation
     */
    'geometry'?: GardenGeometry;
    /**
     * 
     * @type {MunicipalPoliceStationProperties}
     * @memberof MunicipalPoliceStation
     */
    'properties'?: MunicipalPoliceStationProperties;
    /**
     * 
     * @type {string}
     * @memberof MunicipalPoliceStation
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface MunicipalPoliceStationProperties
 */
export interface MunicipalPoliceStationProperties {
    /**
     * 
     * @type {string}
     * @memberof MunicipalPoliceStationProperties
     */
    'cadastral_area': string;
    /**
     * 
     * @type {string}
     * @memberof MunicipalPoliceStationProperties
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MunicipalPoliceStationProperties
     */
    'note': string;
    /**
     * 
     * @type {string}
     * @memberof MunicipalPoliceStationProperties
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof MunicipalPoliceStationProperties
     */
    'district'?: string;
    /**
     * 
     * @type {MedicalInstitutionPropertiesAddress}
     * @memberof MunicipalPoliceStationProperties
     */
    'address': MedicalInstitutionPropertiesAddress;
}
/**
 * 
 * @export
 * @interface OpeningHours
 */
export interface OpeningHours {
    /**
     * 
     * @type {string}
     * @memberof OpeningHours
     */
    'valid_from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OpeningHours
     */
    'valid_to'?: string | null;
    /**
     * Array of Periods of Time objects.
     * @type {Array<ParkingPeriodsOfTimeWithDuration>}
     * @memberof OpeningHours
     */
    'periods_of_time'?: Array<ParkingPeriodsOfTimeWithDuration>;
}
/**
 * 
 * @export
 * @interface Parking
 */
export interface Parking {
    /**
     * 
     * @type {ParkingGeometry}
     * @memberof Parking
     */
    'geometry'?: ParkingGeometry;
    /**
     * 
     * @type {ParkingProperties}
     * @memberof Parking
     */
    'properties'?: ParkingProperties;
    /**
     * 
     * @type {string}
     * @memberof Parking
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface ParkingAddress
 */
export interface ParkingAddress {
    /**
     * Formatted address of the parking location.
     * @type {string}
     * @memberof ParkingAddress
     */
    'address_formatted'?: string | null;
    /**
     * Country of the parking location.
     * @type {string}
     * @memberof ParkingAddress
     */
    'country'?: string | null;
    /**
     * Locality of the parking location.
     * @type {string}
     * @memberof ParkingAddress
     */
    'locality'?: string | null;
    /**
     * Region of the parking location.
     * @type {string}
     * @memberof ParkingAddress
     */
    'region'?: string | null;
    /**
     * Postal code of the parking location.
     * @type {string}
     * @memberof ParkingAddress
     */
    'postal_code'?: string | null;
    /**
     * Street address of the parking location.
     * @type {string}
     * @memberof ParkingAddress
     */
    'street_address'?: string | null;
    /**
     * Area of the parking lot in square meters.
     * @type {number}
     * @memberof ParkingAddress
     */
    'area'?: number;
    /**
     * 
     * @type {string}
     * @memberof ParkingAddress
     */
    'house_number'?: string | null;
}
/**
 * 
 * @export
 * @interface ParkingCharge
 */
export interface ParkingCharge {
    /**
     * The UUID identifier for the charge.
     * @type {string}
     * @memberof ParkingCharge
     */
    'id': string;
    /**
     * Charge amount.
     * @type {string}
     * @memberof ParkingCharge
     */
    'charge': string;
    /**
     * Type of charge.
     * @type {string}
     * @memberof ParkingCharge
     */
    'charge_type': ParkingChargeChargeTypeEnum;
    /**
     * Order index for charges.
     * @type {number}
     * @memberof ParkingCharge
     */
    'charge_order_index': number;
    /**
     * Charge interval (in seconds).
     * @type {number}
     * @memberof ParkingCharge
     */
    'charge_interval': number;
    /**
     * Maximum iterations of charge.
     * @type {number}
     * @memberof ParkingCharge
     */
    'max_iterations_of_charge'?: number;
    /**
     * Minimum iterations of charge.
     * @type {number}
     * @memberof ParkingCharge
     */
    'min_iterations_of_charge'?: number;
    /**
     * Valid from date.
     * @type {string}
     * @memberof ParkingCharge
     */
    'valid_from': string;
    /**
     * Valid to date.
     * @type {string}
     * @memberof ParkingCharge
     */
    'valid_to'?: string | null;
    /**
     * Array of Periods of Time objects.
     * @type {Array<ParkingPeriodsOfTime>}
     * @memberof ParkingCharge
     */
    'periods_of_time'?: Array<ParkingPeriodsOfTime>;
}

export const ParkingChargeChargeTypeEnum = {
    Other: 'other',
    Minimum: 'minimum',
    Maximum: 'maximum'
} as const;

export type ParkingChargeChargeTypeEnum = typeof ParkingChargeChargeTypeEnum[keyof typeof ParkingChargeChargeTypeEnum];

/**
 * 
 * @export
 * @interface ParkingChargeBand
 */
export interface ParkingChargeBand {
    /**
     * The primary source of the charge band.
     * @type {string}
     * @memberof ParkingChargeBand
     */
    'primary_source': ParkingChargeBandPrimarySourceEnum;
    /**
     * The ID defines by the primary source.
     * @type {string}
     * @memberof ParkingChargeBand
     */
    'primary_source_id'?: string | null;
    /**
     * Maximum duration for charging (in seconds).
     * @type {number}
     * @memberof ParkingChargeBand
     */
    'maximum_duration'?: number | null;
    /**
     * Valid from date.
     * @type {string}
     * @memberof ParkingChargeBand
     */
    'valid_from': string;
    /**
     * Valid to date.
     * @type {string}
     * @memberof ParkingChargeBand
     */
    'valid_to'?: string | null;
    /**
     * The date and time when info about the tariff category was last checked and updated.
     * @type {string}
     * @memberof ParkingChargeBand
     */
    'last_updated_at'?: string;
    /**
     * The date and time when the tariff category was last modified at the source.
     * @type {string}
     * @memberof ParkingChargeBand
     */
    'last_modified_at_source'?: string | null;
    /**
     * Array of Charge objects. Items are sorted by charge_order_index.
     * @type {Array<ParkingCharge>}
     * @memberof ParkingChargeBand
     */
    'charges'?: Array<ParkingCharge>;
    /**
     * Free charging, no need to calculate the price from Charges.
     * @type {boolean}
     * @memberof ParkingChargeBand
     */
    'free_of_charge'?: boolean;
    /**
     * Payment methods for charging. * `card_online` - payment through an online card transaction (e.g., on website) * `card_offline` - payment using a card (using a parking machine, terminal etc.) * `litacka` - payment via a PID L√≠taƒçka mobile app * `cash` - payment with physical cash * `coins_only` - payment using coins only * `mobile_app` - payment through a dedicated mobile app (no PID L√≠taƒçka) * `sms_payment` - payment made via SMS * `apple_pay` - payment using Apple Pay * `google_pay` - payment using Google Pay 
     * @type {Array<string>}
     * @memberof ParkingChargeBand
     */
    'payment_methods'?: Array<ParkingChargeBandPaymentMethodsEnum> | null;
    /**
     * Whether payment occurs prior to parking or after.
     * @type {string}
     * @memberof ParkingChargeBand
     */
    'payment_mode'?: ParkingChargeBandPaymentModeEnum | null;
    /**
     * URL for the charge band.
     * @type {string}
     * @memberof ParkingChargeBand
     */
    'url'?: string | null;
}

export const ParkingChargeBandPrimarySourceEnum = {
    TskV2: 'tsk_v2'
} as const;

export type ParkingChargeBandPrimarySourceEnum = typeof ParkingChargeBandPrimarySourceEnum[keyof typeof ParkingChargeBandPrimarySourceEnum];
export const ParkingChargeBandPaymentMethodsEnum = {
    CardOnline: 'card_online',
    CardOffline: 'card_offline',
    Litacka: 'litacka',
    Cash: 'cash',
    CoinsOnly: 'coins_only',
    MobileApp: 'mobile_app',
    SmsPayment: 'sms_payment',
    ApplePay: 'apple_pay',
    GooglePay: 'google_pay'
} as const;

export type ParkingChargeBandPaymentMethodsEnum = typeof ParkingChargeBandPaymentMethodsEnum[keyof typeof ParkingChargeBandPaymentMethodsEnum];
export const ParkingChargeBandPaymentModeEnum = {
    PrePaid: 'pre_paid',
    PostPaid: 'post_paid'
} as const;

export type ParkingChargeBandPaymentModeEnum = typeof ParkingChargeBandPaymentModeEnum[keyof typeof ParkingChargeBandPaymentModeEnum];

/**
 * 
 * @export
 * @interface ParkingDimension
 */
export interface ParkingDimension {
    /**
     * The maximum height (in meters).
     * @type {number}
     * @memberof ParkingDimension
     */
    'max_height'?: number | null;
    /**
     * The maximum width (in meters).
     * @type {number}
     * @memberof ParkingDimension
     */
    'max_width'?: number | null;
    /**
     * The maximum length (in meters).
     * @type {number}
     * @memberof ParkingDimension
     */
    'max_length'?: number | null;
    /**
     * The maximum weight (in kilograms).
     * @type {number}
     * @memberof ParkingDimension
     */
    'max_weight'?: number | null;
}
/**
 * 
 * @export
 * @interface ParkingEntrance
 */
export interface ParkingEntrance {
    /**
     * 
     * @type {ParkingSpaceGeometry}
     * @memberof ParkingEntrance
     */
    'geometry'?: ParkingSpaceGeometry;
    /**
     * 
     * @type {ParkingEntranceProperties}
     * @memberof ParkingEntrance
     */
    'properties'?: ParkingEntranceProperties;
    /**
     * 
     * @type {string}
     * @memberof ParkingEntrance
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface ParkingEntranceProperties
 */
export interface ParkingEntranceProperties {
    /**
     * 
     * @type {boolean}
     * @memberof ParkingEntranceProperties
     */
    'entry'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof ParkingEntranceProperties
     */
    'exit'?: boolean | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ParkingEntranceProperties
     */
    'entrance_type'?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof ParkingEntranceProperties
     */
    'level'?: number | null;
    /**
     * 
     * @type {ParkingEntrancePropertiesDimension}
     * @memberof ParkingEntranceProperties
     */
    'dimension'?: ParkingEntrancePropertiesDimension;
}
/**
 * 
 * @export
 * @interface ParkingEntrancePropertiesDimension
 */
export interface ParkingEntrancePropertiesDimension {
    /**
     * 
     * @type {number}
     * @memberof ParkingEntrancePropertiesDimension
     */
    'max_height'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ParkingEntrancePropertiesDimension
     */
    'max_width'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ParkingEntrancePropertiesDimension
     */
    'max_length'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ParkingEntrancePropertiesDimension
     */
    'max_weight'?: number | null;
}
/**
 * GeoJSON geometry of the parking location.
 * @export
 * @interface ParkingGeometry
 */
export interface ParkingGeometry {
    /**
     * The type of geometry (GeoJSON Point, Polygon, MultiPolygon).
     * @type {string}
     * @memberof ParkingGeometry
     */
    'type'?: ParkingGeometryTypeEnum;
    /**
     * 
     * @type {ParkingGeometryCoordinates}
     * @memberof ParkingGeometry
     */
    'coordinates'?: ParkingGeometryCoordinates;
}

export const ParkingGeometryTypeEnum = {
    Point: 'Point',
    Polygon: 'Polygon',
    MultiPolygon: 'MultiPolygon'
} as const;

export type ParkingGeometryTypeEnum = typeof ParkingGeometryTypeEnum[keyof typeof ParkingGeometryTypeEnum];

/**
 * @type ParkingGeometryCoordinates
 * Coordinates of the geometry.
 * @export
 */
export type ParkingGeometryCoordinates = Array<Array<Array<Array<number>>>> | Array<Array<Array<number>>> | Array<number>;
/**
 * 
 * @export
 * @interface ParkingLotFeature
 */
export interface ParkingLotFeature {
    /**
     * 
     * @type {ParkingLotFeatureGeometry}
     * @memberof ParkingLotFeature
     */
    'geometry'?: ParkingLotFeatureGeometry;
    /**
     * 
     * @type {ParkingLotFeatureProperties}
     * @memberof ParkingLotFeature
     */
    'properties'?: ParkingLotFeatureProperties;
    /**
     * 
     * @type {string}
     * @memberof ParkingLotFeature
     */
    'type'?: string;
}
/**
 * GeoJson geometry
 * @export
 * @interface ParkingLotFeatureGeometry
 */
export interface ParkingLotFeatureGeometry {
    /**
     * 
     * @type {ParkingLotFeatureGeometryCoordinates}
     * @memberof ParkingLotFeatureGeometry
     */
    'coordinates'?: ParkingLotFeatureGeometryCoordinates;
    /**
     * 
     * @type {string}
     * @memberof ParkingLotFeatureGeometry
     */
    'type'?: ParkingLotFeatureGeometryTypeEnum;
}

export const ParkingLotFeatureGeometryTypeEnum = {
    Point: 'Point',
    Polygon: 'Polygon',
    MultiPolygon: 'MultiPolygon'
} as const;

export type ParkingLotFeatureGeometryTypeEnum = typeof ParkingLotFeatureGeometryTypeEnum[keyof typeof ParkingLotFeatureGeometryTypeEnum];

/**
 * @type ParkingLotFeatureGeometryCoordinates
 * @export
 */
export type ParkingLotFeatureGeometryCoordinates = Array<Array<Array<Array<number>>>> | Array<Array<Array<number>>> | Array<number>;
/**
 * 
 * @export
 * @interface ParkingLotFeatureProperties
 */
export interface ParkingLotFeatureProperties {
    /**
     * 
     * @type {ParkingLotFeaturePropertiesId}
     * @memberof ParkingLotFeatureProperties
     */
    'id': ParkingLotFeaturePropertiesId;
    /**
     * 
     * @type {string}
     * @memberof ParkingLotFeatureProperties
     */
    'name': string;
    /**
     * 
     * @type {ParkingLotFeaturePropertiesParkingType}
     * @memberof ParkingLotFeatureProperties
     */
    'parking_type'?: ParkingLotFeaturePropertiesParkingType;
    /**
     * 
     * @type {number}
     * @memberof ParkingLotFeatureProperties
     */
    'num_of_free_places': number;
    /**
     * 
     * @type {number}
     * @memberof ParkingLotFeatureProperties
     */
    'num_of_taken_places': number;
    /**
     * 
     * @type {string}
     * @memberof ParkingLotFeatureProperties
     */
    'updated_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof ParkingLotFeatureProperties
     */
    'total_num_of_places': number;
    /**
     * 
     * @type {ParkingLotFeaturePropertiesAverageOccupancy}
     * @memberof ParkingLotFeatureProperties
     */
    'average_occupancy'?: ParkingLotFeaturePropertiesAverageOccupancy;
    /**
     * 
     * @type {number}
     * @memberof ParkingLotFeatureProperties
     */
    'area'?: number;
    /**
     * 
     * @type {string}
     * @memberof ParkingLotFeatureProperties
     */
    'district'?: string | null;
    /**
     * 
     * @type {ParkingLotFeaturePropertiesAddress}
     * @memberof ParkingLotFeatureProperties
     */
    'address'?: ParkingLotFeaturePropertiesAddress | null;
    /**
     * 
     * @type {number}
     * @memberof ParkingLotFeatureProperties
     */
    'last_updated'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ParkingLotFeatureProperties
     */
    'payment_link'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParkingLotFeatureProperties
     */
    'payment_shortname'?: string | null;
}
/**
 * 
 * @export
 * @interface ParkingLotFeaturePropertiesAddress
 */
export interface ParkingLotFeaturePropertiesAddress {
    /**
     * 
     * @type {string}
     * @memberof ParkingLotFeaturePropertiesAddress
     */
    'address_country'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParkingLotFeaturePropertiesAddress
     */
    'address_formatted'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParkingLotFeaturePropertiesAddress
     */
    'address_locality'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParkingLotFeaturePropertiesAddress
     */
    'address_region'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParkingLotFeaturePropertiesAddress
     */
    'postal_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParkingLotFeaturePropertiesAddress
     */
    'street_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParkingLotFeaturePropertiesAddress
     */
    'house_number'?: string;
}
/**
 * 
 * @export
 * @interface ParkingLotFeaturePropertiesAverageOccupancy
 */
export interface ParkingLotFeaturePropertiesAverageOccupancy {
    /**
     * 
     * @type {AverageOccupancyDay}
     * @memberof ParkingLotFeaturePropertiesAverageOccupancy
     */
    '0'?: AverageOccupancyDay;
    /**
     * 
     * @type {AverageOccupancyDay}
     * @memberof ParkingLotFeaturePropertiesAverageOccupancy
     */
    '1'?: AverageOccupancyDay;
    /**
     * 
     * @type {AverageOccupancyDay}
     * @memberof ParkingLotFeaturePropertiesAverageOccupancy
     */
    '2'?: AverageOccupancyDay;
    /**
     * 
     * @type {AverageOccupancyDay}
     * @memberof ParkingLotFeaturePropertiesAverageOccupancy
     */
    '3'?: AverageOccupancyDay;
    /**
     * 
     * @type {AverageOccupancyDay}
     * @memberof ParkingLotFeaturePropertiesAverageOccupancy
     */
    '4'?: AverageOccupancyDay;
    /**
     * 
     * @type {AverageOccupancyDay}
     * @memberof ParkingLotFeaturePropertiesAverageOccupancy
     */
    '5'?: AverageOccupancyDay;
    /**
     * 
     * @type {AverageOccupancyDay}
     * @memberof ParkingLotFeaturePropertiesAverageOccupancy
     */
    '6'?: AverageOccupancyDay;
}
/**
 * @type ParkingLotFeaturePropertiesId
 * @export
 */
export type ParkingLotFeaturePropertiesId = number | string;
/**
 * 
 * @export
 * @interface ParkingLotFeaturePropertiesParkingType
 */
export interface ParkingLotFeaturePropertiesParkingType {
    /**
     * 
     * @type {number}
     * @memberof ParkingLotFeaturePropertiesParkingType
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ParkingLotFeaturePropertiesParkingType
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface ParkingLotHistory
 */
export interface ParkingLotHistory {
    /**
     * 
     * @type {string}
     * @memberof ParkingLotHistory
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof ParkingLotHistory
     */
    'num_of_free_places': number;
    /**
     * 
     * @type {number}
     * @memberof ParkingLotHistory
     */
    'num_of_taken_places': number;
    /**
     * 
     * @type {string}
     * @memberof ParkingLotHistory
     */
    'updated_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof ParkingLotHistory
     */
    'total_num_of_places': number;
    /**
     * 
     * @type {number}
     * @memberof ParkingLotHistory
     */
    'last_updated'?: number | null;
}
/**
 * 
 * @export
 * @interface ParkingMachine
 */
export interface ParkingMachine {
    /**
     * 
     * @type {ParkingMachineGeometry}
     * @memberof ParkingMachine
     */
    'geometry'?: ParkingMachineGeometry;
    /**
     * 
     * @type {ParkingMachineProperties}
     * @memberof ParkingMachine
     */
    'properties'?: ParkingMachineProperties;
    /**
     * 
     * @type {string}
     * @memberof ParkingMachine
     */
    'type'?: string;
}
/**
 * GeoJSON geometry of the parking machine.
 * @export
 * @interface ParkingMachineGeometry
 */
export interface ParkingMachineGeometry {
    /**
     * The type of geometry (GeoJSON Point, Polygon, MultiPolygon).
     * @type {string}
     * @memberof ParkingMachineGeometry
     */
    'type'?: ParkingMachineGeometryTypeEnum;
    /**
     * 
     * @type {ParkingGeometryCoordinates}
     * @memberof ParkingMachineGeometry
     */
    'coordinates'?: ParkingGeometryCoordinates;
}

export const ParkingMachineGeometryTypeEnum = {
    Point: 'Point',
    Polygon: 'Polygon',
    MultiPolygon: 'MultiPolygon'
} as const;

export type ParkingMachineGeometryTypeEnum = typeof ParkingMachineGeometryTypeEnum[keyof typeof ParkingMachineGeometryTypeEnum];

/**
 * 
 * @export
 * @interface ParkingMachineProperties
 */
export interface ParkingMachineProperties {
    /**
     * ID of the parking machine. Formatted as primary_source-primary_source_id
     * @type {string}
     * @memberof ParkingMachineProperties
     */
    'id': string;
    /**
     * The primary source of the parking machine.
     * @type {string}
     * @memberof ParkingMachineProperties
     */
    'primary_source': ParkingMachinePropertiesPrimarySourceEnum;
    /**
     * The ID defined by the primary source.
     * @type {string}
     * @memberof ParkingMachineProperties
     */
    'primary_source_id'?: string | null;
    /**
     * TSK parking machine identification code.
     * @type {string}
     * @memberof ParkingMachineProperties
     */
    'code'?: string;
    /**
     * The type of the parking machine.   * `payment_machine` - a facility where payment can be made for parking; often equipped with payment options   * `info_box` - an installation providing information and possibly a QR code, without payment capabilities. 
     * @type {string}
     * @memberof ParkingMachineProperties
     */
    'machine_type'?: ParkingMachinePropertiesMachineTypeEnum;
    /**
     * The start date when the parking machine is valid.
     * @type {string}
     * @memberof ParkingMachineProperties
     */
    'valid_from': string;
    /**
     * The UUID identifier for the tariff connected to the parking machine.
     * @type {string}
     * @memberof ParkingMachineProperties
     */
    'tariff_id'?: string | null;
}

export const ParkingMachinePropertiesPrimarySourceEnum = {
    TskV2: 'tsk_v2'
} as const;

export type ParkingMachinePropertiesPrimarySourceEnum = typeof ParkingMachinePropertiesPrimarySourceEnum[keyof typeof ParkingMachinePropertiesPrimarySourceEnum];
export const ParkingMachinePropertiesMachineTypeEnum = {
    PaymentMachine: 'payment_machine',
    InfoBox: 'info_box'
} as const;

export type ParkingMachinePropertiesMachineTypeEnum = typeof ParkingMachinePropertiesMachineTypeEnum[keyof typeof ParkingMachinePropertiesMachineTypeEnum];

/**
 * 
 * @export
 * @interface ParkingMeasurement
 */
export interface ParkingMeasurement {
    /**
     * 
     * @type {string}
     * @memberof ParkingMeasurement
     */
    'source': string;
    /**
     * 
     * @type {string}
     * @memberof ParkingMeasurement
     */
    'source_id': string;
    /**
     * 
     * @type {string}
     * @memberof ParkingMeasurement
     */
    'parking_id': string;
    /**
     * 
     * @type {number}
     * @memberof ParkingMeasurement
     */
    'available_spot_number': number;
    /**
     * 
     * @type {number}
     * @memberof ParkingMeasurement
     */
    'closed_spot_number': number | null;
    /**
     * 
     * @type {number}
     * @memberof ParkingMeasurement
     */
    'occupied_spot_number': number;
    /**
     * 
     * @type {number}
     * @memberof ParkingMeasurement
     */
    'total_spot_number': number;
    /**
     * 
     * @type {string}
     * @memberof ParkingMeasurement
     */
    'date_modified': string;
}
/**
 * 
 * @export
 * @interface ParkingOccupancyMeasurement
 */
export interface ParkingOccupancyMeasurement {
    /**
     * 
     * @type {string}
     * @memberof ParkingOccupancyMeasurement
     */
    'parking_id'?: string;
    /**
     * The primary source of the parking location. Assigned by us.
     * @type {string}
     * @memberof ParkingOccupancyMeasurement
     */
    'primary_source'?: ParkingOccupancyMeasurementPrimarySourceEnum;
    /**
     * The ID defined by the primary source. As in the source data.
     * @type {string}
     * @memberof ParkingOccupancyMeasurement
     */
    'primary_source_id'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ParkingOccupancyMeasurement
     */
    'has_free_spots'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ParkingOccupancyMeasurement
     */
    'total_spot_number'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ParkingOccupancyMeasurement
     */
    'free_spot_number'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ParkingOccupancyMeasurement
     */
    'closed_spot_number'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ParkingOccupancyMeasurement
     */
    'occupied_spot_number'?: number | null;
    /**
     * The date and time when the info about the occupancy measurement was last updated.
     * @type {string}
     * @memberof ParkingOccupancyMeasurement
     */
    'last_updated'?: string;
}

export const ParkingOccupancyMeasurementPrimarySourceEnum = {
    TskV2: 'tsk_v2'
} as const;

export type ParkingOccupancyMeasurementPrimarySourceEnum = typeof ParkingOccupancyMeasurementPrimarySourceEnum[keyof typeof ParkingOccupancyMeasurementPrimarySourceEnum];

/**
 * 
 * @export
 * @interface ParkingPayment
 */
export interface ParkingPayment {
    /**
     * 
     * @type {ParkingPaymentProperties}
     * @memberof ParkingPayment
     */
    'properties'?: ParkingPaymentProperties;
}
/**
 * 
 * @export
 * @interface ParkingPaymentProperties
 */
export interface ParkingPaymentProperties {
    /**
     * 
     * @type {string}
     * @memberof ParkingPaymentProperties
     */
    'web_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParkingPaymentProperties
     */
    'android_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParkingPaymentProperties
     */
    'ios_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParkingPaymentProperties
     */
    'discovery_url'?: string | null;
}
/**
 * 
 * @export
 * @interface ParkingPeriodsOfTime
 */
export interface ParkingPeriodsOfTime {
    /**
     * Day of the week.
     * @type {string}
     * @memberof ParkingPeriodsOfTime
     */
    'day_in_week': ParkingPeriodsOfTimeDayInWeekEnum;
    /**
     * Start time of the periods of time.
     * @type {string}
     * @memberof ParkingPeriodsOfTime
     */
    'start': string;
    /**
     * End time of the periods of time.
     * @type {string}
     * @memberof ParkingPeriodsOfTime
     */
    'end': string;
    /**
     * Public holiday availability.
     * @type {string}
     * @memberof ParkingPeriodsOfTime
     */
    'ph': ParkingPeriodsOfTimePhEnum;
}

export const ParkingPeriodsOfTimeDayInWeekEnum = {
    Mo: 'Mo',
    Tu: 'Tu',
    We: 'We',
    Th: 'Th',
    Fr: 'Fr',
    Sa: 'Sa',
    Su: 'Su'
} as const;

export type ParkingPeriodsOfTimeDayInWeekEnum = typeof ParkingPeriodsOfTimeDayInWeekEnum[keyof typeof ParkingPeriodsOfTimeDayInWeekEnum];
export const ParkingPeriodsOfTimePhEnum = {
    PhOnly: 'PH_only',
    PhOff: 'PH_off'
} as const;

export type ParkingPeriodsOfTimePhEnum = typeof ParkingPeriodsOfTimePhEnum[keyof typeof ParkingPeriodsOfTimePhEnum];

/**
 * 
 * @export
 * @interface ParkingPeriodsOfTimeWithDuration
 */
export interface ParkingPeriodsOfTimeWithDuration {
    /**
     * Day of the week.
     * @type {string}
     * @memberof ParkingPeriodsOfTimeWithDuration
     */
    'day_in_week': ParkingPeriodsOfTimeWithDurationDayInWeekEnum;
    /**
     * Start time of the periods of time.
     * @type {string}
     * @memberof ParkingPeriodsOfTimeWithDuration
     */
    'start': string;
    /**
     * End time of the periods of time.
     * @type {string}
     * @memberof ParkingPeriodsOfTimeWithDuration
     */
    'end': string;
    /**
     * Public holiday availability.
     * @type {string}
     * @memberof ParkingPeriodsOfTimeWithDuration
     */
    'ph': ParkingPeriodsOfTimeWithDurationPhEnum;
    /**
     * Time in minutes.
     * @type {number}
     * @memberof ParkingPeriodsOfTimeWithDuration
     */
    'maximum_duration'?: number | null;
    /**
     * Need to use a parking disc.
     * @type {boolean}
     * @memberof ParkingPeriodsOfTimeWithDuration
     */
    'disc_parking'?: boolean | null;
}

export const ParkingPeriodsOfTimeWithDurationDayInWeekEnum = {
    Mo: 'Mo',
    Tu: 'Tu',
    We: 'We',
    Th: 'Th',
    Fr: 'Fr',
    Sa: 'Sa',
    Su: 'Su'
} as const;

export type ParkingPeriodsOfTimeWithDurationDayInWeekEnum = typeof ParkingPeriodsOfTimeWithDurationDayInWeekEnum[keyof typeof ParkingPeriodsOfTimeWithDurationDayInWeekEnum];
export const ParkingPeriodsOfTimeWithDurationPhEnum = {
    PhOnly: 'PH_only',
    PhOff: 'PH_off'
} as const;

export type ParkingPeriodsOfTimeWithDurationPhEnum = typeof ParkingPeriodsOfTimeWithDurationPhEnum[keyof typeof ParkingPeriodsOfTimeWithDurationPhEnum];

/**
 * 
 * @export
 * @interface ParkingProhibitions
 */
export interface ParkingProhibitions {
    /**
     * LPG/CNG vehicles permitted to enter the parking.
     * @type {boolean}
     * @memberof ParkingProhibitions
     */
    'lpg/cng': boolean | null;
    /**
     * buses permitted to enter the parking.
     * @type {boolean}
     * @memberof ParkingProhibitions
     */
    'bus': boolean | null;
    /**
     * trucks permitted to enter the parking.
     * @type {boolean}
     * @memberof ParkingProhibitions
     */
    'truck': boolean | null;
    /**
     * motorcycles permitted to enter the parking.
     * @type {boolean}
     * @memberof ParkingProhibitions
     */
    'motorcycle': boolean | null;
    /**
     * bicycles permitted to enter the parking.
     * @type {boolean}
     * @memberof ParkingProhibitions
     */
    'bicycle': boolean | null;
    /**
     * trailers permitted to enter the parking.
     * @type {boolean}
     * @memberof ParkingProhibitions
     */
    'trailer': boolean | null;
}
/**
 * 
 * @export
 * @interface ParkingProperties
 */
export interface ParkingProperties {
    /**
     * The identifier for the parking location.
     * @type {string}
     * @memberof ParkingProperties
     */
    'id': string;
    /**
     * The primary source of the parking location. Assigned by us.
     * @type {string}
     * @memberof ParkingProperties
     */
    'primary_source': ParkingPropertiesPrimarySourceEnum;
    /**
     * The ID defined by the primary source. As in the source data.
     * @type {string}
     * @memberof ParkingProperties
     */
    'primary_source_id'?: string | null;
    /**
     * The name of the parking location.
     * @type {string}
     * @memberof ParkingProperties
     */
    'name'?: string | null;
    /**
     * The start date and time when the parking location is opened from. Or date of implementation.
     * @type {string}
     * @memberof ParkingProperties
     */
    'valid_from': string;
    /**
     * 
     * @type {ParkingPropertiesCentroid}
     * @memberof ParkingProperties
     */
    'centroid': ParkingPropertiesCentroid;
    /**
     * The date and time when info about the parking location was last checked and updated.
     * @type {string}
     * @memberof ParkingProperties
     */
    'last_updated_at': string;
    /**
     * The date and time when the parking location was last modified at the source. In case data source provides it.
     * @type {string}
     * @memberof ParkingProperties
     */
    'last_modified_at_source'?: string;
    /**
     * Whether the parking location has security.
     * @type {boolean}
     * @memberof ParkingProperties
     */
    'security'?: boolean | null;
    /**
     * 
     * @type {ParkingDimension}
     * @memberof ParkingProperties
     */
    'dimensions'?: ParkingDimension | null;
    /**
     * 
     * @type {ParkingProhibitions}
     * @memberof ParkingProperties
     */
    'parking_prohibitions'?: ParkingProhibitions;
    /**
     * 
     * @type {boolean}
     * @memberof ParkingProperties
     */
    'covered'?: boolean | null;
    /**
     * The capacity of the parking location.
     * @type {number}
     * @memberof ParkingProperties
     */
    'capacity'?: number | null;
    /**
     * The parking policy of the parking location. * `park_and_ride` - parking for transit users * `kiss_and_ride` - short-term passenger drop-off * `commercial` - paid parking for public * `zone` - parking restricted by area (e.g., blue, violet, orange) * `park_sharing` - shared parking spaces * `customer_only` - exclusive for customers 
     * @type {string}
     * @memberof ParkingProperties
     */
    'parking_policy'?: ParkingPropertiesParkingPolicyEnum | null;
    /**
     * 
     * @type {ParkingPropertiesContact}
     * @memberof ParkingProperties
     */
    'contact'?: ParkingPropertiesContact;
    /**
     * Specific marking of parking space (blue zone, A zone etc.).
     * @type {string}
     * @memberof ParkingProperties
     */
    'filter'?: string;
    /**
     * The parking type of the parking location. * `on_street` - parking on the street * `underground` - subterranean parking facility * `multi_storey` - multi-level parking garage * `surface` - open-air parking lot * `rooftop` - parking on building roof 
     * @type {string}
     * @memberof ParkingProperties
     */
    'parking_type'?: ParkingPropertiesParkingTypeEnum;
    /**
     * 
     * @type {ParkingPropertiesSpace}
     * @memberof ParkingProperties
     */
    'space'?: ParkingPropertiesSpace;
    /**
     * 
     * @type {ParkingPropertiesEntrances}
     * @memberof ParkingProperties
     */
    'entrances'?: ParkingPropertiesEntrances;
    /**
     * 
     * @type {ParkingPayment}
     * @memberof ParkingProperties
     */
    'payment'?: ParkingPayment;
    /**
     * 
     * @type {ParkingReservation}
     * @memberof ParkingProperties
     */
    'reservation'?: ParkingReservation;
    /**
     * UUID of related parking tariff.
     * @type {string}
     * @memberof ParkingProperties
     */
    'tariff'?: string;
    /**
     * Array is sorted by valid_from.
     * @type {Array<OpeningHours>}
     * @memberof ParkingProperties
     */
    'opening_hours'?: Array<OpeningHours> | null;
    /**
     * True if average occupancy info calculated from measurements is available
     * @type {boolean}
     * @memberof ParkingProperties
     */
    'has_occupancy_info'?: boolean;
}

export const ParkingPropertiesPrimarySourceEnum = {
    TskV2: 'tsk_v2'
} as const;

export type ParkingPropertiesPrimarySourceEnum = typeof ParkingPropertiesPrimarySourceEnum[keyof typeof ParkingPropertiesPrimarySourceEnum];
export const ParkingPropertiesParkingPolicyEnum = {
    ParkAndRide: 'park_and_ride',
    KissAndRide: 'kiss_and_ride',
    Commercial: 'commercial',
    Zone: 'zone',
    ParkSharing: 'park_sharing',
    CustomerOnly: 'customer_only'
} as const;

export type ParkingPropertiesParkingPolicyEnum = typeof ParkingPropertiesParkingPolicyEnum[keyof typeof ParkingPropertiesParkingPolicyEnum];
export const ParkingPropertiesParkingTypeEnum = {
    OnStreet: 'on_street',
    Underground: 'underground',
    MultiStorey: 'multi_storey',
    Surface: 'surface',
    Rooftop: 'rooftop'
} as const;

export type ParkingPropertiesParkingTypeEnum = typeof ParkingPropertiesParkingTypeEnum[keyof typeof ParkingPropertiesParkingTypeEnum];

/**
 * The GeoJSON centroid of the parking location, centroid is always point in geometry.
 * @export
 * @interface ParkingPropertiesCentroid
 */
export interface ParkingPropertiesCentroid {
    /**
     * 
     * @type {string}
     * @memberof ParkingPropertiesCentroid
     */
    'type'?: ParkingPropertiesCentroidTypeEnum;
    /**
     * 
     * @type {Array<number>}
     * @memberof ParkingPropertiesCentroid
     */
    'coordinates'?: Array<number>;
}

export const ParkingPropertiesCentroidTypeEnum = {
    Point: 'Point'
} as const;

export type ParkingPropertiesCentroidTypeEnum = typeof ParkingPropertiesCentroidTypeEnum[keyof typeof ParkingPropertiesCentroidTypeEnum];

/**
 * 
 * @export
 * @interface ParkingPropertiesContact
 */
export interface ParkingPropertiesContact {
    /**
     * The email of the parking location.
     * @type {string}
     * @memberof ParkingPropertiesContact
     */
    'email'?: string | null;
    /**
     * The phone number of the parking location.
     * @type {string}
     * @memberof ParkingPropertiesContact
     */
    'phone'?: string | null;
    /**
     * The website of the parking location.
     * @type {string}
     * @memberof ParkingPropertiesContact
     */
    'web_url'?: string | null;
}
/**
 * Features are sorted by entrance_id.
 * @export
 * @interface ParkingPropertiesEntrances
 */
export interface ParkingPropertiesEntrances {
    /**
     * 
     * @type {Array<ParkingEntrance>}
     * @memberof ParkingPropertiesEntrances
     */
    'features'?: Array<ParkingEntrance>;
    /**
     * 
     * @type {string}
     * @memberof ParkingPropertiesEntrances
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface ParkingPropertiesSpace
 */
export interface ParkingPropertiesSpace {
    /**
     * 
     * @type {Array<ParkingSpace>}
     * @memberof ParkingPropertiesSpace
     */
    'features'?: Array<ParkingSpace>;
    /**
     * 
     * @type {string}
     * @memberof ParkingPropertiesSpace
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface ParkingReservation
 */
export interface ParkingReservation {
    /**
     * 
     * @type {ParkingReservationProperties}
     * @memberof ParkingReservation
     */
    'properties'?: ParkingReservationProperties;
}
/**
 * 
 * @export
 * @interface ParkingReservationProperties
 */
export interface ParkingReservationProperties {
    /**
     * 
     * @type {string}
     * @memberof ParkingReservationProperties
     */
    'reservation_type'?: ParkingReservationPropertiesReservationTypeEnum | null;
    /**
     * 
     * @type {string}
     * @memberof ParkingReservationProperties
     */
    'web_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParkingReservationProperties
     */
    'android_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParkingReservationProperties
     */
    'ios_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParkingReservationProperties
     */
    'discovery_url'?: string | null;
}

export const ParkingReservationPropertiesReservationTypeEnum = {
    Possible: 'possible',
    NotPossible: 'not_possible',
    Required: 'required'
} as const;

export type ParkingReservationPropertiesReservationTypeEnum = typeof ParkingReservationPropertiesReservationTypeEnum[keyof typeof ParkingReservationPropertiesReservationTypeEnum];

/**
 * 
 * @export
 * @interface ParkingSource
 */
export interface ParkingSource {
    /**
     * unik√°tn√≠ identifik√°tor poskytovatele
     * @type {string}
     * @memberof ParkingSource
     */
    'source'?: string;
    /**
     * jm√©no poskytovatele
     * @type {string}
     * @memberof ParkingSource
     */
    'name'?: string | null;
    /**
     * 
     * @type {ParkingSourceContact}
     * @memberof ParkingSource
     */
    'contact'?: ParkingSourceContact | null;
}
/**
 * 
 * @export
 * @interface ParkingSourceContact
 */
export interface ParkingSourceContact {
    /**
     * 
     * @type {string}
     * @memberof ParkingSourceContact
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParkingSourceContact
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParkingSourceContact
     */
    'web_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParkingSourceContact
     */
    'term_of_use_url'?: string | null;
}
/**
 * 
 * @export
 * @interface ParkingSpace
 */
export interface ParkingSpace {
    /**
     * 
     * @type {ParkingSpaceGeometry}
     * @memberof ParkingSpace
     */
    'geometry'?: ParkingSpaceGeometry;
    /**
     * 
     * @type {ParkingSpaceProperties}
     * @memberof ParkingSpace
     */
    'properties'?: ParkingSpaceProperties;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpace
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface ParkingSpaceFeature
 */
export interface ParkingSpaceFeature {
    /**
     * 
     * @type {ParkingLotFeatureGeometry}
     * @memberof ParkingSpaceFeature
     */
    'geometry'?: ParkingLotFeatureGeometry;
    /**
     * 
     * @type {ParkingSpaceFeatureProperties}
     * @memberof ParkingSpaceFeature
     */
    'properties'?: ParkingSpaceFeatureProperties;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceFeature
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface ParkingSpaceFeatureProperties
 */
export interface ParkingSpaceFeatureProperties {
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceFeatureProperties
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceFeatureProperties
     */
    'source': string;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceFeatureProperties
     */
    'source_id': string;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceFeatureProperties
     */
    'data_provider'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceFeatureProperties
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceFeatureProperties
     */
    'category'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceFeatureProperties
     */
    'date_modified': string | null;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceFeatureProperties
     */
    'address_formatted'?: string | null;
    /**
     * 
     * @type {ParkingLotFeaturePropertiesAddress}
     * @memberof ParkingSpaceFeatureProperties
     */
    'address'?: ParkingLotFeaturePropertiesAddress | null;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceFeatureProperties
     */
    'area_served'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceFeatureProperties
     */
    'web_app_payment_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceFeatureProperties
     */
    'android_app_payment_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceFeatureProperties
     */
    'ios_app_payment_url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ParkingSpaceFeatureProperties
     */
    'total_spot_number'?: number;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceFeatureProperties
     */
    'tariff_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceFeatureProperties
     */
    'valid_from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceFeatureProperties
     */
    'valid_to'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceFeatureProperties
     */
    'parking_type': ParkingSpaceFeaturePropertiesParkingTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceFeatureProperties
     */
    'zone_type'?: ParkingSpaceFeaturePropertiesZoneTypeEnum | null;
    /**
     * 
     * @type {ParkingSpaceFeaturePropertiesCentroid}
     * @memberof ParkingSpaceFeatureProperties
     */
    'centroid': ParkingSpaceFeaturePropertiesCentroid;
    /**
     * 
     * @type {number}
     * @memberof ParkingSpaceFeatureProperties
     */
    'available_spots_last_updated': number | null;
    /**
     * 
     * @type {number}
     * @memberof ParkingSpaceFeatureProperties
     */
    'available_spots_number': number | null;
}

export const ParkingSpaceFeaturePropertiesParkingTypeEnum = {
    ParkAndRide: 'park_and_ride',
    ParkPaidPrivate: 'park_paid_private',
    OnStreet: 'on_street',
    ParkSharing: 'park_sharing',
    DisabledParking: 'disabled_parking',
    Underground: 'underground'
} as const;

export type ParkingSpaceFeaturePropertiesParkingTypeEnum = typeof ParkingSpaceFeaturePropertiesParkingTypeEnum[keyof typeof ParkingSpaceFeaturePropertiesParkingTypeEnum];
export const ParkingSpaceFeaturePropertiesZoneTypeEnum = {
    ZoneResidential: 'zone_residential',
    ZoneMixed: 'zone_mixed',
    ZoneVisitors: 'zone_visitors',
    ZoneOther: 'zone_other',
    ZoneFree: 'zone_free'
} as const;

export type ParkingSpaceFeaturePropertiesZoneTypeEnum = typeof ParkingSpaceFeaturePropertiesZoneTypeEnum[keyof typeof ParkingSpaceFeaturePropertiesZoneTypeEnum];

/**
 * 
 * @export
 * @interface ParkingSpaceFeaturePropertiesCentroid
 */
export interface ParkingSpaceFeaturePropertiesCentroid {
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceFeaturePropertiesCentroid
     */
    'type'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ParkingSpaceFeaturePropertiesCentroid
     */
    'coordinates'?: Array<number>;
}
/**
 * GeoJSON geometry of the parking space.
 * @export
 * @interface ParkingSpaceGeometry
 */
export interface ParkingSpaceGeometry {
    /**
     * The type of geometry (GeoJSON Point, Polygon, MultiPolygon).
     * @type {string}
     * @memberof ParkingSpaceGeometry
     */
    'type'?: ParkingSpaceGeometryTypeEnum;
    /**
     * 
     * @type {ParkingGeometryCoordinates}
     * @memberof ParkingSpaceGeometry
     */
    'coordinates'?: ParkingGeometryCoordinates;
}

export const ParkingSpaceGeometryTypeEnum = {
    Point: 'Point',
    Polygon: 'Polygon',
    MultiPolygon: 'MultiPolygon'
} as const;

export type ParkingSpaceGeometryTypeEnum = typeof ParkingSpaceGeometryTypeEnum[keyof typeof ParkingSpaceGeometryTypeEnum];

/**
 * 
 * @export
 * @interface ParkingSpaceProperties
 */
export interface ParkingSpaceProperties {
    /**
     * The identifier for the parking space.
     * @type {string}
     * @memberof ParkingSpaceProperties
     */
    'id': string;
    /**
     * The capacity of the parking space.
     * @type {number}
     * @memberof ParkingSpaceProperties
     */
    'capacity'?: number | null;
    /**
     * Array of dedicated access types for the parking space, where empty array means no restriction = open for all vehicles: * `disabled` - reserved for disabled individuals * `charging` - intended for electric vehicle charging * `parent` - designated for parents with children * `delivery` - exclusively for delivery purposes * `customer` -  exclusive for customers * `resident` - reserved for residents * `bus` - reserved for buses * `designated` - specific purpose (e.g., school, embassy) * `truck` - reserved for trucks * `motorcycle` - for motorcycles only * `RV` - reserved for recreational vehicles 
     * @type {Array<string>}
     * @memberof ParkingSpaceProperties
     */
    'access_dedicated_to'?: Array<ParkingSpacePropertiesAccessDedicatedToEnum> | null;
    /**
     * 
     * @type {ParkingAddress}
     * @memberof ParkingSpaceProperties
     */
    'address'?: ParkingAddress;
}

export const ParkingSpacePropertiesAccessDedicatedToEnum = {
    Disabled: 'disabled',
    Charging: 'charging',
    Parent: 'parent',
    Delivery: 'delivery',
    Customer: 'customer',
    Resident: 'resident',
    Bus: 'bus',
    Designated: 'designated',
    Truck: 'truck',
    Motorcycle: 'motorcycle',
    Rv: 'RV'
} as const;

export type ParkingSpacePropertiesAccessDedicatedToEnum = typeof ParkingSpacePropertiesAccessDedicatedToEnum[keyof typeof ParkingSpacePropertiesAccessDedicatedToEnum];

/**
 * 
 * @export
 * @interface ParkingSpaceTariff
 */
export interface ParkingSpaceTariff {
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceTariff
     */
    'tariff_id': string;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceTariff
     */
    'source': string;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceTariff
     */
    'last_updated': string;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceTariff
     */
    'payment_mode': string;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceTariff
     */
    'payment_additional_description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ParkingSpaceTariff
     */
    'free_of_charge': boolean;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceTariff
     */
    'url_link_address'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceTariff
     */
    'charge_band_name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ParkingSpaceTariff
     */
    'payment_methods'?: Array<ParkingSpaceTariffPaymentMethodsEnum>;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceTariff
     */
    'charge_currency': string;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceTariff
     */
    'allowed_vehicle_type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceTariff
     */
    'allowed_fuel_type'?: string | null;
    /**
     * 
     * @type {Array<ParkingSpaceTariffCharge>}
     * @memberof ParkingSpaceTariff
     */
    'charges'?: Array<ParkingSpaceTariffCharge>;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceTariff
     */
    'reservation_url'?: string | null;
}

export const ParkingSpaceTariffPaymentMethodsEnum = {
    CardOnline: 'card_online',
    CardOffline: 'card_offline',
    Cash: 'cash',
    CoinsOnly: 'coins_only',
    MobileApp: 'mobile_app',
    Litacka: 'litacka',
    SmsPayment: 'sms_payment',
    ApplePay: 'apple_pay',
    GooglePay: 'google_pay',
    Unknown: 'unknown'
} as const;

export type ParkingSpaceTariffPaymentMethodsEnum = typeof ParkingSpaceTariffPaymentMethodsEnum[keyof typeof ParkingSpaceTariffPaymentMethodsEnum];

/**
 * 
 * @export
 * @interface ParkingSpaceTariffCharge
 */
export interface ParkingSpaceTariffCharge {
    /**
     * 
     * @type {number}
     * @memberof ParkingSpaceTariffCharge
     */
    'charge': number;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceTariffCharge
     */
    'charge_type'?: ParkingSpaceTariffChargeChargeTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof ParkingSpaceTariffCharge
     */
    'charge_order_index': number;
    /**
     * 
     * @type {number}
     * @memberof ParkingSpaceTariffCharge
     */
    'charge_interval'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ParkingSpaceTariffCharge
     */
    'max_iterations_of_charge'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ParkingSpaceTariffCharge
     */
    'min_iterations_of_charge'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceTariffCharge
     */
    'start_time_of_period'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParkingSpaceTariffCharge
     */
    'end_time_of_period'?: string | null;
}

export const ParkingSpaceTariffChargeChargeTypeEnum = {
    Minimum: 'minimum',
    Maximum: 'maximum',
    AdditionalIntervalPrice: 'additional_interval_price',
    SeasonTicket: 'season_ticket',
    TemporaryPrice: 'temporary_price',
    FirstIntervalPrice: 'first_interval_price',
    FreeParking: 'free_parking',
    Flat: 'flat',
    Unknown: 'unknown',
    Other: 'other'
} as const;

export type ParkingSpaceTariffChargeChargeTypeEnum = typeof ParkingSpaceTariffChargeChargeTypeEnum[keyof typeof ParkingSpaceTariffChargeChargeTypeEnum];

/**
 * 
 * @export
 * @interface ParkingTariff
 */
export interface ParkingTariff {
    /**
     * The UUID identifier for the tariff.
     * @type {string}
     * @memberof ParkingTariff
     */
    'id': string;
    /**
     * Array of Charge Band objects that represent tariff categories for different users. Items are sorted by charge_band_name.
     * @type {Array<ParkingChargeBand>}
     * @memberof ParkingTariff
     */
    'charge_bands': Array<ParkingChargeBand>;
}
/**
 * 
 * @export
 * @interface PedestriansDirection
 */
export interface PedestriansDirection {
    /**
     * 
     * @type {number}
     * @memberof PedestriansDirection
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PedestriansDirection
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PedestriansDirection
     */
    'to': number;
}
/**
 * 
 * @export
 * @interface PedestriansLocation
 */
export interface PedestriansLocation {
    /**
     * Location id
     * @type {string}
     * @memberof PedestriansLocation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PedestriansLocation
     */
    'location_name': string;
    /**
     * 
     * @type {string}
     * @memberof PedestriansLocation
     */
    'lat': string;
    /**
     * 
     * @type {string}
     * @memberof PedestriansLocation
     */
    'lng': string;
    /**
     * 
     * @type {string}
     * @memberof PedestriansLocation
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof PedestriansLocation
     */
    'city_district': string;
    /**
     * 
     * @type {string}
     * @memberof PedestriansLocation
     */
    'tech': string;
    /**
     * 
     * @type {string}
     * @memberof PedestriansLocation
     */
    'map_url': string;
    /**
     * 
     * @type {string}
     * @memberof PedestriansLocation
     */
    'photo_url': string;
    /**
     * 
     * @type {string}
     * @memberof PedestriansLocation
     */
    'measurement_start': string;
    /**
     * 
     * @type {string}
     * @memberof PedestriansLocation
     */
    'measurement_end'?: string;
    /**
     * 
     * @type {Array<PedestriansDirection>}
     * @memberof PedestriansLocation
     */
    'directions'?: Array<PedestriansDirection>;
}
/**
 * 
 * @export
 * @interface PedestriansMeasurement
 */
export interface PedestriansMeasurement {
    /**
     * 
     * @type {string}
     * @memberof PedestriansMeasurement
     */
    'location_id': string;
    /**
     * 
     * @type {string}
     * @memberof PedestriansMeasurement
     */
    'direction_id': string;
    /**
     * 
     * @type {string}
     * @memberof PedestriansMeasurement
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof PedestriansMeasurement
     */
    'quality': string;
    /**
     * 
     * @type {string}
     * @memberof PedestriansMeasurement
     */
    'measured_from': string;
    /**
     * 
     * @type {string}
     * @memberof PedestriansMeasurement
     */
    'measured_to': string;
}
/**
 * 
 * @export
 * @interface Playground
 */
export interface Playground {
    /**
     * 
     * @type {GardenGeometry}
     * @memberof Playground
     */
    'geometry'?: GardenGeometry;
    /**
     * 
     * @type {PlaygroundProperties}
     * @memberof Playground
     */
    'properties'?: PlaygroundProperties;
    /**
     * 
     * @type {string}
     * @memberof Playground
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface PlaygroundProperties
 */
export interface PlaygroundProperties {
    /**
     * 
     * @type {PlaygroundPropertiesImage}
     * @memberof PlaygroundProperties
     */
    'image'?: PlaygroundPropertiesImage;
    /**
     * 
     * @type {string}
     * @memberof PlaygroundProperties
     */
    'content': string;
    /**
     * 
     * @type {number}
     * @memberof PlaygroundProperties
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PlaygroundProperties
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PlaygroundProperties
     */
    'perex'?: string;
    /**
     * 
     * @type {Array<PlaygroundProperty>}
     * @memberof PlaygroundProperties
     */
    'properties'?: Array<PlaygroundProperty>;
    /**
     * 
     * @type {string}
     * @memberof PlaygroundProperties
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlaygroundProperties
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof PlaygroundProperties
     */
    'district'?: string;
    /**
     * 
     * @type {MedicalInstitutionPropertiesAddress}
     * @memberof PlaygroundProperties
     */
    'address'?: MedicalInstitutionPropertiesAddress;
}
/**
 * 
 * @export
 * @interface PlaygroundPropertiesImage
 */
export interface PlaygroundPropertiesImage {
    /**
     * 
     * @type {string}
     * @memberof PlaygroundPropertiesImage
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface PlaygroundProperty
 */
export interface PlaygroundProperty {
    /**
     * 
     * @type {number}
     * @memberof PlaygroundProperty
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PlaygroundProperty
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface Point3
 */
export interface Point3 {
    /**
     * 
     * @type {number}
     * @memberof Point3
     */
    'point_id': number;
    /**
     * 
     * @type {number}
     * @memberof Point3
     */
    'location_id': number;
    /**
     * 
     * @type {string}
     * @memberof Point3
     */
    'point_named'?: string;
    /**
     * 
     * @type {string}
     * @memberof Point3
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof Point3
     */
    'loc_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Point3
     */
    'loc_orientation'?: string;
    /**
     * 
     * @type {string}
     * @memberof Point3
     */
    'loc_surface'?: string;
    /**
     * 
     * @type {number}
     * @memberof Point3
     */
    'lat'?: number;
    /**
     * 
     * @type {number}
     * @memberof Point3
     */
    'lng'?: number;
    /**
     * 
     * @type {number}
     * @memberof Point3
     */
    'x_jtsk'?: number;
    /**
     * 
     * @type {number}
     * @memberof Point3
     */
    'y_jtsk'?: number;
    /**
     * 
     * @type {number}
     * @memberof Point3
     */
    'elevation_m'?: number;
    /**
     * 
     * @type {Array<Point3MeasuresInner>}
     * @memberof Point3
     */
    'measures'?: Array<Point3MeasuresInner>;
    /**
     * 
     * @type {string}
     * @memberof Point3
     */
    'sensor_position'?: string;
    /**
     * 
     * @type {string}
     * @memberof Point3
     */
    'sensor_position_detail'?: string;
}
/**
 * 
 * @export
 * @interface Point3MeasuresInner
 */
export interface Point3MeasuresInner {
    /**
     * 
     * @type {string}
     * @memberof Point3MeasuresInner
     */
    'measure': string;
    /**
     * 
     * @type {string}
     * @memberof Point3MeasuresInner
     */
    'measure_cz'?: string;
    /**
     * 
     * @type {string}
     * @memberof Point3MeasuresInner
     */
    'unit': string;
}
/**
 * 
 * @export
 * @interface PotHolesCollection
 */
export interface PotHolesCollection {
    /**
     * 
     * @type {Array<Potholes>}
     * @memberof PotHolesCollection
     */
    'features'?: Array<Potholes>;
    /**
     * 
     * @type {string}
     * @memberof PotHolesCollection
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface Potholes
 */
export interface Potholes {
    /**
     * 
     * @type {PotholesGeometry}
     * @memberof Potholes
     */
    'geometry'?: PotholesGeometry;
    /**
     * 
     * @type {PotholesProperties}
     * @memberof Potholes
     */
    'properties'?: PotholesProperties;
    /**
     * 
     * @type {string}
     * @memberof Potholes
     */
    'type'?: string;
}
/**
 * incident location
 * @export
 * @interface PotholesGeometry
 */
export interface PotholesGeometry {
    /**
     * 
     * @type {Array<number>}
     * @memberof PotholesGeometry
     */
    'coordinates'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof PotholesGeometry
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface PotholesProperties
 */
export interface PotholesProperties {
    /**
     * incident unique ID according to Waze
     * @type {string}
     * @memberof PotholesProperties
     */
    'uuid'?: string;
    /**
     * city
     * @type {string}
     * @memberof PotholesProperties
     */
    'city'?: string;
    /**
     * street
     * @type {string}
     * @memberof PotholesProperties
     */
    'street'?: string;
    /**
     * road type/class/level
     * @type {string}
     * @memberof PotholesProperties
     */
    'road_type'?: string;
    /**
     * driving angle in degrees according to the reporting driver; 0-359, 0=North
     * @type {number}
     * @memberof PotholesProperties
     */
    'event_direction'?: number;
    /**
     * uuid publication date and time from Waze
     * @type {string}
     * @memberof PotholesProperties
     */
    'published_at'?: string;
    /**
     * recording date and time to database
     * @type {string}
     * @memberof PotholesProperties
     */
    'valid_from'?: string;
    /**
     * date and time of last received incident to database
     * @type {string}
     * @memberof PotholesProperties
     */
    'last_reported_at'?: string;
    /**
     * reliability score based on other user‚Äôs reactions (\'Thumbs up\' etc.) and the level of the reporter; range 0-10, 10=max.
     * @type {number}
     * @memberof PotholesProperties
     */
    'reliability'?: number;
    /**
     * confidence score based only on other user‚Äôs reactions (\'Thumbs up\' etc.); range 0-10, 10=max.
     * @type {number}
     * @memberof PotholesProperties
     */
    'confidence'?: number;
    /**
     * how many of one, two or more identical incidents with the same \'uuid\' was dumped; 0=origin, 1=the first duplicate appeared
     * @type {number}
     * @memberof PotholesProperties
     */
    'duplicate_count'?: number;
}
/**
 * 
 * @export
 * @interface SharedCar
 */
export interface SharedCar {
    /**
     * 
     * @type {SharedVehicleGeometry}
     * @memberof SharedCar
     */
    'geometry'?: SharedVehicleGeometry;
    /**
     * 
     * @type {SharedCarProperties}
     * @memberof SharedCar
     */
    'properties'?: SharedCarProperties;
    /**
     * 
     * @type {string}
     * @memberof SharedCar
     */
    'type'?: SharedCarTypeEnum;
}

export const SharedCarTypeEnum = {
    Feature: 'Feature'
} as const;

export type SharedCarTypeEnum = typeof SharedCarTypeEnum[keyof typeof SharedCarTypeEnum];

/**
 * 
 * @export
 * @interface SharedCarAvailability
 */
export interface SharedCarAvailability {
    /**
     * 
     * @type {number}
     * @memberof SharedCarAvailability
     */
    'id': SharedCarAvailabilityIdEnum;
    /**
     * 
     * @type {string}
     * @memberof SharedCarAvailability
     */
    'description': SharedCarAvailabilityDescriptionEnum;
}

export const SharedCarAvailabilityIdEnum = {
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type SharedCarAvailabilityIdEnum = typeof SharedCarAvailabilityIdEnum[keyof typeof SharedCarAvailabilityIdEnum];
export const SharedCarAvailabilityDescriptionEnum = {
    Ihned: 'ihned',
    DleDomluvySProvozovatelem: 'dle domluvy s provozovatelem'
} as const;

export type SharedCarAvailabilityDescriptionEnum = typeof SharedCarAvailabilityDescriptionEnum[keyof typeof SharedCarAvailabilityDescriptionEnum];

/**
 * 
 * @export
 * @interface SharedCarCompany
 */
export interface SharedCarCompany {
    /**
     * 
     * @type {string}
     * @memberof SharedCarCompany
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SharedCarCompany
     */
    'web': string;
    /**
     * 
     * @type {string}
     * @memberof SharedCarCompany
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SharedCarCompany
     */
    'phone'?: string | null;
}
/**
 * 
 * @export
 * @interface SharedCarFuel
 */
export interface SharedCarFuel {
    /**
     * 
     * @type {number}
     * @memberof SharedCarFuel
     */
    'id': SharedCarFuelIdEnum;
    /**
     * 
     * @type {string}
     * @memberof SharedCarFuel
     */
    'description': SharedCarFuelDescriptionEnum;
}

export const SharedCarFuelIdEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_7: 7
} as const;

export type SharedCarFuelIdEnum = typeof SharedCarFuelIdEnum[keyof typeof SharedCarFuelIdEnum];
export const SharedCarFuelDescriptionEnum = {
    Neznm: 'nezn√°m√Ω',
    Benzn: 'benz√≠n',
    Nafta: 'nafta',
    BenznLpg: 'benz√≠n + LPG',
    Elektina: 'elekt≈ôina',
    Hybrid: 'hybrid',
    Jin: 'jin√Ω'
} as const;

export type SharedCarFuelDescriptionEnum = typeof SharedCarFuelDescriptionEnum[keyof typeof SharedCarFuelDescriptionEnum];

/**
 * 
 * @export
 * @interface SharedCarProperties
 */
export interface SharedCarProperties {
    /**
     * 
     * @type {string}
     * @memberof SharedCarProperties
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SharedCarProperties
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SharedCarProperties
     */
    'res_url': string;
    /**
     * 
     * @type {SharedCarCompany}
     * @memberof SharedCarProperties
     */
    'company'?: SharedCarCompany;
    /**
     * 
     * @type {SharedCarAvailability}
     * @memberof SharedCarProperties
     */
    'availability'?: SharedCarAvailability;
    /**
     * 
     * @type {SharedCarFuel}
     * @memberof SharedCarProperties
     */
    'fuel'?: SharedCarFuel;
    /**
     * 
     * @type {string}
     * @memberof SharedCarProperties
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface SharedVehicle
 */
export interface SharedVehicle {
    /**
     * 
     * @type {SharedVehicleGeometry}
     * @memberof SharedVehicle
     */
    'geometry'?: SharedVehicleGeometry;
    /**
     * 
     * @type {SharedVehicleProperties}
     * @memberof SharedVehicle
     */
    'properties'?: SharedVehicleProperties;
    /**
     * 
     * @type {string}
     * @memberof SharedVehicle
     */
    'type'?: SharedVehicleTypeEnum;
}

export const SharedVehicleTypeEnum = {
    Feature: 'Feature'
} as const;

export type SharedVehicleTypeEnum = typeof SharedVehicleTypeEnum[keyof typeof SharedVehicleTypeEnum];

/**
 * 
 * @export
 * @interface SharedVehicleCompany
 */
export interface SharedVehicleCompany {
    /**
     * 
     * @type {string}
     * @memberof SharedVehicleCompany
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SharedVehicleCompany
     */
    'web': string;
    /**
     * 
     * @type {string}
     * @memberof SharedVehicleCompany
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SharedVehicleCompany
     */
    'phone'?: string | null;
}
/**
 * 
 * @export
 * @interface SharedVehicleGeometry
 */
export interface SharedVehicleGeometry {
    /**
     * 
     * @type {string}
     * @memberof SharedVehicleGeometry
     */
    'type'?: SharedVehicleGeometryTypeEnum;
    /**
     * 
     * @type {Array<number>}
     * @memberof SharedVehicleGeometry
     */
    'coordinates'?: Array<number>;
}

export const SharedVehicleGeometryTypeEnum = {
    Point: 'Point'
} as const;

export type SharedVehicleGeometryTypeEnum = typeof SharedVehicleGeometryTypeEnum[keyof typeof SharedVehicleGeometryTypeEnum];

/**
 * 
 * @export
 * @interface SharedVehicleProperties
 */
export interface SharedVehicleProperties {
    /**
     * 
     * @type {string}
     * @memberof SharedVehicleProperties
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof SharedVehicleProperties
     */
    'in_rack'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SharedVehicleProperties
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof SharedVehicleProperties
     */
    'location_note'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SharedVehicleProperties
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SharedVehicleProperties
     */
    'res_url': string;
    /**
     * 
     * @type {SharedVehicleCompany}
     * @memberof SharedVehicleProperties
     */
    'company'?: SharedVehicleCompany;
    /**
     * 
     * @type {number}
     * @memberof SharedVehicleProperties
     */
    'estimated_trip_length_in_km'?: number;
    /**
     * 
     * @type {SharedVehicleType}
     * @memberof SharedVehicleProperties
     */
    'type'?: SharedVehicleType;
    /**
     * 
     * @type {string}
     * @memberof SharedVehicleProperties
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface SharedVehicleType
 */
export interface SharedVehicleType {
    /**
     * 
     * @type {number}
     * @memberof SharedVehicleType
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SharedVehicleType
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface TrafficRestrictionsPublication
 */
export interface TrafficRestrictionsPublication {
    /**
     * 
     * @type {string}
     * @memberof TrafficRestrictionsPublication
     */
    'modelBaseVersion'?: string;
    /**
     * 
     * @type {TrafficRestrictionsPublicationSituationPublicationLight}
     * @memberof TrafficRestrictionsPublication
     */
    'situationPublicationLight'?: TrafficRestrictionsPublicationSituationPublicationLight;
}
/**
 * 
 * @export
 * @interface TrafficRestrictionsPublicationSituationPublicationLight
 */
export interface TrafficRestrictionsPublicationSituationPublicationLight {
    /**
     * 
     * @type {string}
     * @memberof TrafficRestrictionsPublicationSituationPublicationLight
     */
    'lang'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrafficRestrictionsPublicationSituationPublicationLight
     */
    'publicationTime'?: string;
    /**
     * 
     * @type {TrafficRestrictionsPublicationSituationPublicationLightPublicationCreator}
     * @memberof TrafficRestrictionsPublicationSituationPublicationLight
     */
    'publicationCreator'?: TrafficRestrictionsPublicationSituationPublicationLightPublicationCreator;
    /**
     * 
     * @type {Array<TrafficRestrictionsSituation>}
     * @memberof TrafficRestrictionsPublicationSituationPublicationLight
     */
    'situation'?: Array<TrafficRestrictionsSituation>;
}
/**
 * 
 * @export
 * @interface TrafficRestrictionsPublicationSituationPublicationLightPublicationCreator
 */
export interface TrafficRestrictionsPublicationSituationPublicationLightPublicationCreator {
    /**
     * 
     * @type {string}
     * @memberof TrafficRestrictionsPublicationSituationPublicationLightPublicationCreator
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrafficRestrictionsPublicationSituationPublicationLightPublicationCreator
     */
    'nationalIdentifier'?: string;
}
/**
 * 
 * @export
 * @interface TrafficRestrictionsSituation
 */
export interface TrafficRestrictionsSituation {
    /**
     * 
     * @type {string}
     * @memberof TrafficRestrictionsSituation
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof TrafficRestrictionsSituation
     */
    'version'?: number;
    /**
     * 
     * @type {Array<TrafficRestrictionsSituationRecord>}
     * @memberof TrafficRestrictionsSituation
     */
    'situationRecord'?: Array<TrafficRestrictionsSituationRecord>;
}
/**
 * 
 * @export
 * @interface TrafficRestrictionsSituationRecord
 */
export interface TrafficRestrictionsSituationRecord {
    /**
     * 
     * @type {string}
     * @memberof TrafficRestrictionsSituationRecord
     */
    'situationRecordCreationTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrafficRestrictionsSituationRecord
     */
    'situationRecordVersionTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrafficRestrictionsSituationRecord
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrafficRestrictionsSituationRecord
     */
    'endTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrafficRestrictionsSituationRecord
     */
    'type'?: string;
    /**
     * 
     * @type {number}
     * @memberof TrafficRestrictionsSituationRecord
     */
    'version'?: number;
    /**
     * 
     * @type {TrafficRestrictionsSituationRecordGeneralPublicComment}
     * @memberof TrafficRestrictionsSituationRecord
     */
    'generalPublicComment'?: TrafficRestrictionsSituationRecordGeneralPublicComment;
    /**
     * 
     * @type {string}
     * @memberof TrafficRestrictionsSituationRecord
     */
    'sourceName'?: string;
    /**
     * 
     * @type {TrafficRestrictionsSituationRecordImpact}
     * @memberof TrafficRestrictionsSituationRecord
     */
    'impact'?: TrafficRestrictionsSituationRecordImpact;
    /**
     * 
     * @type {TrafficRestrictionsSituationRecordForVehiclesWithCharacteristicsOf}
     * @memberof TrafficRestrictionsSituationRecord
     */
    'forVehiclesWithCharacteristicsOf'?: TrafficRestrictionsSituationRecordForVehiclesWithCharacteristicsOf;
    /**
     * 
     * @type {TrafficRestrictionsSituationRecordAlertCLinear}
     * @memberof TrafficRestrictionsSituationRecord
     */
    'alertCLinear'?: TrafficRestrictionsSituationRecordAlertCLinear;
    /**
     * 
     * @type {Array<Array<number>>}
     * @memberof TrafficRestrictionsSituationRecord
     */
    'osmPath'?: Array<Array<number>> | null;
}
/**
 * 
 * @export
 * @interface TrafficRestrictionsSituationRecordAlertCLinear
 */
export interface TrafficRestrictionsSituationRecordAlertCLinear {
    /**
     * 
     * @type {string}
     * @memberof TrafficRestrictionsSituationRecordAlertCLinear
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrafficRestrictionsSituationRecordAlertCLinear
     */
    'alertCLocationCountryCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrafficRestrictionsSituationRecordAlertCLinear
     */
    'alertCLocationTableNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrafficRestrictionsSituationRecordAlertCLinear
     */
    'alertCLocationTableVersion'?: string | null;
    /**
     * 
     * @type {TrafficRestrictionsSituationRecordAlertCLinearAlertCDirection}
     * @memberof TrafficRestrictionsSituationRecordAlertCLinear
     */
    'alertCDirection'?: TrafficRestrictionsSituationRecordAlertCLinearAlertCDirection;
    /**
     * 
     * @type {TrafficRestrictionsSituationRecordAlertCLinearAlertCMethod2PrimaryPointLocation}
     * @memberof TrafficRestrictionsSituationRecordAlertCLinear
     */
    'alertCMethod2PrimaryPointLocation'?: TrafficRestrictionsSituationRecordAlertCLinearAlertCMethod2PrimaryPointLocation;
    /**
     * 
     * @type {TrafficRestrictionsSituationRecordAlertCLinearAlertCMethod2PrimaryPointLocation}
     * @memberof TrafficRestrictionsSituationRecordAlertCLinear
     */
    'alertCMethod2SecondaryPointLocation'?: TrafficRestrictionsSituationRecordAlertCLinearAlertCMethod2PrimaryPointLocation;
}
/**
 * 
 * @export
 * @interface TrafficRestrictionsSituationRecordAlertCLinearAlertCDirection
 */
export interface TrafficRestrictionsSituationRecordAlertCLinearAlertCDirection {
    /**
     * 
     * @type {string}
     * @memberof TrafficRestrictionsSituationRecordAlertCLinearAlertCDirection
     */
    'alertCDirectionCoded'?: string | null;
}
/**
 * 
 * @export
 * @interface TrafficRestrictionsSituationRecordAlertCLinearAlertCMethod2PrimaryPointLocation
 */
export interface TrafficRestrictionsSituationRecordAlertCLinearAlertCMethod2PrimaryPointLocation {
    /**
     * 
     * @type {TrafficRestrictionsSituationRecordAlertCLinearAlertCMethod2PrimaryPointLocationAlertCLocation}
     * @memberof TrafficRestrictionsSituationRecordAlertCLinearAlertCMethod2PrimaryPointLocation
     */
    'alertCLocation'?: TrafficRestrictionsSituationRecordAlertCLinearAlertCMethod2PrimaryPointLocationAlertCLocation;
}
/**
 * 
 * @export
 * @interface TrafficRestrictionsSituationRecordAlertCLinearAlertCMethod2PrimaryPointLocationAlertCLocation
 */
export interface TrafficRestrictionsSituationRecordAlertCLinearAlertCMethod2PrimaryPointLocationAlertCLocation {
    /**
     * 
     * @type {string}
     * @memberof TrafficRestrictionsSituationRecordAlertCLinearAlertCMethod2PrimaryPointLocationAlertCLocation
     */
    'specificLocation'?: string;
}
/**
 * @type TrafficRestrictionsSituationRecordForVehiclesWithCharacteristicsOf
 * @export
 */
export type TrafficRestrictionsSituationRecordForVehiclesWithCharacteristicsOf = Array<object> | object;
/**
 * 
 * @export
 * @interface TrafficRestrictionsSituationRecordGeneralPublicComment
 */
export interface TrafficRestrictionsSituationRecordGeneralPublicComment {
    /**
     * 
     * @type {string}
     * @memberof TrafficRestrictionsSituationRecordGeneralPublicComment
     */
    'cs'?: string;
}
/**
 * 
 * @export
 * @interface TrafficRestrictionsSituationRecordImpact
 */
export interface TrafficRestrictionsSituationRecordImpact {
    /**
     * 
     * @type {TrafficRestrictionsSituationRecordImpactDelays}
     * @memberof TrafficRestrictionsSituationRecordImpact
     */
    'delays'?: TrafficRestrictionsSituationRecordImpactDelays;
    /**
     * 
     * @type {number}
     * @memberof TrafficRestrictionsSituationRecordImpact
     */
    'numberOfLanesRestricted'?: number;
    /**
     * 
     * @type {number}
     * @memberof TrafficRestrictionsSituationRecordImpact
     */
    'numberOfOperationalLanes'?: number;
    /**
     * 
     * @type {string}
     * @memberof TrafficRestrictionsSituationRecordImpact
     */
    'trafficConstructionType'?: string;
    /**
     * 
     * @type {number}
     * @memberof TrafficRestrictionsSituationRecordImpact
     */
    'capacityRemaining'?: number | null;
}
/**
 * 
 * @export
 * @interface TrafficRestrictionsSituationRecordImpactDelays
 */
export interface TrafficRestrictionsSituationRecordImpactDelays {
    /**
     * 
     * @type {string}
     * @memberof TrafficRestrictionsSituationRecordImpactDelays
     */
    'type'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TrafficRestrictionsSituationRecordImpactDelays
     */
    'timeValue'?: number | null;
}
/**
 * 
 * @export
 * @interface V1ParkingsGet200Response
 */
export interface V1ParkingsGet200Response {
    /**
     * 
     * @type {Array<ParkingLotFeature>}
     * @memberof V1ParkingsGet200Response
     */
    'features'?: Array<ParkingLotFeature>;
    /**
     * 
     * @type {string}
     * @memberof V1ParkingsGet200Response
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface V2AirqualitystationsGet200Response
 */
export interface V2AirqualitystationsGet200Response {
    /**
     * 
     * @type {string}
     * @memberof V2AirqualitystationsGet200Response
     */
    'type': string;
    /**
     * 
     * @type {Array<FeaturePoint>}
     * @memberof V2AirqualitystationsGet200Response
     */
    'features'?: Array<FeaturePoint>;
}
/**
 * 
 * @export
 * @interface V2BicyclecountersGet200Response
 */
export interface V2BicyclecountersGet200Response {
    /**
     * 
     * @type {string}
     * @memberof V2BicyclecountersGet200Response
     */
    'type': string;
    /**
     * 
     * @type {Array<FeaturePoint1>}
     * @memberof V2BicyclecountersGet200Response
     */
    'features'?: Array<FeaturePoint1>;
}
/**
 * 
 * @export
 * @interface V2CitydistrictsGet200Response
 */
export interface V2CitydistrictsGet200Response {
    /**
     * 
     * @type {Array<CityDistrictFeature>}
     * @memberof V2CitydistrictsGet200Response
     */
    'features': Array<CityDistrictFeature>;
    /**
     * 
     * @type {string}
     * @memberof V2CitydistrictsGet200Response
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface V2CitydistrictsGet403Response
 */
export interface V2CitydistrictsGet403Response {
    /**
     * 
     * @type {string}
     * @memberof V2CitydistrictsGet403Response
     */
    'error_message': string;
    /**
     * 
     * @type {number}
     * @memberof V2CitydistrictsGet403Response
     */
    'error_status': number;
}
/**
 * 
 * @export
 * @interface V2EnergeticsDevicesDeviceIdGet404Response
 */
export interface V2EnergeticsDevicesDeviceIdGet404Response {
    /**
     * 
     * @type {string}
     * @memberof V2EnergeticsDevicesDeviceIdGet404Response
     */
    'error_message'?: string;
    /**
     * 
     * @type {number}
     * @memberof V2EnergeticsDevicesDeviceIdGet404Response
     */
    'error_status'?: number;
    /**
     * 
     * @type {string}
     * @memberof V2EnergeticsDevicesDeviceIdGet404Response
     */
    'error_info'?: string;
}
/**
 * 
 * @export
 * @interface V2EnergeticsDevicesGet401Response
 */
export interface V2EnergeticsDevicesGet401Response {
    /**
     * 
     * @type {string}
     * @memberof V2EnergeticsDevicesGet401Response
     */
    'error_message'?: string;
    /**
     * 
     * @type {number}
     * @memberof V2EnergeticsDevicesGet401Response
     */
    'error_status'?: number;
    /**
     * 
     * @type {string}
     * @memberof V2EnergeticsDevicesGet401Response
     */
    'error_info'?: string;
}
/**
 * 
 * @export
 * @interface V2EnergeticsDevicesGet500Response
 */
export interface V2EnergeticsDevicesGet500Response {
    /**
     * 
     * @type {string}
     * @memberof V2EnergeticsDevicesGet500Response
     */
    'error_message'?: string;
    /**
     * 
     * @type {number}
     * @memberof V2EnergeticsDevicesGet500Response
     */
    'error_status'?: number;
    /**
     * 
     * @type {string}
     * @memberof V2EnergeticsDevicesGet500Response
     */
    'error_info'?: string;
}
/**
 * 
 * @export
 * @interface V2EnergeticsOrganizationsGet200Response
 */
export interface V2EnergeticsOrganizationsGet200Response {
}
/**
 * 
 * @export
 * @interface V2EnergeticsOrganizationsOrganizationIdGet400Response
 */
export interface V2EnergeticsOrganizationsOrganizationIdGet400Response {
    /**
     * 
     * @type {string}
     * @memberof V2EnergeticsOrganizationsOrganizationIdGet400Response
     */
    'error_message'?: string;
    /**
     * 
     * @type {number}
     * @memberof V2EnergeticsOrganizationsOrganizationIdGet400Response
     */
    'error_status'?: number;
    /**
     * 
     * @type {string}
     * @memberof V2EnergeticsOrganizationsOrganizationIdGet400Response
     */
    'error_info'?: string;
}
/**
 * 
 * @export
 * @interface V2ParkingGet200Response
 */
export interface V2ParkingGet200Response {
    /**
     * 
     * @type {Array<ParkingSpaceFeature>}
     * @memberof V2ParkingGet200Response
     */
    'features'?: Array<ParkingSpaceFeature>;
    /**
     * 
     * @type {string}
     * @memberof V2ParkingGet200Response
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface V2VehiclesharingMvtsFreeVehicleStatusGet200Response
 */
export interface V2VehiclesharingMvtsFreeVehicleStatusGet200Response {
    /**
     * 
     * @type {V2VehiclesharingMvtsFreeVehicleStatusGet200ResponseLayers}
     * @memberof V2VehiclesharingMvtsFreeVehicleStatusGet200Response
     */
    'layers'?: V2VehiclesharingMvtsFreeVehicleStatusGet200ResponseLayers;
}
/**
 * 
 * @export
 * @interface V2VehiclesharingMvtsFreeVehicleStatusGet200ResponseLayers
 */
export interface V2VehiclesharingMvtsFreeVehicleStatusGet200ResponseLayers {
    /**
     * 
     * @type {FreeVehicleStatusMVTS}
     * @memberof V2VehiclesharingMvtsFreeVehicleStatusGet200ResponseLayers
     */
    'free_vehicle_status'?: FreeVehicleStatusMVTS;
}
/**
 * 
 * @export
 * @interface V2VehiclesharingMvtsFreeVehicleStatusGet400Response
 */
export interface V2VehiclesharingMvtsFreeVehicleStatusGet400Response {
    /**
     * 
     * @type {string}
     * @memberof V2VehiclesharingMvtsFreeVehicleStatusGet400Response
     */
    'error_message': string;
    /**
     * 
     * @type {number}
     * @memberof V2VehiclesharingMvtsFreeVehicleStatusGet400Response
     */
    'error_status': number;
    /**
     * 
     * @type {string}
     * @memberof V2VehiclesharingMvtsFreeVehicleStatusGet400Response
     */
    'error_info'?: string | null;
}
/**
 * 
 * @export
 * @interface V3ParkingGet200Response
 */
export interface V3ParkingGet200Response {
    /**
     * 
     * @type {Array<Parking>}
     * @memberof V3ParkingGet200Response
     */
    'features'?: Array<Parking>;
    /**
     * 
     * @type {string}
     * @memberof V3ParkingGet200Response
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface V3ParkingMachinesGet200Response
 */
export interface V3ParkingMachinesGet200Response {
    /**
     * 
     * @type {Array<ParkingMachine>}
     * @memberof V3ParkingMachinesGet200Response
     */
    'features'?: Array<ParkingMachine>;
    /**
     * 
     * @type {string}
     * @memberof V3ParkingMachinesGet200Response
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface WasteCollectionMeasurement
 */
export interface WasteCollectionMeasurement {
    /**
     * container id
     * @type {string}
     * @memberof WasteCollectionMeasurement
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionMeasurement
     */
    'sensor_code': string;
    /**
     * 
     * @type {number}
     * @memberof WasteCollectionMeasurement
     */
    'percent_calculated': number;
    /**
     * 
     * @type {number}
     * @memberof WasteCollectionMeasurement
     */
    'upturned'?: number;
    /**
     * 
     * @type {number}
     * @memberof WasteCollectionMeasurement
     */
    'temperature'?: number;
    /**
     * 
     * @type {number}
     * @memberof WasteCollectionMeasurement
     */
    'battery_status'?: number;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionMeasurement
     */
    'measured_at_utc': string;
    /**
     * vendor prediction of maximum fullness
     * @type {string}
     * @memberof WasteCollectionMeasurement
     */
    'prediction_utc'?: string;
    /**
     * 
     * @type {number}
     * @memberof WasteCollectionMeasurement
     */
    'firealarm'?: number;
    /**
     * 
     * @type {number}
     * @memberof WasteCollectionMeasurement
     */
    'updated_at'?: number;
}
/**
 * 
 * @export
 * @interface WasteCollectionPick
 */
export interface WasteCollectionPick {
    /**
     * container id
     * @type {string}
     * @memberof WasteCollectionPick
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof WasteCollectionPick
     */
    'pick_minfilllevel'?: number;
    /**
     * 
     * @type {number}
     * @memberof WasteCollectionPick
     */
    'decrease'?: number;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionPick
     */
    'sensor_code': string;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionPick
     */
    'pick_at_utc': string;
    /**
     * 
     * @type {number}
     * @memberof WasteCollectionPick
     */
    'percent_before'?: number;
    /**
     * 
     * @type {number}
     * @memberof WasteCollectionPick
     */
    'percent_now'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof WasteCollectionPick
     */
    'event_driven'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof WasteCollectionPick
     */
    'updated_at'?: number;
}
/**
 * 
 * @export
 * @interface WasteCollectionPickDay
 */
export interface WasteCollectionPickDay {
    /**
     * 
     * @type {number}
     * @memberof WasteCollectionPickDay
     */
    'ksnko_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionPickDay
     */
    'sensoneo_code'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WasteCollectionPickDay
     */
    'generated_dates'?: Array<string>;
}
/**
 * 
 * @export
 * @interface WasteCollectionStation
 */
export interface WasteCollectionStation {
    /**
     * 
     * @type {WasteCollectionStationAccessibility}
     * @memberof WasteCollectionStation
     */
    'accessibility'?: WasteCollectionStationAccessibility;
    /**
     * 
     * @type {Array<WasteCollectionStationContainer>}
     * @memberof WasteCollectionStation
     */
    'containers'?: Array<WasteCollectionStationContainer>;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionStation
     */
    'district'?: string;
    /**
     * station id
     * @type {string}
     * @memberof WasteCollectionStation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionStation
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionStation
     */
    'station_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionStation
     */
    'updated_at'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WasteCollectionStation
     */
    'is_monitored'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof WasteCollectionStation
     */
    'ksnko_id'?: number;
}
/**
 * 
 * @export
 * @interface WasteCollectionStationAccessibility
 */
export interface WasteCollectionStationAccessibility {
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionStationAccessibility
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof WasteCollectionStationAccessibility
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface WasteCollectionStationContainer
 */
export interface WasteCollectionStationContainer {
    /**
     * 
     * @type {WasteCollectionStationContainerCleaningFrequency}
     * @memberof WasteCollectionStationContainer
     */
    'cleaning_frequency'?: WasteCollectionStationContainerCleaningFrequency;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionStationContainer
     */
    'container_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionStationContainer
     */
    'description'?: string;
    /**
     * 
     * @type {WasteCollectionStationContainerTrashType}
     * @memberof WasteCollectionStationContainer
     */
    'trash_type'?: WasteCollectionStationContainerTrashType;
    /**
     * 
     * @type {WasteCollectionStationContainerLastMeasurement}
     * @memberof WasteCollectionStationContainer
     */
    'last_measurement'?: WasteCollectionStationContainerLastMeasurement;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionStationContainer
     */
    'last_pick'?: string;
    /**
     * 
     * @type {number}
     * @memberof WasteCollectionStationContainer
     */
    'ksnko_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionStationContainer
     */
    'container_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionStationContainer
     */
    'sensor_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionStationContainer
     */
    'sensor_supplier'?: string;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionStationContainer
     */
    'sensor_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WasteCollectionStationContainer
     */
    'is_monitored'?: boolean;
}
/**
 * 
 * @export
 * @interface WasteCollectionStationContainerCleaningFrequency
 */
export interface WasteCollectionStationContainerCleaningFrequency {
    /**
     * 
     * @type {number}
     * @memberof WasteCollectionStationContainerCleaningFrequency
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionStationContainerCleaningFrequency
     */
    'duration'?: string;
    /**
     * 
     * @type {number}
     * @memberof WasteCollectionStationContainerCleaningFrequency
     */
    'frequency'?: number;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionStationContainerCleaningFrequency
     */
    'pick_days'?: string;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionStationContainerCleaningFrequency
     */
    'next_pick'?: string;
}
/**
 * 
 * @export
 * @interface WasteCollectionStationContainerLastMeasurement
 */
export interface WasteCollectionStationContainerLastMeasurement {
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionStationContainerLastMeasurement
     */
    'measured_at_utc'?: string;
    /**
     * 
     * @type {number}
     * @memberof WasteCollectionStationContainerLastMeasurement
     */
    'percent_calculated'?: number;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionStationContainerLastMeasurement
     */
    'prediction_utc'?: string;
}
/**
 * 
 * @export
 * @interface WasteCollectionStationContainerTrashType
 */
export interface WasteCollectionStationContainerTrashType {
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionStationContainerTrashType
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof WasteCollectionStationContainerTrashType
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface WasteCollectionStationFeature
 */
export interface WasteCollectionStationFeature {
    /**
     * 
     * @type {WasteCollectionStationFeatureGeometry}
     * @memberof WasteCollectionStationFeature
     */
    'geometry'?: WasteCollectionStationFeatureGeometry;
    /**
     * 
     * @type {WasteCollectionStation}
     * @memberof WasteCollectionStationFeature
     */
    'properties'?: WasteCollectionStation;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionStationFeature
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface WasteCollectionStationFeatureCollection
 */
export interface WasteCollectionStationFeatureCollection {
    /**
     * 
     * @type {Array<WasteCollectionStationFeature>}
     * @memberof WasteCollectionStationFeatureCollection
     */
    'features'?: Array<WasteCollectionStationFeature>;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionStationFeatureCollection
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface WasteCollectionStationFeatureGeometry
 */
export interface WasteCollectionStationFeatureGeometry {
    /**
     * 
     * @type {Array<number>}
     * @memberof WasteCollectionStationFeatureGeometry
     */
    'coordinates'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionStationFeatureGeometry
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface WasteCollectionYard
 */
export interface WasteCollectionYard {
    /**
     * 
     * @type {GardenGeometry}
     * @memberof WasteCollectionYard
     */
    'geometry'?: GardenGeometry;
    /**
     * 
     * @type {WasteCollectionYardProperties}
     * @memberof WasteCollectionYard
     */
    'properties'?: WasteCollectionYardProperties;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionYard
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface WasteCollectionYardFeatureProperty
 */
export interface WasteCollectionYardFeatureProperty {
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionYardFeatureProperty
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionYardFeatureProperty
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionYardFeatureProperty
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface WasteCollectionYardProperties
 */
export interface WasteCollectionYardProperties {
    /**
     * 
     * @type {Array<WasteCollectionYardFeatureProperty>}
     * @memberof WasteCollectionYardProperties
     */
    'properties'?: Array<WasteCollectionYardFeatureProperty>;
    /**
     * 
     * @type {MedicalInstitutionPropertiesAddress}
     * @memberof WasteCollectionYardProperties
     */
    'address'?: MedicalInstitutionPropertiesAddress;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionYardProperties
     */
    'contact'?: string;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionYardProperties
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionYardProperties
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionYardProperties
     */
    'operating_hours'?: string;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionYardProperties
     */
    'operator'?: string;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionYardProperties
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionYardProperties
     */
    'type'?: string;
    /**
     * identification code of yard
     * @type {string}
     * @memberof WasteCollectionYardProperties
     */
    'icz'?: string;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionYardProperties
     */
    'district'?: string;
}
/**
 * 
 * @export
 * @interface WasteCollectionYardProperty
 */
export interface WasteCollectionYardProperty {
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionYardProperty
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionYardProperty
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof WasteCollectionYardProperty
     */
    'value'?: string;
}









/**
 * Query parameters for v2AirqualitystationsGet operation in AirQualityV2Api.
 * @export
 * @interface AirQualityV2ApiV2AirqualitystationsGetQueryParams
 */
export interface AirQualityV2ApiV2AirqualitystationsGetQueryParams {
    //latlng
    /**
     * Sorting by location (Latitude and Longitude separated by comma, latitude first).
     * @type {string}
     * @memberof AirQualityV2ApiV2AirqualitystationsGet
     */
    latlng?: string

    //range
    /**
     * Filter by distance from latlng in meters (range query). Depends on the latlng parameter.
     * @type {number}
     * @memberof AirQualityV2ApiV2AirqualitystationsGet
     */
    range?: number

    //districts
    /**
     * Filter by Prague city districts (slug) separated by comma.
     * @type {Array<string>}
     * @memberof AirQualityV2ApiV2AirqualitystationsGet
     */
    districts?: Array<string>

    //limit
    /**
     * Limits number of retrieved items. The maximum is 10000 (default value).
     * @type {number}
     * @memberof AirQualityV2ApiV2AirqualitystationsGet
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped.
     * @type {number}
     * @memberof AirQualityV2ApiV2AirqualitystationsGet
     */
    offset?: number

    //updatedSince
    /**
     * Filters all results with older updated_at than this parameter
     * @type {string}
     * @memberof AirQualityV2ApiV2AirqualitystationsGet
     */
    updatedSince?: string
}





/**
 * Query parameters for v2AirqualitystationsHistoryGet operation in AirQualityV2Api.
 * @export
 * @interface AirQualityV2ApiV2AirqualitystationsHistoryGetQueryParams
 */
export interface AirQualityV2ApiV2AirqualitystationsHistoryGetQueryParams {
    //limit
    /**
     * Limits number of retrieved items. The maximum is 10000 (default value).
     * @type {number}
     * @memberof AirQualityV2ApiV2AirqualitystationsHistoryGet
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped.
     * @type {number}
     * @memberof AirQualityV2ApiV2AirqualitystationsHistoryGet
     */
    offset?: number

    //from
    /**
     * Date in ISO8601, limits data measured from this datetime. Defaults to 1 day ago.
     * @type {string}
     * @memberof AirQualityV2ApiV2AirqualitystationsHistoryGet
     */
    from?: string

    //to
    /**
     * Date in ISO8601, limits data measured up until this datetime. Defaults to now.
     * @type {string}
     * @memberof AirQualityV2ApiV2AirqualitystationsHistoryGet
     */
    to?: string

    //sensorId
    /**
     * Limits data measured up by sensor with this id
     * @type {string}
     * @memberof AirQualityV2ApiV2AirqualitystationsHistoryGet
     */
    sensorId?: string
}








/**
 * AirQualityV2Api - object-oriented interface
 * @export
 * @class AirQualityV2Api
 * @extends {BaseAPI}
 */
export class AirQualityV2Api extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 
     * @summary GET Air Quality Station Component Types

     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AirQualityV2Api
     */
    
    public async v2AirqualitystationsComponenttypesGet(
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/airqualitystations/componenttypes`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<AirQualityStationComponentType>>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET All Air Quality CHMI Stations

     * @param {AirQualityV2ApiV2AirqualitystationsGetQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AirQualityV2Api
     */
    
    public async v2AirqualitystationsGet(
        queryParams: AirQualityV2ApiV2AirqualitystationsGetQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/airqualitystations`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.latlng !== undefined) {
            requestQueryParameter['latlng'] = queryParams.latlng;
        }

        if (queryParams.range !== undefined) {
            requestQueryParameter['range'] = queryParams.range;
        }

        if (queryParams.districts) {
            requestQueryParameter['districts'] = queryParams.districts.join(COLLECTION_FORMATS.csv);
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }

        if (queryParams.updatedSince !== undefined) {
            requestQueryParameter['updatedSince'] = queryParams.updatedSince;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<V2AirqualitystationsGet200Response>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET Air Quality Stations CHMI History

     * @param {AirQualityV2ApiV2AirqualitystationsHistoryGetQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AirQualityV2Api
     */
    
    public async v2AirqualitystationsHistoryGet(
        queryParams: AirQualityV2ApiV2AirqualitystationsHistoryGetQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/airqualitystations/history`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }

        if (queryParams.from !== undefined) {
            requestQueryParameter['from'] = queryParams.from;
        }

        if (queryParams.to !== undefined) {
            requestQueryParameter['to'] = queryParams.to;
        }

        if (queryParams.sensorId !== undefined) {
            requestQueryParameter['sensorId'] = queryParams.sensorId;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<AirQualityStationHistory>>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET Air Quality Station Index Types

     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AirQualityV2Api
     */
    
    public async v2AirqualitystationsIndextypesGet(
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/airqualitystations/indextypes`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<AirQualityStationIndexType>>(axiosRequestConfig);
    }
}





/**
 * Query parameters for v2BicyclecountersDetectionsGet operation in BicycleCountersV2Api.
 * @export
 * @interface BicycleCountersV2ApiV2BicyclecountersDetectionsGetQueryParams
 */
export interface BicycleCountersV2ApiV2BicyclecountersDetectionsGetQueryParams {
    //limit
    /**
     * Limits number of retrieved items. The maximum is 10000 (default value).
     * @type {number}
     * @memberof BicycleCountersV2ApiV2BicyclecountersDetectionsGet
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped.
     * @type {number}
     * @memberof BicycleCountersV2ApiV2BicyclecountersDetectionsGet
     */
    offset?: number

    //from
    /**
     * Date in ISO8601, limits data measured from this datetime
     * @type {string}
     * @memberof BicycleCountersV2ApiV2BicyclecountersDetectionsGet
     */
    from?: string

    //to
    /**
     * Date in ISO8601, limits data measured up until this datetime
     * @type {string}
     * @memberof BicycleCountersV2ApiV2BicyclecountersDetectionsGet
     */
    to?: string

    //aggregate
    /**
     * sum aggregated by directions_id is returned
     * @type {boolean}
     * @memberof BicycleCountersV2ApiV2BicyclecountersDetectionsGet
     */
    aggregate?: boolean

    //id
    /**
     * direction ids
     * @type {string}
     * @memberof BicycleCountersV2ApiV2BicyclecountersDetectionsGet
     */
    id?: string
}


/**
 * Header parameters for v2BicyclecountersDetectionsGet operation in BicycleCountersV2Api.
 * @export
 * @interface BicycleCountersV2ApiV2BicyclecountersDetectionsGetHeaderParams
 */
export interface BicycleCountersV2ApiV2BicyclecountersDetectionsGetHeaderParams {
    /**
     * e.g. YOUR_ACCESS_TOKEN
     * @type {string}
     * @memberof BicycleCountersV2ApiV2BicyclecountersDetectionsGet
     */
    xAccessToken?: string
}




/**
 * Query parameters for v2BicyclecountersGet operation in BicycleCountersV2Api.
 * @export
 * @interface BicycleCountersV2ApiV2BicyclecountersGetQueryParams
 */
export interface BicycleCountersV2ApiV2BicyclecountersGetQueryParams {
    //latlng
    /**
     * Sorting by location (Latitude and Longitude separated by comma, latitude first).
     * @type {string}
     * @memberof BicycleCountersV2ApiV2BicyclecountersGet
     */
    latlng?: string

    //range
    /**
     * Filter by distance from latlng in meters (range query). Depends on the latlng parameter.
     * @type {number}
     * @memberof BicycleCountersV2ApiV2BicyclecountersGet
     */
    range?: number

    //limit
    /**
     * Limits number of retrieved items. The maximum is 10000 (default value).
     * @type {number}
     * @memberof BicycleCountersV2ApiV2BicyclecountersGet
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped.
     * @type {number}
     * @memberof BicycleCountersV2ApiV2BicyclecountersGet
     */
    offset?: number
}


/**
 * Header parameters for v2BicyclecountersGet operation in BicycleCountersV2Api.
 * @export
 * @interface BicycleCountersV2ApiV2BicyclecountersGetHeaderParams
 */
export interface BicycleCountersV2ApiV2BicyclecountersGetHeaderParams {
    /**
     * e.g. YOUR_ACCESS_TOKEN
     * @type {string}
     * @memberof BicycleCountersV2ApiV2BicyclecountersGet
     */
    xAccessToken?: string
}




/**
 * Query parameters for v2BicyclecountersTemperaturesGet operation in BicycleCountersV2Api.
 * @export
 * @interface BicycleCountersV2ApiV2BicyclecountersTemperaturesGetQueryParams
 */
export interface BicycleCountersV2ApiV2BicyclecountersTemperaturesGetQueryParams {
    //limit
    /**
     * Limits number of retrieved items. The maximum is 10000 (default value).
     * @type {number}
     * @memberof BicycleCountersV2ApiV2BicyclecountersTemperaturesGet
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped.
     * @type {number}
     * @memberof BicycleCountersV2ApiV2BicyclecountersTemperaturesGet
     */
    offset?: number

    //from
    /**
     * Date in ISO8601, limits data measured from this datetime
     * @type {string}
     * @memberof BicycleCountersV2ApiV2BicyclecountersTemperaturesGet
     */
    from?: string

    //to
    /**
     * Date in ISO8601, limits data measured up until this datetime
     * @type {string}
     * @memberof BicycleCountersV2ApiV2BicyclecountersTemperaturesGet
     */
    to?: string

    //aggregate
    /**
     * average aggregated by locations_id is returned
     * @type {boolean}
     * @memberof BicycleCountersV2ApiV2BicyclecountersTemperaturesGet
     */
    aggregate?: boolean

    //id
    /**
     * location ids
     * @type {Array<string>}
     * @memberof BicycleCountersV2ApiV2BicyclecountersTemperaturesGet
     */
    id?: Array<string>
}


/**
 * Header parameters for v2BicyclecountersTemperaturesGet operation in BicycleCountersV2Api.
 * @export
 * @interface BicycleCountersV2ApiV2BicyclecountersTemperaturesGetHeaderParams
 */
export interface BicycleCountersV2ApiV2BicyclecountersTemperaturesGetHeaderParams {
    /**
     * e.g. YOUR_ACCESS_TOKEN
     * @type {string}
     * @memberof BicycleCountersV2ApiV2BicyclecountersTemperaturesGet
     */
    xAccessToken?: string
}



/**
 * BicycleCountersV2Api - object-oriented interface
 * @export
 * @class BicycleCountersV2Api
 * @extends {BaseAPI}
 */
export class BicycleCountersV2Api extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 
     * @summary GET Bicycle Counters Detections

     * @param {BicycleCountersV2ApiV2BicyclecountersDetectionsGetQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BicycleCountersV2Api
     */
    
    public async v2BicyclecountersDetectionsGet(
        queryParams: BicycleCountersV2ApiV2BicyclecountersDetectionsGetQueryParams = {},
        headerParams: BicycleCountersV2ApiV2BicyclecountersDetectionsGetHeaderParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/bicyclecounters/detections`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }

        if (queryParams.from !== undefined) {
            requestQueryParameter['from'] = queryParams.from;
        }

        if (queryParams.to !== undefined) {
            requestQueryParameter['to'] = queryParams.to;
        }

        if (queryParams.aggregate !== undefined) {
            requestQueryParameter['aggregate'] = queryParams.aggregate;
        }

        if (queryParams.id !== undefined) {
            requestQueryParameter['id'] = queryParams.id;
        }

        if (headerParams.xAccessToken != null) {
            requestHeaderParameter['x-access-token'] = String(headerParams.xAccessToken);
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<BicycleCounterDetections>>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET All Bicycle Counters

     * @param {BicycleCountersV2ApiV2BicyclecountersGetQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BicycleCountersV2Api
     */
    
    public async v2BicyclecountersGet(
        queryParams: BicycleCountersV2ApiV2BicyclecountersGetQueryParams = {},
        headerParams: BicycleCountersV2ApiV2BicyclecountersGetHeaderParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/bicyclecounters`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.latlng !== undefined) {
            requestQueryParameter['latlng'] = queryParams.latlng;
        }

        if (queryParams.range !== undefined) {
            requestQueryParameter['range'] = queryParams.range;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }

        if (headerParams.xAccessToken != null) {
            requestHeaderParameter['x-access-token'] = String(headerParams.xAccessToken);
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<V2BicyclecountersGet200Response>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET Bicycle Counters Temperatures

     * @param {BicycleCountersV2ApiV2BicyclecountersTemperaturesGetQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BicycleCountersV2Api
     */
    
    public async v2BicyclecountersTemperaturesGet(
        queryParams: BicycleCountersV2ApiV2BicyclecountersTemperaturesGetQueryParams = {},
        headerParams: BicycleCountersV2ApiV2BicyclecountersTemperaturesGetHeaderParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/bicyclecounters/temperatures`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }

        if (queryParams.from !== undefined) {
            requestQueryParameter['from'] = queryParams.from;
        }

        if (queryParams.to !== undefined) {
            requestQueryParameter['to'] = queryParams.to;
        }

        if (queryParams.aggregate !== undefined) {
            requestQueryParameter['aggregate'] = queryParams.aggregate;
        }

        if (queryParams.id) {
            requestQueryParameter['id'] = queryParams.id;
        }

        if (headerParams.xAccessToken != null) {
            requestHeaderParameter['x-access-token'] = String(headerParams.xAccessToken);
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<BicycleCounterTemperatures>>(axiosRequestConfig);
    }
}





/**
 * Query parameters for getBWStations operation in BulkyWasteV1Api.
 * @export
 * @interface BulkyWasteV1ApiGetBWStationsQueryParams
 */
export interface BulkyWasteV1ApiGetBWStationsQueryParams {
    //latlng
    /**
     * Sorting by location (Latitude and Longitude separated by comma, latitude first)
     * @type {string}
     * @memberof BulkyWasteV1ApiGetBWStations
     */
    latlng?: string

    //range
    /**
     * Filter by distance from latlng in kilometres (default 1 km). Depends on the latlng parameter
     * @type {number}
     * @memberof BulkyWasteV1ApiGetBWStations
     */
    range?: number

    //from
    /**
     * Date in ISO8601, limits data measured from this datetime ( default before pick time to)
     * @type {string}
     * @memberof BulkyWasteV1ApiGetBWStations
     */
    from?: string

    //to
    /**
     * Date in ISO8601, limits data measured up until this datetime (default 60 days into the future)
     * @type {string}
     * @memberof BulkyWasteV1ApiGetBWStations
     */
    to?: string

    //districts
    /**
     * Filter by Prague city districts (slug) separated by comma
     * @type {string}
     * @memberof BulkyWasteV1ApiGetBWStations
     */
    districts?: string

    //limit
    /**
     * Limits number of retrieved items. The maximum is 10000 (default value)
     * @type {number}
     * @memberof BulkyWasteV1ApiGetBWStations
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped
     * @type {number}
     * @memberof BulkyWasteV1ApiGetBWStations
     */
    offset?: number
}








/**
 * BulkyWasteV1Api - object-oriented interface
 * @export
 * @class BulkyWasteV1Api
 * @extends {BaseAPI}
 */
export class BulkyWasteV1Api extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * Provides position of the bulky containers
     * @summary GET All Bulky Waste Containers

     * @param {BulkyWasteV1ApiGetBWStationsQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkyWasteV1Api
     */
    
    public async getBWStations(
        queryParams: BulkyWasteV1ApiGetBWStationsQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v1/bulky-waste/stations`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.latlng !== undefined) {
            requestQueryParameter['latlng'] = queryParams.latlng;
        }

        if (queryParams.range !== undefined) {
            requestQueryParameter['range'] = queryParams.range;
        }

        if (queryParams.from !== undefined) {
            requestQueryParameter['from'] = queryParams.from;
        }

        if (queryParams.to !== undefined) {
            requestQueryParameter['to'] = queryParams.to;
        }

        if (queryParams.districts !== undefined) {
            requestQueryParameter['districts'] = queryParams.districts;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<BulkyStationsCollection>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET Bulky Waste Station by customId

     * @param {string} customId Custom id (in form of pick_date pick_time_from ID:id)
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkyWasteV1Api
     */
    
    public async v1BulkyWasteStationsCustomIdGet(
        customId: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'customId' is not null or undefined
        assertParamExists('v1BulkyWasteStationsCustomIdGet', 'customId', customId)
        
        const localVarPath = `/v1/bulky-waste/stations/:customId`
            .replace(`{${"customId"}}`, encodeURIComponent(String(customId)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<BulkyContainer>(axiosRequestConfig);
    }
}





/**
 * Query parameters for v2EnergeticsBuildingsGet operation in EnergeticsV2Api.
 * @export
 * @interface EnergeticsV2ApiV2EnergeticsBuildingsGetQueryParams
 */
export interface EnergeticsV2ApiV2EnergeticsBuildingsGetQueryParams {
    //full
    /**
     * Display full buildings data.
     * @type {boolean}
     * @memberof EnergeticsV2ApiV2EnergeticsBuildingsGet
     */
    full?: boolean
}

















/**
 * Query parameters for v2EnergeticsMeasurementsGet operation in EnergeticsV2Api.
 * @export
 * @interface EnergeticsV2ApiV2EnergeticsMeasurementsGetQueryParams
 */
export interface EnergeticsV2ApiV2EnergeticsMeasurementsGetQueryParams {
    //variable
    /**
     * core - Kumulovan√Ω objem [m3]&lt;br /&gt; core2 - Kumulovan√Ω p≈ôepoƒç√≠tan√Ω objem [Nm3]&lt;br /&gt; EFwActi - Odbƒõr ƒçinn√© energie [kWh]&lt;br /&gt; EFwActiVT - Odbƒõr ƒçinn√© energie, vysok√Ω tarif [kVArh]&lt;br /&gt; ERvReact - Dod√°vka jalov√© energie [kVArh]&lt;br /&gt; EFwReact - Odbƒõr jalov√© energie [kVArh]&lt;br /&gt; raw - ƒå√≠seln√≠k impulz≈Ø [imp]&lt;br /&gt; RSSI - S√≠la sign√°lu [dBm]&lt;br /&gt; T - Teplota [¬∞C]&lt;br /&gt; CO2 - Koncentrace CO2 [ppm]&lt;br /&gt; RH - Relativn√≠ vlhkost [%]&lt;br /&gt; EFwActiNT - Odbƒõr ƒçinn√© energie, n√≠zk√Ω tarif [kVArh]&lt;br /&gt; VOC - M√≠ra koncentrace tƒõkav√Ωch l√°tek [%]&lt;br /&gt; VT - Vysok√Ω tarif [kWh]&lt;br /&gt; NT - N√≠zk√Ω tarif [kWh]&lt;br /&gt;
     * @type {EnergeticsVariables}
     * @memberof EnergeticsV2ApiV2EnergeticsMeasurementsGet
     */
    variable?: EnergeticsVariables

    //type
    /**
     * monthly_reading - hodnoty sƒç√≠tan√© po mƒõs√≠c√≠ch z 15 minutov√Ωch spot≈ôeb poskytovan√Ωch firmou PRE&lt;br /&gt; provider_value - data z√≠skan√° od poskytovatel≈Ø energi√≠&lt;br /&gt; dotcontrols_value - data z√≠skan√° ze syst√©m≈Ø VisApp firmy DotControls&lt;br /&gt;
     * @type {EnergeticsTypes}
     * @memberof EnergeticsV2ApiV2EnergeticsMeasurementsGet
     */
    type?: EnergeticsTypes

    //addr1
    /**
     * 
     * @type {string}
     * @memberof EnergeticsV2ApiV2EnergeticsMeasurementsGet
     */
    addr1?: string

    //addr2
    /**
     * 
     * @type {string}
     * @memberof EnergeticsV2ApiV2EnergeticsMeasurementsGet
     */
    addr2?: string

    //dateFrom
    /**
     * 
     * @type {string}
     * @memberof EnergeticsV2ApiV2EnergeticsMeasurementsGet
     */
    dateFrom?: string

    //dateTo
    /**
     * 
     * @type {string}
     * @memberof EnergeticsV2ApiV2EnergeticsMeasurementsGet
     */
    dateTo?: string

    //limit
    /**
     * Limits number of retrieved items.
     * @type {number}
     * @memberof EnergeticsV2ApiV2EnergeticsMeasurementsGet
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped.
     * @type {number}
     * @memberof EnergeticsV2ApiV2EnergeticsMeasurementsGet
     */
    offset?: number
}





/**
 * Query parameters for v2EnergeticsMeasurementsMonthlyReadingGet operation in EnergeticsV2Api.
 * @export
 * @interface EnergeticsV2ApiV2EnergeticsMeasurementsMonthlyReadingGetQueryParams
 */
export interface EnergeticsV2ApiV2EnergeticsMeasurementsMonthlyReadingGetQueryParams {
    //addr1
    /**
     * First part of device address
     * @type {string}
     * @memberof EnergeticsV2ApiV2EnergeticsMeasurementsMonthlyReadingGet
     */
    addr1: string

    //addr2
    /**
     * Second part of device address
     * @type {string}
     * @memberof EnergeticsV2ApiV2EnergeticsMeasurementsMonthlyReadingGet
     */
    addr2: string

    //variable
    /**
     * core - Kumulovan√Ω objem [m3]&lt;br /&gt; core2 - Kumulovan√Ω p≈ôepoƒç√≠tan√Ω objem [Nm3]&lt;br /&gt; EFwActi - Odbƒõr ƒçinn√© energie [kWh]&lt;br /&gt; EFwActiVT - Odbƒõr ƒçinn√© energie, vysok√Ω tarif [kVArh]&lt;br /&gt; ERvReact - Dod√°vka jalov√© energie [kVArh]&lt;br /&gt; EFwReact - Odbƒõr jalov√© energie [kVArh]&lt;br /&gt; raw - ƒå√≠seln√≠k impulz≈Ø [imp]&lt;br /&gt; RSSI - S√≠la sign√°lu [dBm]&lt;br /&gt; T - Teplota [¬∞C]&lt;br /&gt; CO2 - Koncentrace CO2 [ppm]&lt;br /&gt; RH - Relativn√≠ vlhkost [%]&lt;br /&gt; EFwActiNT - Odbƒõr ƒçinn√© energie, n√≠zk√Ω tarif [kVArh]&lt;br /&gt; VOC - M√≠ra koncentrace tƒõkav√Ωch l√°tek [%]&lt;br /&gt; VT - Vysok√Ω tarif [kWh]&lt;br /&gt; NT - N√≠zk√Ω tarif [kWh]&lt;br /&gt;
     * @type {EnergeticsVariables}
     * @memberof EnergeticsV2ApiV2EnergeticsMeasurementsMonthlyReadingGet
     */
    variable: EnergeticsVariables

    //year
    /**
     * Year of measurement
     * @type {number}
     * @memberof EnergeticsV2ApiV2EnergeticsMeasurementsMonthlyReadingGet
     */
    year: number

    //month
    /**
     * Month of measurement
     * @type {number}
     * @memberof EnergeticsV2ApiV2EnergeticsMeasurementsMonthlyReadingGet
     */
    month: number
}





/**
 * Query parameters for v2EnergeticsOrganizationsGet operation in EnergeticsV2Api.
 * @export
 * @interface EnergeticsV2ApiV2EnergeticsOrganizationsGetQueryParams
 */
export interface EnergeticsV2ApiV2EnergeticsOrganizationsGetQueryParams {
    //full
    /**
     * Display full organization data.
     * @type {boolean}
     * @memberof EnergeticsV2ApiV2EnergeticsOrganizationsGet
     */
    full?: boolean
}








/**
 * EnergeticsV2Api - object-oriented interface
 * @export
 * @class EnergeticsV2Api
 * @extends {BaseAPI}
 */
export class EnergeticsV2Api extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 
     * @summary Get all buildings

     * @param {EnergeticsV2ApiV2EnergeticsBuildingsGetQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnergeticsV2Api
     */
    
    public async v2EnergeticsBuildingsGet(
        queryParams: EnergeticsV2ApiV2EnergeticsBuildingsGetQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/energetics/buildings`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.full !== undefined) {
            requestQueryParameter['full'] = queryParams.full;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<EnergeticsBuildingShort>>(axiosRequestConfig);
    }

    /**
     * 
     * @summary Get a building by ID

     * @param {number} id 
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnergeticsV2Api
     */
    
    public async v2EnergeticsBuildingsIdGet(
        id: number,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'id' is not null or undefined
        assertParamExists('v2EnergeticsBuildingsIdGet', 'id', id)
        
        const localVarPath = `/v2/energetics/buildings/{id}`
            .replace(`{${"id"}}`, encodeURIComponent(String(id)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<EnergeticsBuildingFull>(axiosRequestConfig);
    }

    /**
     * 
     * @summary Measurement device info

     * @param {number} deviceId Id of device
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnergeticsV2Api
     */
    
    public async v2EnergeticsDevicesDeviceIdGet(
        deviceId: number,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'deviceId' is not null or undefined
        assertParamExists('v2EnergeticsDevicesDeviceIdGet', 'deviceId', deviceId)
        
        const localVarPath = `/v2/energetics/devices/{deviceId}`
            .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<EnergeticsDevice>(axiosRequestConfig);
    }

    /**
     * 
     * @summary List of measurement devices

     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnergeticsV2Api
     */
    
    public async v2EnergeticsDevicesGet(
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/energetics/devices`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<EnergeticsDevice>>(axiosRequestConfig);
    }

    /**
     * 
     * @summary Measurements

     * @param {EnergeticsV2ApiV2EnergeticsMeasurementsGetQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnergeticsV2Api
     */
    
    public async v2EnergeticsMeasurementsGet(
        queryParams: EnergeticsV2ApiV2EnergeticsMeasurementsGetQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/energetics/measurements`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.variable !== undefined) {
            requestQueryParameter['variable'] = queryParams.variable;
        }

        if (queryParams.type !== undefined) {
            requestQueryParameter['type'] = queryParams.type;
        }

        if (queryParams.addr1 !== undefined) {
            requestQueryParameter['addr1'] = queryParams.addr1;
        }

        if (queryParams.addr2 !== undefined) {
            requestQueryParameter['addr2'] = queryParams.addr2;
        }

        if (queryParams.dateFrom !== undefined) {
            requestQueryParameter['dateFrom'] = (queryParams.dateFrom as any instanceof Date) ?
                (queryParams.dateFrom as any).toISOString() :
                queryParams.dateFrom;
        }

        if (queryParams.dateTo !== undefined) {
            requestQueryParameter['dateTo'] = (queryParams.dateTo as any instanceof Date) ?
                (queryParams.dateTo as any).toISOString() :
                queryParams.dateTo;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<EnergeticsMeasurement>>(axiosRequestConfig);
    }

    /**
     * 
     * @summary Monthly sums of measurements from devices

     * @param {EnergeticsV2ApiV2EnergeticsMeasurementsMonthlyReadingGetQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnergeticsV2Api
     */
    
    public async v2EnergeticsMeasurementsMonthlyReadingGet(
        queryParams: EnergeticsV2ApiV2EnergeticsMeasurementsMonthlyReadingGetQueryParams,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'addr1' is not null or undefined
        assertParamExists('v2EnergeticsMeasurementsMonthlyReadingGet', 'addr1', queryParams.addr1)
        assertParamExists('v2EnergeticsMeasurementsMonthlyReadingGet', 'addr2', queryParams.addr2)
        assertParamExists('v2EnergeticsMeasurementsMonthlyReadingGet', 'variable', queryParams.variable)
        assertParamExists('v2EnergeticsMeasurementsMonthlyReadingGet', 'year', queryParams.year)
        assertParamExists('v2EnergeticsMeasurementsMonthlyReadingGet', 'month', queryParams.month)
        
        // verify required parameter 'addr2' is not null or undefined
        assertParamExists('v2EnergeticsMeasurementsMonthlyReadingGet', 'addr1', queryParams.addr1)
        assertParamExists('v2EnergeticsMeasurementsMonthlyReadingGet', 'addr2', queryParams.addr2)
        assertParamExists('v2EnergeticsMeasurementsMonthlyReadingGet', 'variable', queryParams.variable)
        assertParamExists('v2EnergeticsMeasurementsMonthlyReadingGet', 'year', queryParams.year)
        assertParamExists('v2EnergeticsMeasurementsMonthlyReadingGet', 'month', queryParams.month)
        
        // verify required parameter 'variable' is not null or undefined
        assertParamExists('v2EnergeticsMeasurementsMonthlyReadingGet', 'addr1', queryParams.addr1)
        assertParamExists('v2EnergeticsMeasurementsMonthlyReadingGet', 'addr2', queryParams.addr2)
        assertParamExists('v2EnergeticsMeasurementsMonthlyReadingGet', 'variable', queryParams.variable)
        assertParamExists('v2EnergeticsMeasurementsMonthlyReadingGet', 'year', queryParams.year)
        assertParamExists('v2EnergeticsMeasurementsMonthlyReadingGet', 'month', queryParams.month)
        
        // verify required parameter 'year' is not null or undefined
        assertParamExists('v2EnergeticsMeasurementsMonthlyReadingGet', 'addr1', queryParams.addr1)
        assertParamExists('v2EnergeticsMeasurementsMonthlyReadingGet', 'addr2', queryParams.addr2)
        assertParamExists('v2EnergeticsMeasurementsMonthlyReadingGet', 'variable', queryParams.variable)
        assertParamExists('v2EnergeticsMeasurementsMonthlyReadingGet', 'year', queryParams.year)
        assertParamExists('v2EnergeticsMeasurementsMonthlyReadingGet', 'month', queryParams.month)
        
        // verify required parameter 'month' is not null or undefined
        assertParamExists('v2EnergeticsMeasurementsMonthlyReadingGet', 'addr1', queryParams.addr1)
        assertParamExists('v2EnergeticsMeasurementsMonthlyReadingGet', 'addr2', queryParams.addr2)
        assertParamExists('v2EnergeticsMeasurementsMonthlyReadingGet', 'variable', queryParams.variable)
        assertParamExists('v2EnergeticsMeasurementsMonthlyReadingGet', 'year', queryParams.year)
        assertParamExists('v2EnergeticsMeasurementsMonthlyReadingGet', 'month', queryParams.month)
        
        const localVarPath = `/v2/energetics/measurements/monthly-reading`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.addr1 !== undefined) {
            requestQueryParameter['addr1'] = queryParams.addr1;
        }

        if (queryParams.addr2 !== undefined) {
            requestQueryParameter['addr2'] = queryParams.addr2;
        }

        if (queryParams.variable !== undefined) {
            requestQueryParameter['variable'] = queryParams.variable;
        }

        if (queryParams.year !== undefined) {
            requestQueryParameter['year'] = queryParams.year;
        }

        if (queryParams.month !== undefined) {
            requestQueryParameter['month'] = queryParams.month;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<EnergeticsMeasurement>>(axiosRequestConfig);
    }

    /**
     * 
     * @summary List of organizations in brief or full format

     * @param {EnergeticsV2ApiV2EnergeticsOrganizationsGetQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnergeticsV2Api
     */
    
    public async v2EnergeticsOrganizationsGet(
        queryParams: EnergeticsV2ApiV2EnergeticsOrganizationsGetQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/energetics/organizations`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.full !== undefined) {
            requestQueryParameter['full'] = queryParams.full;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<V2EnergeticsOrganizationsGet200Response>(axiosRequestConfig);
    }

    /**
     * 
     * @summary Organization detail

     * @param {number} organizationId Id of organization
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnergeticsV2Api
     */
    
    public async v2EnergeticsOrganizationsOrganizationIdGet(
        organizationId: number,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'organizationId' is not null or undefined
        assertParamExists('v2EnergeticsOrganizationsOrganizationIdGet', 'organizationId', organizationId)
        
        const localVarPath = `/v2/energetics/organizations/{organizationId}`
            .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<EnergeticsOrganizationFull>(axiosRequestConfig);
    }
}





/**
 * Query parameters for getFCD operation in FloatingCarDataV2Api.
 * @export
 * @interface FloatingCarDataV2ApiGetFCDQueryParams
 */
export interface FloatingCarDataV2ApiGetFCDQueryParams {
    //locationId
    /**
     * Filters data with Predefined Location Id.
     * @type {string}
     * @memberof FloatingCarDataV2ApiGetFCD
     */
    locationId?: string

    //osmPath
    /**
     * Includes in the output pathOsm
     * @type {boolean}
     * @memberof FloatingCarDataV2ApiGetFCD
     */
    osmPath?: boolean

    //minutesBefore
    /**
     * Lists items updated since given number of minutes, returns unique locations only
     * @type {number}
     * @memberof FloatingCarDataV2ApiGetFCD
     */
    minutesBefore?: number

    //limit
    /**
     * Limits number of retrieved items. The maximum is 10000 (default value)
     * @type {number}
     * @memberof FloatingCarDataV2ApiGetFCD
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped
     * @type {number}
     * @memberof FloatingCarDataV2ApiGetFCD
     */
    offset?: number
}




/**
 * FloatingCarDataV2Api - object-oriented interface
 * @export
 * @class FloatingCarDataV2Api
 * @extends {BaseAPI}
 */
export class FloatingCarDataV2Api extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 
     * @summary GET Latest floating Car Data

     * @param {FloatingCarDataV2ApiGetFCDQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloatingCarDataV2Api
     */
    
    public async getFCD(
        queryParams: FloatingCarDataV2ApiGetFCDQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/fcd/info`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.locationId !== undefined) {
            requestQueryParameter['locationId'] = queryParams.locationId;
        }

        if (queryParams.osmPath !== undefined) {
            requestQueryParameter['osmPath'] = queryParams.osmPath;
        }

        if (queryParams.minutesBefore !== undefined) {
            requestQueryParameter['minutesBefore'] = queryParams.minutesBefore;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<FloatingCarDataPublication>(axiosRequestConfig);
    }
}












































/**
 * GBFSV2Api - object-oriented interface
 * @export
 * @class GBFSV2Api
 * @extends {BaseAPI}
 */
export class GBFSV2Api extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 
     * @summary GET GBFS

     * @param {string} systemId Identifier of the system.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GBFSV2Api
     */
    
    public async gETGBFS(
        systemId: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'systemId' is not null or undefined
        assertParamExists('gETGBFS', 'systemId', systemId)
        
        const localVarPath = `/v2/vehiclesharing/gbfs/{system_id}/gbfs`
            .replace(`{${"system_id"}}`, encodeURIComponent(String(systemId)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<GBFSWrapper>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET GBFS Free Bike Status

     * @param {string} systemId Identifier of the system.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GBFSV2Api
     */
    
    public async gETGBFSFreeBikeStatus(
        systemId: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'systemId' is not null or undefined
        assertParamExists('gETGBFSFreeBikeStatus', 'systemId', systemId)
        
        const localVarPath = `/v2/vehiclesharing/gbfs/{system_id}/free_bike_status`
            .replace(`{${"system_id"}}`, encodeURIComponent(String(systemId)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<GBFSWrapper>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET GBFS Geofencing Zones

     * @param {string} systemId Identifier of the system.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GBFSV2Api
     */
    
    public async gETGBFSGeofencingZones(
        systemId: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'systemId' is not null or undefined
        assertParamExists('gETGBFSGeofencingZones', 'systemId', systemId)
        
        const localVarPath = `/v2/vehiclesharing/gbfs/{system_id}/geofencing_zones`
            .replace(`{${"system_id"}}`, encodeURIComponent(String(systemId)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<GBFSWrapper>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET GBFS Station Information

     * @param {string} systemId Identifier of the system.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GBFSV2Api
     */
    
    public async gETGBFSStationInformation(
        systemId: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'systemId' is not null or undefined
        assertParamExists('gETGBFSStationInformation', 'systemId', systemId)
        
        const localVarPath = `/v2/vehiclesharing/gbfs/{system_id}/station_information`
            .replace(`{${"system_id"}}`, encodeURIComponent(String(systemId)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<GBFSWrapper>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET GBFS Station Status

     * @param {string} systemId Identifier of the system.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GBFSV2Api
     */
    
    public async gETGBFSStationStatus(
        systemId: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'systemId' is not null or undefined
        assertParamExists('gETGBFSStationStatus', 'systemId', systemId)
        
        const localVarPath = `/v2/vehiclesharing/gbfs/{system_id}/station_status`
            .replace(`{${"system_id"}}`, encodeURIComponent(String(systemId)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<GBFSWrapper>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET GBFS System Information

     * @param {string} systemId Identifier of the system.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GBFSV2Api
     */
    
    public async gETGBFSSystemInformation(
        systemId: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'systemId' is not null or undefined
        assertParamExists('gETGBFSSystemInformation', 'systemId', systemId)
        
        const localVarPath = `/v2/vehiclesharing/gbfs/{system_id}/system_information`
            .replace(`{${"system_id"}}`, encodeURIComponent(String(systemId)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<GBFSWrapper>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET GBFS System Pricing Plans

     * @param {string} systemId Identifier of the system.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GBFSV2Api
     */
    
    public async gETGBFSSystemPricingPlans(
        systemId: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'systemId' is not null or undefined
        assertParamExists('gETGBFSSystemPricingPlans', 'systemId', systemId)
        
        const localVarPath = `/v2/vehiclesharing/gbfs/{system_id}/system_pricing_plans`
            .replace(`{${"system_id"}}`, encodeURIComponent(String(systemId)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<GBFSWrapper>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET GBFS Systems List

     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GBFSV2Api
     */
    
    public async gETGBFSSystemsList(
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/vehiclesharing/gbfs/systems_list`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<GBFSSystemsList>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET GBFS Vehicle Types

     * @param {string} systemId Identifier of the system.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GBFSV2Api
     */
    
    public async gETGBFSVehicleTypes(
        systemId: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'systemId' is not null or undefined
        assertParamExists('gETGBFSVehicleTypes', 'systemId', systemId)
        
        const localVarPath = `/v2/vehiclesharing/gbfs/{system_id}/vehicle_types`
            .replace(`{${"system_id"}}`, encodeURIComponent(String(systemId)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<GBFSWrapper>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET GBFS Versions

     * @param {string} systemId Identifier of the system.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GBFSV2Api
     */
    
    public async gETGBFSVersions(
        systemId: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'systemId' is not null or undefined
        assertParamExists('gETGBFSVersions', 'systemId', systemId)
        
        const localVarPath = `/v2/vehiclesharing/gbfs/{system_id}/gbfs_versions`
            .replace(`{${"system_id"}}`, encodeURIComponent(String(systemId)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<GBFSWrapper>(axiosRequestConfig);
    }
}





/**
 * Query parameters for gETAllGardens operation in GardensV2Api.
 * @export
 * @interface GardensV2ApiGETAllGardensQueryParams
 */
export interface GardensV2ApiGETAllGardensQueryParams {
    //latlng
    /**
     * Sorting by location (Latitude and Longitude separated by comma, latitude first).
     * @type {string}
     * @memberof GardensV2ApiGETAllGardens
     */
    latlng?: string

    //range
    /**
     * Filter by distance from latlng in meters (range query). Depends on the latlng parameter.
     * @type {number}
     * @memberof GardensV2ApiGETAllGardens
     */
    range?: number

    //districts
    /**
     * Filter by Prague city districts (slug) separated by comma.
     * @type {Array<any>}
     * @memberof GardensV2ApiGETAllGardens
     */
    districts?: Array<any>

    //limit
    /**
     * Limits number of retrieved items. The maximum is 10000 (default value).
     * @type {number}
     * @memberof GardensV2ApiGETAllGardens
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped.
     * @type {number}
     * @memberof GardensV2ApiGETAllGardens
     */
    offset?: number

    //updatedSince
    /**
     * Filters all results with older updated_at than this parameter
     * @type {string}
     * @memberof GardensV2ApiGETAllGardens
     */
    updatedSince?: string
}








/**
 * GardensV2Api - object-oriented interface
 * @export
 * @class GardensV2Api
 * @extends {BaseAPI}
 */
export class GardensV2Api extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 
     * @summary GET All Gardens

     * @param {GardensV2ApiGETAllGardensQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GardensV2Api
     */
    
    public async gETAllGardens(
        queryParams: GardensV2ApiGETAllGardensQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/gardens`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.latlng !== undefined) {
            requestQueryParameter['latlng'] = queryParams.latlng;
        }

        if (queryParams.range !== undefined) {
            requestQueryParameter['range'] = queryParams.range;
        }

        if (queryParams.districts) {
            requestQueryParameter['districts'] = queryParams.districts;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }

        if (queryParams.updatedSince !== undefined) {
            requestQueryParameter['updatedSince'] = queryParams.updatedSince;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<GETAllGardens200Response>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET Gardens

     * @param {string} id Identifier of the garden.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GardensV2Api
     */
    
    public async gETGardens(
        id: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'id' is not null or undefined
        assertParamExists('gETGardens', 'id', id)
        
        const localVarPath = `/v2/gardens/{id}`
            .replace(`{${"id"}}`, encodeURIComponent(String(id)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Garden>(axiosRequestConfig);
    }
}





/**
 * Query parameters for v2VehiclesharingMvtsFreeVehicleStatusGet operation in MVTSApi.
 * @export
 * @interface MVTSApiV2VehiclesharingMvtsFreeVehicleStatusGetQueryParams
 */
export interface MVTSApiV2VehiclesharingMvtsFreeVehicleStatusGetQueryParams {
    //tileX
    /**
     * Tile\&#39;s column
     * @type {number}
     * @memberof MVTSApiV2VehiclesharingMvtsFreeVehicleStatusGet
     */
    tileX: number

    //tileY
    /**
     * Tile\&#39;s row
     * @type {number}
     * @memberof MVTSApiV2VehiclesharingMvtsFreeVehicleStatusGet
     */
    tileY: number

    //zoom
    /**
     * Tile\&#39;s zoom level
     * @type {number}
     * @memberof MVTSApiV2VehiclesharingMvtsFreeVehicleStatusGet
     */
    zoom: number

    //systemId
    /**
     * Identifier for the vehicle share system.
     * @type {Array<string>}
     * @memberof MVTSApiV2VehiclesharingMvtsFreeVehicleStatusGet
     */
    systemId?: Array<string>
}




/**
 * MVTSApi - object-oriented interface
 * @export
 * @class MVTSApi
 * @extends {BaseAPI}
 */
export class MVTSApi extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * Mapbox vector tileset of free vehicles for sharing; Provides result as json or mapbox-vector-tile depending on accept header.
     * @summary GET MVTS geojson of free vehicle status

     * @param {MVTSApiV2VehiclesharingMvtsFreeVehicleStatusGetQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MVTSApi
     */
    
    public async v2VehiclesharingMvtsFreeVehicleStatusGet(
        queryParams: MVTSApiV2VehiclesharingMvtsFreeVehicleStatusGetQueryParams,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'tileX' is not null or undefined
        assertParamExists('v2VehiclesharingMvtsFreeVehicleStatusGet', 'tileX', queryParams.tileX)
        assertParamExists('v2VehiclesharingMvtsFreeVehicleStatusGet', 'tileY', queryParams.tileY)
        assertParamExists('v2VehiclesharingMvtsFreeVehicleStatusGet', 'zoom', queryParams.zoom)
        
        // verify required parameter 'tileY' is not null or undefined
        assertParamExists('v2VehiclesharingMvtsFreeVehicleStatusGet', 'tileX', queryParams.tileX)
        assertParamExists('v2VehiclesharingMvtsFreeVehicleStatusGet', 'tileY', queryParams.tileY)
        assertParamExists('v2VehiclesharingMvtsFreeVehicleStatusGet', 'zoom', queryParams.zoom)
        
        // verify required parameter 'zoom' is not null or undefined
        assertParamExists('v2VehiclesharingMvtsFreeVehicleStatusGet', 'tileX', queryParams.tileX)
        assertParamExists('v2VehiclesharingMvtsFreeVehicleStatusGet', 'tileY', queryParams.tileY)
        assertParamExists('v2VehiclesharingMvtsFreeVehicleStatusGet', 'zoom', queryParams.zoom)
        
        const localVarPath = `/v2/vehiclesharing/mvts/free_vehicle_status`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.tileX !== undefined) {
            requestQueryParameter['tileX'] = queryParams.tileX;
        }

        if (queryParams.tileY !== undefined) {
            requestQueryParameter['tileY'] = queryParams.tileY;
        }

        if (queryParams.zoom !== undefined) {
            requestQueryParameter['zoom'] = queryParams.zoom;
        }

        if (queryParams.systemId) {
            requestQueryParameter['systemId'] = queryParams.systemId;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<File>(axiosRequestConfig);
    }
}







/**
 * @export
 */
export const GETAllMedicalInstitutionsGroupEnum = {
    Pharmacies: 'pharmacies',
    HealthCare: 'health_care'
} as const;
export type GETAllMedicalInstitutionsGroupEnum = typeof GETAllMedicalInstitutionsGroupEnum[keyof typeof GETAllMedicalInstitutionsGroupEnum];


/**
 * Query parameters for gETAllMedicalInstitutions operation in MedicalInstitutionsV2Api.
 * @export
 * @interface MedicalInstitutionsV2ApiGETAllMedicalInstitutionsQueryParams
 */
export interface MedicalInstitutionsV2ApiGETAllMedicalInstitutionsQueryParams {
    //latlng
    /**
     * Sorting by location (Latitude and Longitude separated by comma, latitude first).
     * @type {string}
     * @memberof MedicalInstitutionsV2ApiGETAllMedicalInstitutions
     */
    latlng?: string

    //range
    /**
     * Filter by distance from latlng in meters (range query). Depends on the latlng parameter.
     * @type {number}
     * @memberof MedicalInstitutionsV2ApiGETAllMedicalInstitutions
     */
    range?: number

    //districts
    /**
     * Filter by Prague city districts (slug) separated by comma.
     * @type {Array<any>}
     * @memberof MedicalInstitutionsV2ApiGETAllMedicalInstitutions
     */
    districts?: Array<any>

    //groupisEnumGroupEnum
    /**
     * Filter by group of types of the medical institution.
     * @type {'pharmacies' | 'health_care'}
     * @memberof MedicalInstitutionsV2ApiGETAllMedicalInstitutions
     */
    group?: GETAllMedicalInstitutionsGroupEnum

    //limit
    /**
     * Limits number of retrieved items. The maximum is 10000 (default value).
     * @type {number}
     * @memberof MedicalInstitutionsV2ApiGETAllMedicalInstitutions
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped.
     * @type {number}
     * @memberof MedicalInstitutionsV2ApiGETAllMedicalInstitutions
     */
    offset?: number

    //updatedSince
    /**
     * Filters all results with older updated_at than this parameter
     * @type {string}
     * @memberof MedicalInstitutionsV2ApiGETAllMedicalInstitutions
     */
    updatedSince?: string
}








/**
 * MedicalInstitutionsV2Api - object-oriented interface
 * @export
 * @class MedicalInstitutionsV2Api
 * @extends {BaseAPI}
 */
export class MedicalInstitutionsV2Api extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 
     * @summary GET All Medical Institution Types

     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MedicalInstitutionsV2Api
     */
    
    public async gETAllMedicalInstitutionTypes(
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/medicalinstitutions/types`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<MedicalInstitutionType>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET All Medical Institutions

     * @param {MedicalInstitutionsV2ApiGETAllMedicalInstitutionsQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MedicalInstitutionsV2Api
     */
    
    public async gETAllMedicalInstitutions(
        queryParams: MedicalInstitutionsV2ApiGETAllMedicalInstitutionsQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/medicalinstitutions`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.latlng !== undefined) {
            requestQueryParameter['latlng'] = queryParams.latlng;
        }

        if (queryParams.range !== undefined) {
            requestQueryParameter['range'] = queryParams.range;
        }

        if (queryParams.districts) {
            requestQueryParameter['districts'] = queryParams.districts;
        }

        if (queryParams.group !== undefined) {
            requestQueryParameter['group'] = queryParams.group;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }

        if (queryParams.updatedSince !== undefined) {
            requestQueryParameter['updatedSince'] = queryParams.updatedSince;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<GETAllMedicalInstitutions200Response>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET Medical Institution

     * @param {string} id Identifier of the Medical Institution.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MedicalInstitutionsV2Api
     */
    
    public async gETMedicalInstitution(
        id: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'id' is not null or undefined
        assertParamExists('gETMedicalInstitution', 'id', id)
        
        const localVarPath = `/v2/medicalinstitutions/{id}`
            .replace(`{${"id"}}`, encodeURIComponent(String(id)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<MedicalInstitution>(axiosRequestConfig);
    }
}





/**
 * Query parameters for gETAllMicroclimateSensorLocations operation in MicroclimateV2Api.
 * @export
 * @interface MicroclimateV2ApiGETAllMicroclimateSensorLocationsQueryParams
 */
export interface MicroclimateV2ApiGETAllMicroclimateSensorLocationsQueryParams {
    //locationId
    /**
     * Filter by location
     * @type {number}
     * @memberof MicroclimateV2ApiGETAllMicroclimateSensorLocations
     */
    locationId?: number
}





/**
 * Query parameters for gETAllMicroclimateSensorMeasurements operation in MicroclimateV2Api.
 * @export
 * @interface MicroclimateV2ApiGETAllMicroclimateSensorMeasurementsQueryParams
 */
export interface MicroclimateV2ApiGETAllMicroclimateSensorMeasurementsQueryParams {
    //locationId
    /**
     * Filter by location
     * @type {number}
     * @memberof MicroclimateV2ApiGETAllMicroclimateSensorMeasurements
     */
    locationId?: number

    //pointId
    /**
     * Filter by location
     * @type {number}
     * @memberof MicroclimateV2ApiGETAllMicroclimateSensorMeasurements
     */
    pointId?: number

    //measure
    /**
     * Filter by measure type
     * @type {string}
     * @memberof MicroclimateV2ApiGETAllMicroclimateSensorMeasurements
     */
    measure?: string

    //from
    /**
     * Filter by measured_at
     * @type {string}
     * @memberof MicroclimateV2ApiGETAllMicroclimateSensorMeasurements
     */
    from?: string

    //to
    /**
     * Filter by measured_at
     * @type {string}
     * @memberof MicroclimateV2ApiGETAllMicroclimateSensorMeasurements
     */
    to?: string
}





/**
 * Query parameters for gETMicroclimateSensorPoints operation in MicroclimateV2Api.
 * @export
 * @interface MicroclimateV2ApiGETMicroclimateSensorPointsQueryParams
 */
export interface MicroclimateV2ApiGETMicroclimateSensorPointsQueryParams {
    //locationId
    /**
     * Filter by location
     * @type {number}
     * @memberof MicroclimateV2ApiGETMicroclimateSensorPoints
     */
    locationId?: number

    //pointId
    /**
     * Filter by location
     * @type {number}
     * @memberof MicroclimateV2ApiGETMicroclimateSensorPoints
     */
    pointId?: number
}




/**
 * MicroclimateV2Api - object-oriented interface
 * @export
 * @class MicroclimateV2Api
 * @extends {BaseAPI}
 */
export class MicroclimateV2Api extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 
     * @summary GET All Microclimate Sensor Locations

     * @param {MicroclimateV2ApiGETAllMicroclimateSensorLocationsQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MicroclimateV2Api
     */
    
    public async gETAllMicroclimateSensorLocations(
        queryParams: MicroclimateV2ApiGETAllMicroclimateSensorLocationsQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/microclimate/locations`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.locationId !== undefined) {
            requestQueryParameter['locationId'] = queryParams.locationId;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<Location>>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET All Microclimate Sensor Measurements

     * @param {MicroclimateV2ApiGETAllMicroclimateSensorMeasurementsQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MicroclimateV2Api
     */
    
    public async gETAllMicroclimateSensorMeasurements(
        queryParams: MicroclimateV2ApiGETAllMicroclimateSensorMeasurementsQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/microclimate/measurements`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.locationId !== undefined) {
            requestQueryParameter['locationId'] = queryParams.locationId;
        }

        if (queryParams.pointId !== undefined) {
            requestQueryParameter['pointId'] = queryParams.pointId;
        }

        if (queryParams.measure !== undefined) {
            requestQueryParameter['measure'] = queryParams.measure;
        }

        if (queryParams.from !== undefined) {
            requestQueryParameter['from'] = (queryParams.from as any instanceof Date) ?
                (queryParams.from as any).toISOString() :
                queryParams.from;
        }

        if (queryParams.to !== undefined) {
            requestQueryParameter['to'] = (queryParams.to as any instanceof Date) ?
                (queryParams.to as any).toISOString() :
                queryParams.to;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<Measurement>>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET Microclimate Sensor Points

     * @param {MicroclimateV2ApiGETMicroclimateSensorPointsQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MicroclimateV2Api
     */
    
    public async gETMicroclimateSensorPoints(
        queryParams: MicroclimateV2ApiGETMicroclimateSensorPointsQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/microclimate/points`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.locationId !== undefined) {
            requestQueryParameter['locationId'] = queryParams.locationId;
        }

        if (queryParams.pointId !== undefined) {
            requestQueryParameter['pointId'] = queryParams.pointId;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Point3>(axiosRequestConfig);
    }
}



/**
 * @export
 */
export const GETAllMunicipalAuthoritiesTypeEnum = {
    Municipality: 'municipality',
    CityHall: 'city-hall'
} as const;
export type GETAllMunicipalAuthoritiesTypeEnum = typeof GETAllMunicipalAuthoritiesTypeEnum[keyof typeof GETAllMunicipalAuthoritiesTypeEnum];


/**
 * Query parameters for gETAllMunicipalAuthorities operation in MunicipalAuthoritiesV2Api.
 * @export
 * @interface MunicipalAuthoritiesV2ApiGETAllMunicipalAuthoritiesQueryParams
 */
export interface MunicipalAuthoritiesV2ApiGETAllMunicipalAuthoritiesQueryParams {
    //latlng
    /**
     * Sorting by location (Latitude and Longitude separated by comma, latitude first).
     * @type {string}
     * @memberof MunicipalAuthoritiesV2ApiGETAllMunicipalAuthorities
     */
    latlng?: string

    //range
    /**
     * Filter by distance from latlng in meters (range query). Depends on the latlng parameter.
     * @type {number}
     * @memberof MunicipalAuthoritiesV2ApiGETAllMunicipalAuthorities
     */
    range?: number

    //districts
    /**
     * Filter by Prague city districts (slug) separated by comma.
     * @type {Array<any>}
     * @memberof MunicipalAuthoritiesV2ApiGETAllMunicipalAuthorities
     */
    districts?: Array<any>

    //typeisEnumTypeEnum
    /**
     * Filter by group of types of the municipal authorities.
     * @type {'municipality' | 'city-hall'}
     * @memberof MunicipalAuthoritiesV2ApiGETAllMunicipalAuthorities
     */
    type?: GETAllMunicipalAuthoritiesTypeEnum

    //limit
    /**
     * Limits number of retrieved items. The maximum is 10000 (default value).
     * @type {number}
     * @memberof MunicipalAuthoritiesV2ApiGETAllMunicipalAuthorities
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped.
     * @type {number}
     * @memberof MunicipalAuthoritiesV2ApiGETAllMunicipalAuthorities
     */
    offset?: number

    //updatedSince
    /**
     * Filters all results with older updated_at than this parameter
     * @type {string}
     * @memberof MunicipalAuthoritiesV2ApiGETAllMunicipalAuthorities
     */
    updatedSince?: string
}












/**
 * MunicipalAuthoritiesV2Api - object-oriented interface
 * @export
 * @class MunicipalAuthoritiesV2Api
 * @extends {BaseAPI}
 */
export class MunicipalAuthoritiesV2Api extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 
     * @summary GET All Municipal Authorities

     * @param {MunicipalAuthoritiesV2ApiGETAllMunicipalAuthoritiesQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MunicipalAuthoritiesV2Api
     */
    
    public async gETAllMunicipalAuthorities(
        queryParams: MunicipalAuthoritiesV2ApiGETAllMunicipalAuthoritiesQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/municipalauthorities`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.latlng !== undefined) {
            requestQueryParameter['latlng'] = queryParams.latlng;
        }

        if (queryParams.range !== undefined) {
            requestQueryParameter['range'] = queryParams.range;
        }

        if (queryParams.districts) {
            requestQueryParameter['districts'] = queryParams.districts;
        }

        if (queryParams.type !== undefined) {
            requestQueryParameter['type'] = queryParams.type;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }

        if (queryParams.updatedSince !== undefined) {
            requestQueryParameter['updatedSince'] = queryParams.updatedSince;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<GETAllMunicipalAuthorities200Response>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET All Municipal Authority Waiting Queues

     * @param {string} id Identifier of the municipality.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MunicipalAuthoritiesV2Api
     */
    
    public async gETAllMunicipalAuthorityWaitingQueues(
        id: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'id' is not null or undefined
        assertParamExists('gETAllMunicipalAuthorityWaitingQueues', 'id', id)
        
        const localVarPath = `/v2/municipalauthorities/{id}/queues`
            .replace(`{${"id"}}`, encodeURIComponent(String(id)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<MunicipalAuthorityQueues>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET Municipal Authority

     * @param {string} id Identifier of the municipal authority.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MunicipalAuthoritiesV2Api
     */
    
    public async gETMunicipalAuthority(
        id: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'id' is not null or undefined
        assertParamExists('gETMunicipalAuthority', 'id', id)
        
        const localVarPath = `/v2/municipalauthorities/{id}`
            .replace(`{${"id"}}`, encodeURIComponent(String(id)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<MunicipalAuthority>(axiosRequestConfig);
    }
}





/**
 * Query parameters for gETAllMunicipalLibraries operation in MunicipalLibrariesV2Api.
 * @export
 * @interface MunicipalLibrariesV2ApiGETAllMunicipalLibrariesQueryParams
 */
export interface MunicipalLibrariesV2ApiGETAllMunicipalLibrariesQueryParams {
    //latlng
    /**
     * Sorting by location (Latitude and Longitude separated by comma, latitude first).
     * @type {string}
     * @memberof MunicipalLibrariesV2ApiGETAllMunicipalLibraries
     */
    latlng?: string

    //range
    /**
     * Filter by distance from latlng in meters (range query). Depends on the latlng parameter.
     * @type {number}
     * @memberof MunicipalLibrariesV2ApiGETAllMunicipalLibraries
     */
    range?: number

    //districts
    /**
     * Filter by Prague city districts (slug) separated by comma.
     * @type {Array<any>}
     * @memberof MunicipalLibrariesV2ApiGETAllMunicipalLibraries
     */
    districts?: Array<any>

    //limit
    /**
     * Limits number of retrieved items. The maximum is 10000 (default value).
     * @type {number}
     * @memberof MunicipalLibrariesV2ApiGETAllMunicipalLibraries
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped.
     * @type {number}
     * @memberof MunicipalLibrariesV2ApiGETAllMunicipalLibraries
     */
    offset?: number

    //updatedSince
    /**
     * Filters all results with older updated_at than this parameter
     * @type {string}
     * @memberof MunicipalLibrariesV2ApiGETAllMunicipalLibraries
     */
    updatedSince?: string
}








/**
 * MunicipalLibrariesV2Api - object-oriented interface
 * @export
 * @class MunicipalLibrariesV2Api
 * @extends {BaseAPI}
 */
export class MunicipalLibrariesV2Api extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 
     * @summary GET All Municipal Libraries

     * @param {MunicipalLibrariesV2ApiGETAllMunicipalLibrariesQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MunicipalLibrariesV2Api
     */
    
    public async gETAllMunicipalLibraries(
        queryParams: MunicipalLibrariesV2ApiGETAllMunicipalLibrariesQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/municipallibraries`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.latlng !== undefined) {
            requestQueryParameter['latlng'] = queryParams.latlng;
        }

        if (queryParams.range !== undefined) {
            requestQueryParameter['range'] = queryParams.range;
        }

        if (queryParams.districts) {
            requestQueryParameter['districts'] = queryParams.districts;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }

        if (queryParams.updatedSince !== undefined) {
            requestQueryParameter['updatedSince'] = queryParams.updatedSince;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<GETAllMunicipalLibraries200Response>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET Municipal Library

     * @param {number} id Identifier of the Municipal Library.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MunicipalLibrariesV2Api
     */
    
    public async gETMunicipalLibrary(
        id: number,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'id' is not null or undefined
        assertParamExists('gETMunicipalLibrary', 'id', id)
        
        const localVarPath = `/v2/municipallibraries/{id}`
            .replace(`{${"id"}}`, encodeURIComponent(String(id)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<MunicipalLibrary>(axiosRequestConfig);
    }
}





/**
 * Query parameters for gETAllMunicipalPoliceStations operation in MunicipalPoliceStationsV2Api.
 * @export
 * @interface MunicipalPoliceStationsV2ApiGETAllMunicipalPoliceStationsQueryParams
 */
export interface MunicipalPoliceStationsV2ApiGETAllMunicipalPoliceStationsQueryParams {
    //latlng
    /**
     * Sorting by location (Latitude and Longitude separated by comma, latitude first).
     * @type {string}
     * @memberof MunicipalPoliceStationsV2ApiGETAllMunicipalPoliceStations
     */
    latlng?: string

    //range
    /**
     * Filter by distance from latlng in meters (range query). Depends on the latlng parameter.
     * @type {number}
     * @memberof MunicipalPoliceStationsV2ApiGETAllMunicipalPoliceStations
     */
    range?: number

    //districts
    /**
     * Filter by Prague city districts (slug) separated by comma.
     * @type {Array<any>}
     * @memberof MunicipalPoliceStationsV2ApiGETAllMunicipalPoliceStations
     */
    districts?: Array<any>

    //limit
    /**
     * Limits number of retrieved items. The maximum is 10000 (default value).
     * @type {number}
     * @memberof MunicipalPoliceStationsV2ApiGETAllMunicipalPoliceStations
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped.
     * @type {number}
     * @memberof MunicipalPoliceStationsV2ApiGETAllMunicipalPoliceStations
     */
    offset?: number

    //updatedSince
    /**
     * Filters all results with older updated_at than this parameter
     * @type {string}
     * @memberof MunicipalPoliceStationsV2ApiGETAllMunicipalPoliceStations
     */
    updatedSince?: string
}








/**
 * MunicipalPoliceStationsV2Api - object-oriented interface
 * @export
 * @class MunicipalPoliceStationsV2Api
 * @extends {BaseAPI}
 */
export class MunicipalPoliceStationsV2Api extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 
     * @summary GET All Municipal Police Stations

     * @param {MunicipalPoliceStationsV2ApiGETAllMunicipalPoliceStationsQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MunicipalPoliceStationsV2Api
     */
    
    public async gETAllMunicipalPoliceStations(
        queryParams: MunicipalPoliceStationsV2ApiGETAllMunicipalPoliceStationsQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/municipalpolicestations`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.latlng !== undefined) {
            requestQueryParameter['latlng'] = queryParams.latlng;
        }

        if (queryParams.range !== undefined) {
            requestQueryParameter['range'] = queryParams.range;
        }

        if (queryParams.districts) {
            requestQueryParameter['districts'] = queryParams.districts;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }

        if (queryParams.updatedSince !== undefined) {
            requestQueryParameter['updatedSince'] = queryParams.updatedSince;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<GETAllMunicipalPoliceStations200Response>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET Municipal Police Station

     * @param {number} id Identifier of the police station.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MunicipalPoliceStationsV2Api
     */
    
    public async gETMunicipalPoliceStation(
        id: number,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'id' is not null or undefined
        assertParamExists('gETMunicipalPoliceStation', 'id', id)
        
        const localVarPath = `/v2/municipalpolicestations/{id}`
            .replace(`{${"id"}}`, encodeURIComponent(String(id)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<MunicipalPoliceStation>(axiosRequestConfig);
    }
}





/**
 * Query parameters for v1ParkingsGet operation in ParkingV1Api.
 * @export
 * @interface ParkingV1ApiV1ParkingsGetQueryParams
 */
export interface ParkingV1ApiV1ParkingsGetQueryParams {
    //latlng
    /**
     * Sorting by location (Latitude and Longitude separated by comma, latitude first).
     * @type {string}
     * @memberof ParkingV1ApiV1ParkingsGet
     */
    latlng?: string

    //range
    /**
     * Filter by distance from latlng in meters (range query). Depends on the latlng parameter.
     * @type {number}
     * @memberof ParkingV1ApiV1ParkingsGet
     */
    range?: number

    //districts
    /**
     * Filter by Prague city districts (slug) separated by comma.
     * @type {Array<any>}
     * @memberof ParkingV1ApiV1ParkingsGet
     */
    districts?: Array<any>

    //limit
    /**
     * Limits number of retrieved items.
     * @type {number}
     * @memberof ParkingV1ApiV1ParkingsGet
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped.
     * @type {number}
     * @memberof ParkingV1ApiV1ParkingsGet
     */
    offset?: number

    //updatedSince
    /**
     * Filters all results with older updated_at than this parameter
     * @type {string}
     * @memberof ParkingV1ApiV1ParkingsGet
     */
    updatedSince?: string
}





/**
 * Query parameters for v1ParkingsHistoryGet operation in ParkingV1Api.
 * @export
 * @interface ParkingV1ApiV1ParkingsHistoryGetQueryParams
 */
export interface ParkingV1ApiV1ParkingsHistoryGetQueryParams {
    //limit
    /**
     * Limits number of retrieved items.
     * @type {number}
     * @memberof ParkingV1ApiV1ParkingsHistoryGet
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped.
     * @type {number}
     * @memberof ParkingV1ApiV1ParkingsHistoryGet
     */
    offset?: number

    //from
    /**
     * Date in ISO8601, limits data measured from this datetime
     * @type {string}
     * @memberof ParkingV1ApiV1ParkingsHistoryGet
     */
    from?: string

    //to
    /**
     * Date in ISO8601, limits data measured up to this datetime
     * @type {string}
     * @memberof ParkingV1ApiV1ParkingsHistoryGet
     */
    to?: string

    //sensorId
    /**
     * Limits data measured by sensor with this id (parameter &#x60;id&#x60; of the parking)
     * @type {string}
     * @memberof ParkingV1ApiV1ParkingsHistoryGet
     */
    sensorId?: string
}








/**
 * ParkingV1Api - object-oriented interface
 * @export
 * @class ParkingV1Api
 * @extends {BaseAPI}
 */
export class ParkingV1Api extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 
     * @summary GET All Parking Lots within the region of interest

     * @param {ParkingV1ApiV1ParkingsGetQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParkingV1Api
     */
    
    public async v1ParkingsGet(
        queryParams: ParkingV1ApiV1ParkingsGetQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v1/parkings`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.latlng !== undefined) {
            requestQueryParameter['latlng'] = queryParams.latlng;
        }

        if (queryParams.range !== undefined) {
            requestQueryParameter['range'] = queryParams.range;
        }

        if (queryParams.districts) {
            requestQueryParameter['districts'] = queryParams.districts;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }

        if (queryParams.updatedSince !== undefined) {
            requestQueryParameter['updatedSince'] = queryParams.updatedSince;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<V1ParkingsGet200Response>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET Parking Lot History

     * @param {ParkingV1ApiV1ParkingsHistoryGetQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParkingV1Api
     */
    
    public async v1ParkingsHistoryGet(
        queryParams: ParkingV1ApiV1ParkingsHistoryGetQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v1/parkings/history`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }

        if (queryParams.from !== undefined) {
            requestQueryParameter['from'] = queryParams.from;
        }

        if (queryParams.to !== undefined) {
            requestQueryParameter['to'] = queryParams.to;
        }

        if (queryParams.sensorId !== undefined) {
            requestQueryParameter['sensorId'] = queryParams.sensorId;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<ParkingLotHistory>>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET Parking Lot

     * @param {string} id Id of parking location.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParkingV1Api
     */
    
    public async v1ParkingsIdGet(
        id: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'id' is not null or undefined
        assertParamExists('v1ParkingsIdGet', 'id', id)
        
        const localVarPath = `/v1/parkings/{id}`
            .replace(`{${"id"}}`, encodeURIComponent(String(id)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<ParkingLotFeature>(axiosRequestConfig);
    }
}





/**
 * Query parameters for v2ParkingGet operation in ParkingV2Api.
 * @export
 * @interface ParkingV2ApiV2ParkingGetQueryParams
 */
export interface ParkingV2ApiV2ParkingGetQueryParams {
    //latlng
    /**
     * Sorting by location (Latitude and Longitude separated by comma, latitude first).
     * @type {string}
     * @memberof ParkingV2ApiV2ParkingGet
     */
    latlng?: string

    //range
    /**
     * Filter by distance from latlng in meters (range query). Depends on the latlng parameter.
     * @type {number}
     * @memberof ParkingV2ApiV2ParkingGet
     */
    range?: number

    //source
    /**
     * Filter by data provider.
     * @type {string}
     * @memberof ParkingV2ApiV2ParkingGet
     */
    source?: string

    //sourceId
    /**
     * Filter by parking group id. Unique per data provider.
     * @type {string}
     * @memberof ParkingV2ApiV2ParkingGet
     */
    sourceId?: string

    //category
    /**
     * Filter by parking type. Use with square brackets &#x60;category[]&#x60;
     * @type {Array<string>}
     * @memberof ParkingV2ApiV2ParkingGet
     */
    category?: Array<string>

    //limit
    /**
     * Limits number of retrieved items.
     * @type {number}
     * @memberof ParkingV2ApiV2ParkingGet
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped.
     * @type {number}
     * @memberof ParkingV2ApiV2ParkingGet
     */
    offset?: number

    //minutesBefore
    /**
     * Filter by time conditions based on last data update. By maximal minutes before last update.
     * @type {number}
     * @memberof ParkingV2ApiV2ParkingGet
     */
    minutesBefore?: number

    //updatedSince
    /**
     * Filter by time conditions based on last data update. Date has to be in ISO8601 format. Cannot be used together with minutesBefore.
     * @type {string}
     * @memberof ParkingV2ApiV2ParkingGet
     */
    updatedSince?: string
}








/**
 * ParkingV2Api - object-oriented interface
 * @export
 * @class ParkingV2Api
 * @extends {BaseAPI}
 */
export class ParkingV2Api extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 
     * @summary GET All Parking Spaces within the region of interest

     * @param {ParkingV2ApiV2ParkingGetQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParkingV2Api
     */
    
    public async v2ParkingGet(
        queryParams: ParkingV2ApiV2ParkingGetQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/parking`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.latlng !== undefined) {
            requestQueryParameter['latlng'] = queryParams.latlng;
        }

        if (queryParams.range !== undefined) {
            requestQueryParameter['range'] = queryParams.range;
        }

        if (queryParams.source !== undefined) {
            requestQueryParameter['source'] = queryParams.source;
        }

        if (queryParams.sourceId !== undefined) {
            requestQueryParameter['sourceId'] = queryParams.sourceId;
        }

        if (queryParams.category) {
            requestQueryParameter['category'] = queryParams.category.join(COLLECTION_FORMATS.csv);
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }

        if (queryParams.minutesBefore !== undefined) {
            requestQueryParameter['minutesBefore'] = queryParams.minutesBefore;
        }

        if (queryParams.updatedSince !== undefined) {
            requestQueryParameter['updatedSince'] = queryParams.updatedSince;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<V2ParkingGet200Response>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET Parking Space

     * @param {string} id Id of parking location.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParkingV2Api
     */
    
    public async v2ParkingIdGet(
        id: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'id' is not null or undefined
        assertParamExists('v2ParkingIdGet', 'id', id)
        
        const localVarPath = `/v2/parking/{id}`
            .replace(`{${"id"}}`, encodeURIComponent(String(id)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<ParkingSpaceFeature>(axiosRequestConfig);
    }
}





/**
 * Query parameters for v2ParkingDetailGet operation in ParkingV2InternalApi.
 * @export
 * @interface ParkingV2InternalApiV2ParkingDetailGetQueryParams
 */
export interface ParkingV2InternalApiV2ParkingDetailGetQueryParams {
    //latlng
    /**
     * Sorting by location (Latitude and Longitude separated by comma, latitude first).
     * @type {string}
     * @memberof ParkingV2InternalApiV2ParkingDetailGet
     */
    latlng?: string

    //range
    /**
     * Filter by distance from latlng in meters (range query). Depends on the latlng parameter.
     * @type {number}
     * @memberof ParkingV2InternalApiV2ParkingDetailGet
     */
    range?: number

    //source
    /**
     * Filter by data provider.
     * @type {string}
     * @memberof ParkingV2InternalApiV2ParkingDetailGet
     */
    source?: string

    //sourceId
    /**
     * Filter by parking group id. Unique per data provider.
     * @type {string}
     * @memberof ParkingV2InternalApiV2ParkingDetailGet
     */
    sourceId?: string

    //category
    /**
     * Filter by parking type. Use with square brackets &#x60;category[]&#x60;
     * @type {Array<string>}
     * @memberof ParkingV2InternalApiV2ParkingDetailGet
     */
    category?: Array<string>

    //limit
    /**
     * Limits number of retrieved items.
     * @type {number}
     * @memberof ParkingV2InternalApiV2ParkingDetailGet
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped.
     * @type {number}
     * @memberof ParkingV2InternalApiV2ParkingDetailGet
     */
    offset?: number

    //minutesBefore
    /**
     * Filter by time conditions based on last data update. By maximal minutes before last update.
     * @type {number}
     * @memberof ParkingV2InternalApiV2ParkingDetailGet
     */
    minutesBefore?: number

    //updatedSince
    /**
     * Filter by time conditions based on last data update. Date has to be in ISO8601 format. Cannot be used together with minutesBefore.
     * @type {string}
     * @memberof ParkingV2InternalApiV2ParkingDetailGet
     */
    updatedSince?: string

    //zoneType
    /**
     * Filter by parking zone. Use with square brackets &#x60;zoneType[]&#x60;, multiple values can be passed forming an array.
     * @type {Array<string>}
     * @memberof ParkingV2InternalApiV2ParkingDetailGet
     */
    zoneType?: Array<string>

    //parkingType
    /**
     * Filter by parking type. Use with square brackets &#x60;parkingType[]&#x60;, multiple values can be passed forming an array.
     * @type {Array<string>}
     * @memberof ParkingV2InternalApiV2ParkingDetailGet
     */
    parkingType?: Array<string>
}









/**
 * Query parameters for v2ParkingMeasurementsGet operation in ParkingV2InternalApi.
 * @export
 * @interface ParkingV2InternalApiV2ParkingMeasurementsGetQueryParams
 */
export interface ParkingV2InternalApiV2ParkingMeasurementsGetQueryParams {
    //source
    /**
     * Filter by data provider.
     * @type {string}
     * @memberof ParkingV2InternalApiV2ParkingMeasurementsGet
     */
    source?: string

    //sourceId
    /**
     * Filter by parking group id. Unique per data provider.
     * @type {string}
     * @memberof ParkingV2InternalApiV2ParkingMeasurementsGet
     */
    sourceId?: string

    //latest
    /**
     * Show only the latest measurement.
     * @type {boolean}
     * @memberof ParkingV2InternalApiV2ParkingMeasurementsGet
     */
    latest?: boolean

    //from
    /**
     * Date in ISO8601, limits data measured from this datetime.
     * @type {string}
     * @memberof ParkingV2InternalApiV2ParkingMeasurementsGet
     */
    from?: string

    //to
    /**
     * Date in ISO8601, limits data measured up until this datetime.
     * @type {string}
     * @memberof ParkingV2InternalApiV2ParkingMeasurementsGet
     */
    to?: string

    //limit
    /**
     * Limits number of retrieved items. Max 10000.
     * @type {number}
     * @memberof ParkingV2InternalApiV2ParkingMeasurementsGet
     */
    limit?: number

    //offset
    /**
     * Number of items that are skipped in result (like in sql).
     * @type {number}
     * @memberof ParkingV2InternalApiV2ParkingMeasurementsGet
     */
    offset?: number

    //minutesBefore
    /**
     * Filter by time conditions based on last data update. By maximal minutes before last update.
     * @type {number}
     * @memberof ParkingV2InternalApiV2ParkingMeasurementsGet
     */
    minutesBefore?: number

    //updatedSince
    /**
     * Filter by time conditions based on last data update. Date has to be in ISO8601 format. Cannot be used together with minutesBefore.
     * @type {string}
     * @memberof ParkingV2InternalApiV2ParkingMeasurementsGet
     */
    updatedSince?: string
}





/**
 * Query parameters for v2ParkingTariffsGet operation in ParkingV2InternalApi.
 * @export
 * @interface ParkingV2InternalApiV2ParkingTariffsGetQueryParams
 */
export interface ParkingV2InternalApiV2ParkingTariffsGetQueryParams {
    //source
    /**
     * Filter by data provider.
     * @type {string}
     * @memberof ParkingV2InternalApiV2ParkingTariffsGet
     */
    source?: string
}








/**
 * ParkingV2InternalApi - object-oriented interface
 * @export
 * @class ParkingV2InternalApi
 * @extends {BaseAPI}
 */
export class ParkingV2InternalApi extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 
     * @summary GET All Detailed Parking Spaces

     * @param {ParkingV2InternalApiV2ParkingDetailGetQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParkingV2InternalApi
     */
    
    public async v2ParkingDetailGet(
        queryParams: ParkingV2InternalApiV2ParkingDetailGetQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/parking/detail`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.latlng !== undefined) {
            requestQueryParameter['latlng'] = queryParams.latlng;
        }

        if (queryParams.range !== undefined) {
            requestQueryParameter['range'] = queryParams.range;
        }

        if (queryParams.source !== undefined) {
            requestQueryParameter['source'] = queryParams.source;
        }

        if (queryParams.sourceId !== undefined) {
            requestQueryParameter['sourceId'] = queryParams.sourceId;
        }

        if (queryParams.category) {
            requestQueryParameter['category'] = queryParams.category.join(COLLECTION_FORMATS.csv);
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }

        if (queryParams.minutesBefore !== undefined) {
            requestQueryParameter['minutesBefore'] = queryParams.minutesBefore;
        }

        if (queryParams.updatedSince !== undefined) {
            requestQueryParameter['updatedSince'] = queryParams.updatedSince;
        }

        if (queryParams.zoneType) {
            requestQueryParameter['zoneType'] = queryParams.zoneType.join(COLLECTION_FORMATS.csv);
        }

        if (queryParams.parkingType) {
            requestQueryParameter['parkingType'] = queryParams.parkingType.join(COLLECTION_FORMATS.csv);
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<V2ParkingGet200Response>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET Detailed Parking Space

     * @param {string} id Id of parking location.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParkingV2InternalApi
     */
    
    public async v2ParkingDetailIdGet(
        id: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'id' is not null or undefined
        assertParamExists('v2ParkingDetailIdGet', 'id', id)
        
        const localVarPath = `/v2/parking/detail/{id}`
            .replace(`{${"id"}}`, encodeURIComponent(String(id)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<ParkingSpaceFeature>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET All Parking Spaces Measurements

     * @param {ParkingV2InternalApiV2ParkingMeasurementsGetQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParkingV2InternalApi
     */
    
    public async v2ParkingMeasurementsGet(
        queryParams: ParkingV2InternalApiV2ParkingMeasurementsGetQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/parking/measurements`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.source !== undefined) {
            requestQueryParameter['source'] = queryParams.source;
        }

        if (queryParams.sourceId !== undefined) {
            requestQueryParameter['sourceId'] = queryParams.sourceId;
        }

        if (queryParams.latest !== undefined) {
            requestQueryParameter['latest'] = queryParams.latest;
        }

        if (queryParams.from !== undefined) {
            requestQueryParameter['from'] = queryParams.from;
        }

        if (queryParams.to !== undefined) {
            requestQueryParameter['to'] = queryParams.to;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }

        if (queryParams.minutesBefore !== undefined) {
            requestQueryParameter['minutesBefore'] = queryParams.minutesBefore;
        }

        if (queryParams.updatedSince !== undefined) {
            requestQueryParameter['updatedSince'] = queryParams.updatedSince;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<ParkingMeasurement>>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET All Parking Spaces Tariffs

     * @param {ParkingV2InternalApiV2ParkingTariffsGetQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParkingV2InternalApi
     */
    
    public async v2ParkingTariffsGet(
        queryParams: ParkingV2InternalApiV2ParkingTariffsGetQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/parking/tariffs`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.source !== undefined) {
            requestQueryParameter['source'] = queryParams.source;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<ParkingSpaceTariff>>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET Parking Space Tariff

     * @param {string} tariffId Id of parking tariff.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParkingV2InternalApi
     */
    
    public async v2ParkingTariffsTariffIdGet(
        tariffId: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'tariffId' is not null or undefined
        assertParamExists('v2ParkingTariffsTariffIdGet', 'tariffId', tariffId)
        
        const localVarPath = `/v2/parking/tariffs/{tariffId}`
            .replace(`{${"tariffId"}}`, encodeURIComponent(String(tariffId)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<ParkingSpaceTariff>(axiosRequestConfig);
    }
}



/**
 * @export
 */
export const V3ParkingGetAccessDedicatedToEnum = {
    Disabled: 'disabled',
    Charging: 'charging',
    Parent: 'parent',
    Delivery: 'delivery',
    Customer: 'customer',
    Resident: 'resident',
    Bus: 'bus',
    Designated: 'designated',
    Truck: 'truck',
    Motorcycle: 'motorcycle',
    Rv: 'RV'
} as const;
export type V3ParkingGetAccessDedicatedToEnum = typeof V3ParkingGetAccessDedicatedToEnum[keyof typeof V3ParkingGetAccessDedicatedToEnum];
/**
 * @export
 */
export const V3ParkingGetParkingPolicyEnum = {
    Commercial: 'commercial',
    CustomerOnly: 'customer_only',
    KissAndRide: 'kiss_and_ride',
    ParkAndRide: 'park_and_ride',
    ParkSharing: 'park_sharing',
    Zone: 'zone'
} as const;
export type V3ParkingGetParkingPolicyEnum = typeof V3ParkingGetParkingPolicyEnum[keyof typeof V3ParkingGetParkingPolicyEnum];


/**
 * Query parameters for v3ParkingGet operation in ParkingV3Api.
 * @export
 * @interface ParkingV3ApiV3ParkingGetQueryParams
 */
export interface ParkingV3ApiV3ParkingGetQueryParams {
    //primarySource
    /**
     * Filter by data source (note that &#x60;osm&#x60; is a secondary source, not a primary source). Use with square brackets &#x60;primarySource[]&#x60;. When no filter is used, all parking locations from all primary sources are included along with non-overlapping parking locations from all secondary sources (&#x60;osm&#x60;). Similarly, when a filter with both primary and secondary sources is used, all parking locations from the specified primary sources are included along with non-overlapping parking locations from the specified secondary sources. When a filter with only a single source is used, all parking locations from the specified source are included regardless of whether the source is primary or secondary.
     * @type {Array<string>}
     * @memberof ParkingV3ApiV3ParkingGet
     */
    primarySource?: Array<string>

    //boundingBox
    /**
     * Filter by bounding box in format \&quot;topLeft.lat,topLeft.lon,bottomRight.lat,bottomRight.lon\&quot;, polygons that fit only partially to selected bounding box are included
     * @type {string}
     * @memberof ParkingV3ApiV3ParkingGet
     */
    boundingBox?: string

    //validFrom
    /**
     * Filter by valid from date
     * @type {string}
     * @memberof ParkingV3ApiV3ParkingGet
     */
    validFrom?: string

    //openingHoursValidFrom
    /**
     * Filter opening hours by valid from date
     * @type {string}
     * @memberof ParkingV3ApiV3ParkingGet
     */
    openingHoursValidFrom?: string

    //openingHoursValidTo
    /**
     * Filter opening hours by valid to date
     * @type {string}
     * @memberof ParkingV3ApiV3ParkingGet
     */
    openingHoursValidTo?: string

    //accessDedicatedToisEnumAccessDedicatedToEnum
    /**
     * Experimental: Filter by access combinations to specific spaces in parking. Return only strictly matched parking by access to parking spaces
     * @type {Array<'disabled' | 'charging' | 'parent' | 'delivery' | 'customer' | 'resident' | 'bus' | 'designated' | 'truck' | 'motorcycle' | 'RV'>}
     * @memberof ParkingV3ApiV3ParkingGet
     */
    accessDedicatedTo?: Array<V3ParkingGetAccessDedicatedToEnum>

    //parkingPolicyisEnumParkingPolicyEnum
    /**
     * Filter by parking policy. For multiple values use with square brackets &#x60;parkingPolicy[]&#x60;
     * @type {Array<'commercial' | 'customer_only' | 'kiss_and_ride' | 'park_and_ride' | 'park_sharing' | 'zone'>}
     * @memberof ParkingV3ApiV3ParkingGet
     */
    parkingPolicy?: Array<V3ParkingGetParkingPolicyEnum>

    //minutesBefore
    /**
     * Filter by time conditions based on last data update. By maximal minutes before last update.
     * @type {number}
     * @memberof ParkingV3ApiV3ParkingGet
     */
    minutesBefore?: number

    //updatedSince
    /**
     * Filter by time conditions based on last data update. Date has to be in ISO8601 format. Cannot be used together with minutesBefore.
     * @type {string}
     * @memberof ParkingV3ApiV3ParkingGet
     */
    updatedSince?: string

    //activeOnly
    /**
     * If true, filter out locations that did not appear in latest source data.
     * @type {boolean}
     * @memberof ParkingV3ApiV3ParkingGet
     */
    activeOnly?: boolean

    //limit
    /**
     * Number of results to return
     * @type {number}
     * @memberof ParkingV3ApiV3ParkingGet
     */
    limit?: number

    //offset
    /**
     * Number of results to skip for pagination
     * @type {number}
     * @memberof ParkingV3ApiV3ParkingGet
     */
    offset?: number
}











/**
 * @export
 */
export const V3ParkingMachinesGetTypeEnum = {
    PaymentMachine: 'payment_machine',
    InfoBox: 'info_box'
} as const;
export type V3ParkingMachinesGetTypeEnum = typeof V3ParkingMachinesGetTypeEnum[keyof typeof V3ParkingMachinesGetTypeEnum];


/**
 * Query parameters for v3ParkingMachinesGet operation in ParkingV3Api.
 * @export
 * @interface ParkingV3ApiV3ParkingMachinesGetQueryParams
 */
export interface ParkingV3ApiV3ParkingMachinesGetQueryParams {
    //primarySource
    /**
     * Filter by primary source. Use with square brackets &#x60;primarySource[]&#x60;
     * @type {Array<string>}
     * @memberof ParkingV3ApiV3ParkingMachinesGet
     */
    primarySource?: Array<string>

    //typeisEnumTypeEnum
    /**
     * Filter by type
     * @type {Array<'payment_machine' | 'info_box'>}
     * @memberof ParkingV3ApiV3ParkingMachinesGet
     */
    type?: Array<V3ParkingMachinesGetTypeEnum>

    //boundingBox
    /**
     * Filter by bounding box in format \&quot;topLeft.lat,topLeft.lon,bottomRight.lat,bottomRight.lon\&quot;, polygons that fit only partially to selected bounding box are included
     * @type {string}
     * @memberof ParkingV3ApiV3ParkingMachinesGet
     */
    boundingBox?: string

    //codeMask
    /**
     * Filter by code mask using substring match and \&quot;%\&quot; wildcard (partial match). (If used directly in postman or browser, \&quot;%\&quot; needs to be encoded as \&quot;%25\&quot;. Examples: - &#x60;query&#x60; matches substring in codes - &#x60;start%&#x60; matches codes starting with \&quot;start\&quot; - &#x60;%end&#x60; matches codes ending with \&quot;end\&quot; - &#x60;%middle%&#x60; matches codes containing \&quot;middle\&quot; anywhere 
     * @type {string}
     * @memberof ParkingV3ApiV3ParkingMachinesGet
     */
    codeMask?: string

    //validFrom
    /**
     * Filter by valid from date
     * @type {string}
     * @memberof ParkingV3ApiV3ParkingMachinesGet
     */
    validFrom?: string

    //limit
    /**
     * Number of results to return
     * @type {number}
     * @memberof ParkingV3ApiV3ParkingMachinesGet
     */
    limit?: number

    //offset
    /**
     * Number of results to skip for pagination
     * @type {number}
     * @memberof ParkingV3ApiV3ParkingMachinesGet
     */
    offset?: number
}









/**
 * Query parameters for v3ParkingMeasurementsGet operation in ParkingV3Api.
 * @export
 * @interface ParkingV3ApiV3ParkingMeasurementsGetQueryParams
 */
export interface ParkingV3ApiV3ParkingMeasurementsGetQueryParams {
    //primarySource
    /**
     * Filter by primary source. Use with square brackets &#x60;primarySource[]&#x60;
     * @type {Array<string>}
     * @memberof ParkingV3ApiV3ParkingMeasurementsGet
     */
    primarySource?: Array<string>

    //parkingId
    /**
     * Filter by primary parking ID. Use with square brackets &#x60;parkingId[]&#x60;
     * @type {Array<string>}
     * @memberof ParkingV3ApiV3ParkingMeasurementsGet
     */
    parkingId?: Array<string>

    //limit
    /**
     * Number of results to return
     * @type {number}
     * @memberof ParkingV3ApiV3ParkingMeasurementsGet
     */
    limit?: number

    //offset
    /**
     * Number of results to skip for pagination
     * @type {number}
     * @memberof ParkingV3ApiV3ParkingMeasurementsGet
     */
    offset?: number
}









/**
 * Query parameters for v3ParkingTariffsGet operation in ParkingV3Api.
 * @export
 * @interface ParkingV3ApiV3ParkingTariffsGetQueryParams
 */
export interface ParkingV3ApiV3ParkingTariffsGetQueryParams {
    //primarySource
    /**
     * Filter by primary source. Use with square brackets &#x60;primarySource[]&#x60;
     * @type {Array<string>}
     * @memberof ParkingV3ApiV3ParkingTariffsGet
     */
    primarySource?: Array<string>

    //validFrom
    /**
     * Filter by valid from date of ChargeBand in Tariff (result show all tariffs that contains at least one valid ChargeBand and inside only ChargeBand objects that fit into that filter)
     * @type {string}
     * @memberof ParkingV3ApiV3ParkingTariffsGet
     */
    validFrom?: string

    //validTo
    /**
     * Filter by valid to date of ChargeBand in Tariff (result show all tariffs that contains at least one valid ChargeBand and inside only ChargeBand objects that fit into that filter)
     * @type {string}
     * @memberof ParkingV3ApiV3ParkingTariffsGet
     */
    validTo?: string

    //limit
    /**
     * Number of results to return
     * @type {number}
     * @memberof ParkingV3ApiV3ParkingTariffsGet
     */
    limit?: number

    //offset
    /**
     * Number of results to skip for pagination
     * @type {number}
     * @memberof ParkingV3ApiV3ParkingTariffsGet
     */
    offset?: number
}








/**
 * ParkingV3Api - object-oriented interface
 * @export
 * @class ParkingV3Api
 * @extends {BaseAPI}
 */
export class ParkingV3Api extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 
     * @summary Get a list of parking locations within the region of interest with filtering options

     * @param {ParkingV3ApiV3ParkingGetQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParkingV3Api
     */
    
    public async v3ParkingGet(
        queryParams: ParkingV3ApiV3ParkingGetQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v3/parking`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.primarySource) {
            requestQueryParameter['primarySource'] = queryParams.primarySource;
        }

        if (queryParams.boundingBox !== undefined) {
            requestQueryParameter['boundingBox'] = queryParams.boundingBox;
        }

        if (queryParams.validFrom !== undefined) {
            requestQueryParameter['validFrom'] = (queryParams.validFrom as any instanceof Date) ?
                (queryParams.validFrom as any).toISOString() :
                queryParams.validFrom;
        }

        if (queryParams.openingHoursValidFrom !== undefined) {
            requestQueryParameter['openingHoursValidFrom'] = (queryParams.openingHoursValidFrom as any instanceof Date) ?
                (queryParams.openingHoursValidFrom as any).toISOString() :
                queryParams.openingHoursValidFrom;
        }

        if (queryParams.openingHoursValidTo !== undefined) {
            requestQueryParameter['openingHoursValidTo'] = (queryParams.openingHoursValidTo as any instanceof Date) ?
                (queryParams.openingHoursValidTo as any).toISOString() :
                queryParams.openingHoursValidTo;
        }

        if (queryParams.accessDedicatedTo) {
            requestQueryParameter['accessDedicatedTo'] = queryParams.accessDedicatedTo;
        }

        if (queryParams.parkingPolicy) {
            requestQueryParameter['parkingPolicy'] = queryParams.parkingPolicy;
        }

        if (queryParams.minutesBefore !== undefined) {
            requestQueryParameter['minutesBefore'] = queryParams.minutesBefore;
        }

        if (queryParams.updatedSince !== undefined) {
            requestQueryParameter['updatedSince'] = queryParams.updatedSince;
        }

        if (queryParams.activeOnly !== undefined) {
            requestQueryParameter['activeOnly'] = queryParams.activeOnly;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<V3ParkingGet200Response>(axiosRequestConfig);
    }

    /**
     * 
     * @summary Get detailed information about the average occupancy by ID

     * @param {string} id The identifier of the parking space to retrieve
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParkingV3Api
     */
    
    public async v3ParkingIdAverageOccupancyGet(
        id: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'id' is not null or undefined
        assertParamExists('v3ParkingIdAverageOccupancyGet', 'id', id)
        
        const localVarPath = `/v3/parking/{id}/average-occupancy`
            .replace(`{${"id"}}`, encodeURIComponent(String(id)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<AverageOccupancyWeek>(axiosRequestConfig);
    }

    /**
     * 
     * @summary Get detailed information about a parking location by ID

     * @param {string} id The identifier of the parking location to retrieve
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParkingV3Api
     */
    
    public async v3ParkingIdGet(
        id: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'id' is not null or undefined
        assertParamExists('v3ParkingIdGet', 'id', id)
        
        const localVarPath = `/v3/parking/{id}`
            .replace(`{${"id"}}`, encodeURIComponent(String(id)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Parking>(axiosRequestConfig);
    }

    /**
     * 
     * @summary Get a list of parking machines within the region of interest with filtering options. Results are sorted by id.

     * @param {ParkingV3ApiV3ParkingMachinesGetQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParkingV3Api
     */
    
    public async v3ParkingMachinesGet(
        queryParams: ParkingV3ApiV3ParkingMachinesGetQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v3/parking-machines`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.primarySource) {
            requestQueryParameter['primarySource'] = queryParams.primarySource;
        }

        if (queryParams.type) {
            requestQueryParameter['type'] = queryParams.type;
        }

        if (queryParams.boundingBox !== undefined) {
            requestQueryParameter['boundingBox'] = queryParams.boundingBox;
        }

        if (queryParams.codeMask !== undefined) {
            requestQueryParameter['codeMask'] = queryParams.codeMask;
        }

        if (queryParams.validFrom !== undefined) {
            requestQueryParameter['validFrom'] = (queryParams.validFrom as any instanceof Date) ?
                (queryParams.validFrom as any).toISOString() :
                queryParams.validFrom;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<V3ParkingMachinesGet200Response>(axiosRequestConfig);
    }

    /**
     * 
     * @summary Get a parking machine by ID

     * @param {string} id ID of the parking machine to retrieve
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParkingV3Api
     */
    
    public async v3ParkingMachinesIdGet(
        id: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'id' is not null or undefined
        assertParamExists('v3ParkingMachinesIdGet', 'id', id)
        
        const localVarPath = `/v3/parking-machines/{id}`
            .replace(`{${"id"}}`, encodeURIComponent(String(id)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<ParkingMachine>(axiosRequestConfig);
    }

    /**
     * 
     * @summary Get a list of the latest (max 1h old) parking measurements with filtering options

     * @param {ParkingV3ApiV3ParkingMeasurementsGetQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParkingV3Api
     */
    
    public async v3ParkingMeasurementsGet(
        queryParams: ParkingV3ApiV3ParkingMeasurementsGetQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v3/parking-measurements`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.primarySource) {
            requestQueryParameter['primarySource'] = queryParams.primarySource;
        }

        if (queryParams.parkingId) {
            requestQueryParameter['parkingId'] = queryParams.parkingId;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<ParkingOccupancyMeasurement>>(axiosRequestConfig);
    }

    /**
     * 
     * @summary Available parking sources

     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParkingV3Api
     */
    
    public async v3ParkingSourcesGet(
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v3/parking-sources`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<ParkingSource>>(axiosRequestConfig);
    }

    /**
     * 
     * @summary Get a list of tariffs with filtering options

     * @param {ParkingV3ApiV3ParkingTariffsGetQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParkingV3Api
     */
    
    public async v3ParkingTariffsGet(
        queryParams: ParkingV3ApiV3ParkingTariffsGetQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v3/parking-tariffs`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.primarySource) {
            requestQueryParameter['primarySource'] = queryParams.primarySource;
        }

        if (queryParams.validFrom !== undefined) {
            requestQueryParameter['validFrom'] = (queryParams.validFrom as any instanceof Date) ?
                (queryParams.validFrom as any).toISOString() :
                queryParams.validFrom;
        }

        if (queryParams.validTo !== undefined) {
            requestQueryParameter['validTo'] = (queryParams.validTo as any instanceof Date) ?
                (queryParams.validTo as any).toISOString() :
                queryParams.validTo;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<ParkingTariff>>(axiosRequestConfig);
    }

    /**
     * 
     * @summary Get a tariff by ID

     * @param {string} id UUID of the tariff to retrieve
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParkingV3Api
     */
    
    public async v3ParkingTariffsIdGet(
        id: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'id' is not null or undefined
        assertParamExists('v3ParkingTariffsIdGet', 'id', id)
        
        const localVarPath = `/v3/parking-tariffs/{id}`
            .replace(`{${"id"}}`, encodeURIComponent(String(id)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<ParkingTariff>(axiosRequestConfig);
    }
}





/**
 * Query parameters for v2PedestriansLocationsGet operation in PedestriansV2Api.
 * @export
 * @interface PedestriansV2ApiV2PedestriansLocationsGetQueryParams
 */
export interface PedestriansV2ApiV2PedestriansLocationsGetQueryParams {
    //locationId
    /**
     * Lists only locations with this ID
     * @type {number}
     * @memberof PedestriansV2ApiV2PedestriansLocationsGet
     */
    locationId?: number

    //locationName
    /**
     * Lists only locations with this NAME
     * @type {string}
     * @memberof PedestriansV2ApiV2PedestriansLocationsGet
     */
    locationName?: string

    //limit
    /**
     * Limits number of retrieved items
     * @type {number}
     * @memberof PedestriansV2ApiV2PedestriansLocationsGet
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped
     * @type {number}
     * @memberof PedestriansV2ApiV2PedestriansLocationsGet
     */
    offset?: number
}





/**
 * Query parameters for v2PedestriansMeasurementsGet operation in PedestriansV2Api.
 * @export
 * @interface PedestriansV2ApiV2PedestriansMeasurementsGetQueryParams
 */
export interface PedestriansV2ApiV2PedestriansMeasurementsGetQueryParams {
    //locationId
    /**
     * Lists only measurements for this location
     * @type {number}
     * @memberof PedestriansV2ApiV2PedestriansMeasurementsGet
     */
    locationId?: number

    //directionId
    /**
     * Lists only measurements for this direction
     * @type {number}
     * @memberof PedestriansV2ApiV2PedestriansMeasurementsGet
     */
    directionId?: number

    //limit
    /**
     * Limits number of retrieved items
     * @type {number}
     * @memberof PedestriansV2ApiV2PedestriansMeasurementsGet
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped
     * @type {number}
     * @memberof PedestriansV2ApiV2PedestriansMeasurementsGet
     */
    offset?: number

    //from
    /**
     * Date in ISO8601, limits data measured from this datetime
     * @type {string}
     * @memberof PedestriansV2ApiV2PedestriansMeasurementsGet
     */
    from?: string

    //to
    /**
     * Date in ISO8601, limits data measured up until this datetime
     * @type {string}
     * @memberof PedestriansV2ApiV2PedestriansMeasurementsGet
     */
    to?: string
}




/**
 * PedestriansV2Api - object-oriented interface
 * @export
 * @class PedestriansV2Api
 * @extends {BaseAPI}
 */
export class PedestriansV2Api extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 
     * @summary Get locations and directions

     * @param {PedestriansV2ApiV2PedestriansLocationsGetQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PedestriansV2Api
     */
    
    public async v2PedestriansLocationsGet(
        queryParams: PedestriansV2ApiV2PedestriansLocationsGetQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/pedestrians/locations`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.locationId !== undefined) {
            requestQueryParameter['locationId'] = queryParams.locationId;
        }

        if (queryParams.locationName !== undefined) {
            requestQueryParameter['locationName'] = queryParams.locationName;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<PedestriansLocation>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET measurements of pedestrian traffic

     * @param {PedestriansV2ApiV2PedestriansMeasurementsGetQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PedestriansV2Api
     */
    
    public async v2PedestriansMeasurementsGet(
        queryParams: PedestriansV2ApiV2PedestriansMeasurementsGetQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/pedestrians/measurements`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.locationId !== undefined) {
            requestQueryParameter['locationId'] = queryParams.locationId;
        }

        if (queryParams.directionId !== undefined) {
            requestQueryParameter['directionId'] = queryParams.directionId;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }

        if (queryParams.from !== undefined) {
            requestQueryParameter['from'] = (queryParams.from as any instanceof Date) ?
                (queryParams.from as any).toISOString().substring(0,10) :
                queryParams.from;
        }

        if (queryParams.to !== undefined) {
            requestQueryParameter['to'] = (queryParams.to as any instanceof Date) ?
                (queryParams.to as any).toISOString().substring(0,10) :
                queryParams.to;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<PedestriansMeasurement>(axiosRequestConfig);
    }
}





/**
 * Query parameters for gETAllPlaygrounds operation in PlaygroundsV2Api.
 * @export
 * @interface PlaygroundsV2ApiGETAllPlaygroundsQueryParams
 */
export interface PlaygroundsV2ApiGETAllPlaygroundsQueryParams {
    //latlng
    /**
     * Sorting by location (Latitude and Longitude separated by comma, latitude first).
     * @type {string}
     * @memberof PlaygroundsV2ApiGETAllPlaygrounds
     */
    latlng?: string

    //range
    /**
     * Filter by distance from latlng in meters (range query). Depends on the latlng parameter.
     * @type {number}
     * @memberof PlaygroundsV2ApiGETAllPlaygrounds
     */
    range?: number

    //districts
    /**
     * Filter by Prague city districts (slug) separated by comma.
     * @type {Array<any>}
     * @memberof PlaygroundsV2ApiGETAllPlaygrounds
     */
    districts?: Array<any>

    //limit
    /**
     * Limits number of retrieved items. The maximum is 10000 (default value).
     * @type {number}
     * @memberof PlaygroundsV2ApiGETAllPlaygrounds
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped.
     * @type {number}
     * @memberof PlaygroundsV2ApiGETAllPlaygrounds
     */
    offset?: number

    //updatedSince
    /**
     * Filters all results with older updated_at than this parameter
     * @type {string}
     * @memberof PlaygroundsV2ApiGETAllPlaygrounds
     */
    updatedSince?: string
}












/**
 * PlaygroundsV2Api - object-oriented interface
 * @export
 * @class PlaygroundsV2Api
 * @extends {BaseAPI}
 */
export class PlaygroundsV2Api extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 
     * @summary GET All Playgrounds

     * @param {PlaygroundsV2ApiGETAllPlaygroundsQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaygroundsV2Api
     */
    
    public async gETAllPlaygrounds(
        queryParams: PlaygroundsV2ApiGETAllPlaygroundsQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/playgrounds`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.latlng !== undefined) {
            requestQueryParameter['latlng'] = queryParams.latlng;
        }

        if (queryParams.range !== undefined) {
            requestQueryParameter['range'] = queryParams.range;
        }

        if (queryParams.districts) {
            requestQueryParameter['districts'] = queryParams.districts;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }

        if (queryParams.updatedSince !== undefined) {
            requestQueryParameter['updatedSince'] = queryParams.updatedSince;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<GETAllPlaygrounds200Response>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET All Playgrounds Properties

     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaygroundsV2Api
     */
    
    public async gETAllPlaygroundsProperties(
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/playgrounds/properties`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<PlaygroundProperty>>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET Playground

     * @param {number} id Identifier of the playground.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaygroundsV2Api
     */
    
    public async gETPlaygrounds(
        id: number,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'id' is not null or undefined
        assertParamExists('gETPlaygrounds', 'id', id)
        
        const localVarPath = `/v2/playgrounds/{id}`
            .replace(`{${"id"}}`, encodeURIComponent(String(id)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Playground>(axiosRequestConfig);
    }
}





/**
 * Query parameters for v2CitydistrictsGet operation in PragueCityDistrictsV2Api.
 * @export
 * @interface PragueCityDistrictsV2ApiV2CitydistrictsGetQueryParams
 */
export interface PragueCityDistrictsV2ApiV2CitydistrictsGetQueryParams {
    //latlng
    /**
     * Sorting by location (Latitude and Longitude separated by comma, latitude first).
     * @type {string}
     * @memberof PragueCityDistrictsV2ApiV2CitydistrictsGet
     */
    latlng?: string

    //range
    /**
     * Filter by distance from latlng in meters (range query). Depends on the latlng parameter.
     * @type {number}
     * @memberof PragueCityDistrictsV2ApiV2CitydistrictsGet
     */
    range?: number

    //limit
    /**
     * Limits number of retrieved items.
     * @type {number}
     * @memberof PragueCityDistrictsV2ApiV2CitydistrictsGet
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped.
     * @type {number}
     * @memberof PragueCityDistrictsV2ApiV2CitydistrictsGet
     */
    offset?: number

    //updatedSince
    /**
     * Filters all results with older updated_at than this parameter
     * @type {string}
     * @memberof PragueCityDistrictsV2ApiV2CitydistrictsGet
     */
    updatedSince?: string
}








/**
 * PragueCityDistrictsV2Api - object-oriented interface
 * @export
 * @class PragueCityDistrictsV2Api
 * @extends {BaseAPI}
 */
export class PragueCityDistrictsV2Api extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 
     * @summary GET All Districts

     * @param {PragueCityDistrictsV2ApiV2CitydistrictsGetQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PragueCityDistrictsV2Api
     */
    
    public async v2CitydistrictsGet(
        queryParams: PragueCityDistrictsV2ApiV2CitydistrictsGetQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/citydistricts`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.latlng !== undefined) {
            requestQueryParameter['latlng'] = queryParams.latlng;
        }

        if (queryParams.range !== undefined) {
            requestQueryParameter['range'] = queryParams.range;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }

        if (queryParams.updatedSince !== undefined) {
            requestQueryParameter['updatedSince'] = (queryParams.updatedSince as any instanceof Date) ?
                (queryParams.updatedSince as any).toISOString() :
                queryParams.updatedSince;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<V2CitydistrictsGet200Response>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET District

     * @param {string} id Identifier or slug of the city district.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PragueCityDistrictsV2Api
     */
    
    public async v2CitydistrictsIdGet(
        id: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'id' is not null or undefined
        assertParamExists('v2CitydistrictsIdGet', 'id', id)
        
        const localVarPath = `/v2/citydistricts/{id}`
            .replace(`{${"id"}}`, encodeURIComponent(String(id)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<CityDistrictFeature>(axiosRequestConfig);
    }
}





/**
 * Query parameters for gETAllSharedBikes operation in SharedBikesV2Api.
 * @export
 * @interface SharedBikesV2ApiGETAllSharedBikesQueryParams
 */
export interface SharedBikesV2ApiGETAllSharedBikesQueryParams {
    //latlng
    /**
     * Sorting by location (Latitude and Longitude separated by comma, latitude first).
     * @type {string}
     * @memberof SharedBikesV2ApiGETAllSharedBikes
     */
    latlng?: string

    //range
    /**
     * Filter by distance from latlng in meters (range query). Depends on the latlng parameter.
     * @type {number}
     * @memberof SharedBikesV2ApiGETAllSharedBikes
     */
    range?: number

    //districts
    /**
     * Filter by Prague city districts (in array format - eg. districts[]&#x3D;praha7&amp;districts[]&#x3D;praha6)
     * @type {Array<any>}
     * @memberof SharedBikesV2ApiGETAllSharedBikes
     */
    districts?: Array<any>

    //limit
    /**
     * Limits number of retrieved items. The maximum is 10000 (default value).
     * @type {number}
     * @memberof SharedBikesV2ApiGETAllSharedBikes
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped.
     * @type {number}
     * @memberof SharedBikesV2ApiGETAllSharedBikes
     */
    offset?: number

    //updatedSince
    /**
     * Filters all results with older updated_at than this parameter
     * @type {string}
     * @memberof SharedBikesV2ApiGETAllSharedBikes
     */
    updatedSince?: string

    //companyNames
    /**
     * Filters all results with company.name property by this parameter. Use with square brackets &#x60;companyNames[]&#x60;, multiple values can be passed forming an array.
     * @type {Array<string>}
     * @memberof SharedBikesV2ApiGETAllSharedBikes
     */
    companyNames?: Array<string>
}








/**
 * SharedBikesV2Api - object-oriented interface
 * @export
 * @class SharedBikesV2Api
 * @extends {BaseAPI}
 */
export class SharedBikesV2Api extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 
     * @summary GET All Shared Bikes

     * @param {SharedBikesV2ApiGETAllSharedBikesQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SharedBikesV2Api
     */
    
    public async gETAllSharedBikes(
        queryParams: SharedBikesV2ApiGETAllSharedBikesQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/sharedbikes`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.latlng !== undefined) {
            requestQueryParameter['latlng'] = queryParams.latlng;
        }

        if (queryParams.range !== undefined) {
            requestQueryParameter['range'] = queryParams.range;
        }

        if (queryParams.districts) {
            requestQueryParameter['districts'] = queryParams.districts;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }

        if (queryParams.updatedSince !== undefined) {
            requestQueryParameter['updatedSince'] = queryParams.updatedSince;
        }

        if (queryParams.companyNames) {
            requestQueryParameter['companyNames'] = queryParams.companyNames;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<GETAllSharedBikes200Response>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET Shared Bike

     * @param {string} id Identifier of the shared vehicle.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SharedBikesV2Api
     */
    
    public async gETSharedVBike(
        id: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'id' is not null or undefined
        assertParamExists('gETSharedVBike', 'id', id)
        
        const localVarPath = `/v2/sharedbikes/{id}`
            .replace(`{${"id"}}`, encodeURIComponent(String(id)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<SharedVehicle>(axiosRequestConfig);
    }
}





/**
 * Query parameters for gETAllSharedCars operation in SharedCarsV2Api.
 * @export
 * @interface SharedCarsV2ApiGETAllSharedCarsQueryParams
 */
export interface SharedCarsV2ApiGETAllSharedCarsQueryParams {
    //latlng
    /**
     * Sorting by location (Latitude and Longitude separated by comma, latitude first).
     * @type {string}
     * @memberof SharedCarsV2ApiGETAllSharedCars
     */
    latlng?: string

    //range
    /**
     * Filter by distance from latlng in meters (range query). Depends on the latlng parameter.
     * @type {number}
     * @memberof SharedCarsV2ApiGETAllSharedCars
     */
    range?: number

    //districts
    /**
     * Filter by Prague city districts (in array format - eg. districts[]&#x3D;praha7&amp;districts[]&#x3D;praha6)
     * @type {Array<any>}
     * @memberof SharedCarsV2ApiGETAllSharedCars
     */
    districts?: Array<any>

    //limit
    /**
     * Limits number of retrieved items. The maximum is 10000 (default value).
     * @type {number}
     * @memberof SharedCarsV2ApiGETAllSharedCars
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped.
     * @type {number}
     * @memberof SharedCarsV2ApiGETAllSharedCars
     */
    offset?: number

    //updatedSince
    /**
     * Filters all results with older updated_at than this parameter
     * @type {string}
     * @memberof SharedCarsV2ApiGETAllSharedCars
     */
    updatedSince?: string

    //companyNames
    /**
     * Filters all results with company.name property by this parameter. Use with square brackets &#x60;companyNames[]&#x60;, multiple values can be passed forming an array.
     * @type {Array<string>}
     * @memberof SharedCarsV2ApiGETAllSharedCars
     */
    companyNames?: Array<string>
}








/**
 * SharedCarsV2Api - object-oriented interface
 * @export
 * @class SharedCarsV2Api
 * @extends {BaseAPI}
 */
export class SharedCarsV2Api extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 
     * @summary GET All Shared Cars

     * @param {SharedCarsV2ApiGETAllSharedCarsQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SharedCarsV2Api
     */
    
    public async gETAllSharedCars(
        queryParams: SharedCarsV2ApiGETAllSharedCarsQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/sharedcars`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.latlng !== undefined) {
            requestQueryParameter['latlng'] = queryParams.latlng;
        }

        if (queryParams.range !== undefined) {
            requestQueryParameter['range'] = queryParams.range;
        }

        if (queryParams.districts) {
            requestQueryParameter['districts'] = queryParams.districts;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }

        if (queryParams.updatedSince !== undefined) {
            requestQueryParameter['updatedSince'] = queryParams.updatedSince;
        }

        if (queryParams.companyNames) {
            requestQueryParameter['companyNames'] = queryParams.companyNames;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<GETAllSharedCars200Response>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET Shared Car

     * @param {string} id Identifier of the shared car.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SharedCarsV2Api
     */
    
    public async gETSharedCar(
        id: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'id' is not null or undefined
        assertParamExists('gETSharedCar', 'id', id)
        
        const localVarPath = `/v2/sharedcars/{id}`
            .replace(`{${"id"}}`, encodeURIComponent(String(id)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<SharedCar>(axiosRequestConfig);
    }
}





/**
 * Query parameters for getTrafficRestrictions operation in TrafficRestrictionsV2Api.
 * @export
 * @interface TrafficRestrictionsV2ApiGetTrafficRestrictionsQueryParams
 */
export interface TrafficRestrictionsV2ApiGetTrafficRestrictionsQueryParams {
    //moment
    /**
     * Get restrictions valid on given moment. ISO8601 format.
     * @type {string}
     * @memberof TrafficRestrictionsV2ApiGetTrafficRestrictions
     */
    moment?: string

    //situationRecordType
    /**
     * Situation Record Type
     * @type {string}
     * @memberof TrafficRestrictionsV2ApiGetTrafficRestrictions
     */
    situationRecordType?: string

    //limit
    /**
     * Limits number of retrieved items. The maximum is 10000 (default value)
     * @type {number}
     * @memberof TrafficRestrictionsV2ApiGetTrafficRestrictions
     */
    limit?: number

    //offset
    /**
     * Sets offset for pagination. Combine with limit accordingly.
     * @type {number}
     * @memberof TrafficRestrictionsV2ApiGetTrafficRestrictions
     */
    offset?: number
}




/**
 * TrafficRestrictionsV2Api - object-oriented interface
 * @export
 * @class TrafficRestrictionsV2Api
 * @extends {BaseAPI}
 */
export class TrafficRestrictionsV2Api extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 
     * @summary GET All Traffic Restrictions for a specific moment

     * @param {TrafficRestrictionsV2ApiGetTrafficRestrictionsQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrafficRestrictionsV2Api
     */
    
    public async getTrafficRestrictions(
        queryParams: TrafficRestrictionsV2ApiGetTrafficRestrictionsQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/traffic/restrictions`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.moment !== undefined) {
            requestQueryParameter['moment'] = queryParams.moment;
        }

        if (queryParams.situationRecordType !== undefined) {
            requestQueryParameter['situationRecordType'] = queryParams.situationRecordType;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<TrafficRestrictionsPublication>(axiosRequestConfig);
    }
}





/**
 * Query parameters for gETAllSharedVehicles operation in VehiclesharingV2Api.
 * @export
 * @interface VehiclesharingV2ApiGETAllSharedVehiclesQueryParams
 */
export interface VehiclesharingV2ApiGETAllSharedVehiclesQueryParams {
    //latlng
    /**
     * Sorting by location (Latitude and Longitude separated by comma, latitude first).
     * @type {string}
     * @memberof VehiclesharingV2ApiGETAllSharedVehicles
     */
    latlng?: string

    //range
    /**
     * Filter by distance from latlng in meters (range query). Depends on the latlng parameter.
     * @type {number}
     * @memberof VehiclesharingV2ApiGETAllSharedVehicles
     */
    range?: number

    //districts
    /**
     * Filter by Prague city districts (in array format - eg. districts[]&#x3D;praha7&amp;districts[]&#x3D;praha6)
     * @type {Array<any>}
     * @memberof VehiclesharingV2ApiGETAllSharedVehicles
     */
    districts?: Array<any>

    //limit
    /**
     * Limits number of retrieved items. The maximum is 10000 (default value).
     * @type {number}
     * @memberof VehiclesharingV2ApiGETAllSharedVehicles
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped.
     * @type {number}
     * @memberof VehiclesharingV2ApiGETAllSharedVehicles
     */
    offset?: number

    //updatedSince
    /**
     * Filters all results with older updated_at than this parameter
     * @type {string}
     * @memberof VehiclesharingV2ApiGETAllSharedVehicles
     */
    updatedSince?: string

    //companyNames
    /**
     * Filters all results with company.name property by this parameter. Use with square brackets &#x60;companyNames[]&#x60;, multiple values can be passed forming an array.
     * @type {Array<string>}
     * @memberof VehiclesharingV2ApiGETAllSharedVehicles
     */
    companyNames?: Array<string>
}








/**
 * VehiclesharingV2Api - object-oriented interface
 * @export
 * @class VehiclesharingV2Api
 * @extends {BaseAPI}
 */
export class VehiclesharingV2Api extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 
     * @summary GET All Shared Vehicles

     * @param {VehiclesharingV2ApiGETAllSharedVehiclesQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehiclesharingV2Api
     */
    
    public async gETAllSharedVehicles(
        queryParams: VehiclesharingV2ApiGETAllSharedVehiclesQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/vehiclesharing`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.latlng !== undefined) {
            requestQueryParameter['latlng'] = queryParams.latlng;
        }

        if (queryParams.range !== undefined) {
            requestQueryParameter['range'] = queryParams.range;
        }

        if (queryParams.districts) {
            requestQueryParameter['districts'] = queryParams.districts;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }

        if (queryParams.updatedSince !== undefined) {
            requestQueryParameter['updatedSince'] = queryParams.updatedSince;
        }

        if (queryParams.companyNames) {
            requestQueryParameter['companyNames'] = queryParams.companyNames;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<GETAllSharedBikes200Response>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET Shared Vehicle

     * @param {string} id Identifier of the shared vehicle.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehiclesharingV2Api
     */
    
    public async gETSharedVehicle(
        id: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'id' is not null or undefined
        assertParamExists('gETSharedVehicle', 'id', id)
        
        const localVarPath = `/v2/vehiclesharing/{id}`
            .replace(`{${"id"}}`, encodeURIComponent(String(id)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<SharedVehicle>(axiosRequestConfig);
    }
}





/**
 * Query parameters for getWCStations operation in WasteCollectionV2Api.
 * @export
 * @interface WasteCollectionV2ApiGetWCStationsQueryParams
 */
export interface WasteCollectionV2ApiGetWCStationsQueryParams {
    //latlng
    /**
     * Sorting by location (Latitude and Longitude separated by comma, latitude first)
     * @type {string}
     * @memberof WasteCollectionV2ApiGetWCStations
     */
    latlng?: string

    //range
    /**
     * Filter by distance from latlng in meters (range query). Depends on the latlng parameter
     * @type {number}
     * @memberof WasteCollectionV2ApiGetWCStations
     */
    range?: number

    //districts
    /**
     * Filter by Prague city districts (slug) separated by comma
     * @type {string}
     * @memberof WasteCollectionV2ApiGetWCStations
     */
    districts?: string

    //accessibility
    /**
     * Filter by accessibility id&lt;br /&gt; | 1 | volnƒõ | accessible |&lt;br /&gt; | 2 | obyvatel≈Øm domu | only for house residents |&lt;br /&gt; | 3 | nezn√°m√° dostupnost | unknown |
     * @type {Array<number>}
     * @memberof WasteCollectionV2ApiGetWCStations
     */
    accessibility?: Array<number>

    //limit
    /**
     * Limits number of retrieved items. The maximum is 10000 (default value)
     * @type {number}
     * @memberof WasteCollectionV2ApiGetWCStations
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped
     * @type {number}
     * @memberof WasteCollectionV2ApiGetWCStations
     */
    offset?: number

    //onlyMonitored
    /**
     * Filter only stations with at least one \&quot;smart\&quot; container with sensor for measurements and pickups
     * @type {boolean}
     * @memberof WasteCollectionV2ApiGetWCStations
     */
    onlyMonitored?: boolean

    //id
    /**
     * Identical to ksnkoId, displays station containers with given id (now is used KSNKO ID as the main identifier)
     * @type {number}
     * @memberof WasteCollectionV2ApiGetWCStations
     */
    id?: number

    //ksnkoId
    /**
     * KSNKO identifier of a container, shows only stations that posess containers with this ID
     * @type {number}
     * @memberof WasteCollectionV2ApiGetWCStations
     */
    ksnkoId?: number
}




/**
 * WasteCollectionV2Api - object-oriented interface
 * @export
 * @class WasteCollectionV2Api
 * @extends {BaseAPI}
 */
export class WasteCollectionV2Api extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * **Trash type**<br /> | 1 | Barevn√© sklo | Tinted glass |<br /> | 2 | Elektroza≈ô√≠zen√≠ | Electric waste |<br /> | 3 | Kovy | Metals |<br /> | 4 | N√°pojov√© kart√≥ny | Beverage cartons |<br /> | 5 | Pap√≠r | Paper |<br /> | 6 | Plast | Plastics |<br /> | 7 | ƒåir√© sklo | Clear glass |<br /> | 8 | Jedl√© tuky a oleje | Edible fats and oils |<br /> | 9 | Multikomoditn√≠ sbƒõr | Multicommodity |<br /> <br /> **Cleaning Frequency**<br /> | Value | 1st digit - period duration | 2nd digit - frequency |<br /> Example<br /> | `13` | `1` | `3` | 3 times per 1 week |<br /> | `61` | `6` | `1` | Once per 6 weeks |<br />
     * @summary GET All Waste Collection Stations

     * @param {WasteCollectionV2ApiGetWCStationsQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WasteCollectionV2Api
     */
    
    public async getWCStations(
        queryParams: WasteCollectionV2ApiGetWCStationsQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/sortedwastestations`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.latlng !== undefined) {
            requestQueryParameter['latlng'] = queryParams.latlng;
        }

        if (queryParams.range !== undefined) {
            requestQueryParameter['range'] = queryParams.range;
        }

        if (queryParams.districts !== undefined) {
            requestQueryParameter['districts'] = queryParams.districts;
        }

        if (queryParams.accessibility) {
            requestQueryParameter['accessibility'] = queryParams.accessibility;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }

        if (queryParams.onlyMonitored !== undefined) {
            requestQueryParameter['onlyMonitored'] = queryParams.onlyMonitored;
        }

        if (queryParams.id !== undefined) {
            requestQueryParameter['id'] = queryParams.id;
        }

        if (queryParams.ksnkoId !== undefined) {
            requestQueryParameter['ksnkoId'] = queryParams.ksnkoId;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<WasteCollectionStationFeatureCollection>(axiosRequestConfig);
    }
}





/**
 * Query parameters for getWCMeasurements operation in WasteCollectionV2InternalApi.
 * @export
 * @interface WasteCollectionV2InternalApiGetWCMeasurementsQueryParams
 */
export interface WasteCollectionV2InternalApiGetWCMeasurementsQueryParams {
    //containerId
    /**
     * Lists only measurements from container with this ID (now is used KSNKO ID as main identifier)
     * @type {string}
     * @memberof WasteCollectionV2InternalApiGetWCMeasurements
     */
    containerId: string

    //ksnkoId
    /**
     * Lists only measurements from container with this KSNKO ID
     * @type {string}
     * @memberof WasteCollectionV2InternalApiGetWCMeasurements
     */
    ksnkoId?: string

    //limit
    /**
     * Limits number of retrieved items. The maximum is 10000 (default value)
     * @type {number}
     * @memberof WasteCollectionV2InternalApiGetWCMeasurements
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped
     * @type {number}
     * @memberof WasteCollectionV2InternalApiGetWCMeasurements
     */
    offset?: number

    //from
    /**
     * Date in ISO8601, limits data measured from this datetime
     * @type {string}
     * @memberof WasteCollectionV2InternalApiGetWCMeasurements
     */
    from?: string

    //to
    /**
     * Date in ISO8601, limits data measured up until this datetime
     * @type {string}
     * @memberof WasteCollectionV2InternalApiGetWCMeasurements
     */
    to?: string
}





/**
 * Query parameters for getWCPickDays operation in WasteCollectionV2InternalApi.
 * @export
 * @interface WasteCollectionV2InternalApiGetWCPickDaysQueryParams
 */
export interface WasteCollectionV2InternalApiGetWCPickDaysQueryParams {
    //sensoneoCode
    /**
     * Lists only pick days for container with this ID (now is used KSNKO ID as main identifier)
     * @type {string}
     * @memberof WasteCollectionV2InternalApiGetWCPickDays
     */
    sensoneoCode?: string

    //ksnkoId
    /**
     * Lists only pick days for container with this KSNKO ID
     * @type {string}
     * @memberof WasteCollectionV2InternalApiGetWCPickDays
     */
    ksnkoId?: string
}





/**
 * Query parameters for getWCPicks operation in WasteCollectionV2InternalApi.
 * @export
 * @interface WasteCollectionV2InternalApiGetWCPicksQueryParams
 */
export interface WasteCollectionV2InternalApiGetWCPicksQueryParams {
    //containerId
    /**
     * Lists only measurements from container with this ID (now is used KSNKO ID as main identifier)
     * @type {string}
     * @memberof WasteCollectionV2InternalApiGetWCPicks
     */
    containerId: string

    //ksnkoId
    /**
     * Lists only measurements from container with this KSNKO ID
     * @type {string}
     * @memberof WasteCollectionV2InternalApiGetWCPicks
     */
    ksnkoId?: string

    //limit
    /**
     * Limits number of retrieved items. The maximum is 10000 (default value)
     * @type {number}
     * @memberof WasteCollectionV2InternalApiGetWCPicks
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped
     * @type {number}
     * @memberof WasteCollectionV2InternalApiGetWCPicks
     */
    offset?: number

    //from
    /**
     * Date in ISO8601, limits data measured from this datetime
     * @type {string}
     * @memberof WasteCollectionV2InternalApiGetWCPicks
     */
    from?: string

    //to
    /**
     * Date in ISO8601, limits data measured up until this datetime
     * @type {string}
     * @memberof WasteCollectionV2InternalApiGetWCPicks
     */
    to?: string
}




/**
 * WasteCollectionV2InternalApi - object-oriented interface
 * @export
 * @class WasteCollectionV2InternalApi
 * @extends {BaseAPI}
 */
export class WasteCollectionV2InternalApi extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 
     * @summary GET All Waste Collection Measurements

     * @param {WasteCollectionV2InternalApiGetWCMeasurementsQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WasteCollectionV2InternalApi
     */
    
    public async getWCMeasurements(
        queryParams: WasteCollectionV2InternalApiGetWCMeasurementsQueryParams,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'containerId' is not null or undefined
        assertParamExists('getWCMeasurements', 'containerId', queryParams.containerId)
        
        const localVarPath = `/v2/sortedwastestations/measurements`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.containerId !== undefined) {
            requestQueryParameter['containerId'] = queryParams.containerId;
        }

        if (queryParams.ksnkoId !== undefined) {
            requestQueryParameter['ksnkoId'] = queryParams.ksnkoId;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }

        if (queryParams.from !== undefined) {
            requestQueryParameter['from'] = queryParams.from;
        }

        if (queryParams.to !== undefined) {
            requestQueryParameter['to'] = queryParams.to;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<WasteCollectionMeasurement>>(axiosRequestConfig);
    }

    /**
     * Provides information about planed pick dates for specific container.
     * @summary GET Waste Collection Pick Days

     * @param {WasteCollectionV2InternalApiGetWCPickDaysQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WasteCollectionV2InternalApi
     */
    
    public async getWCPickDays(
        queryParams: WasteCollectionV2InternalApiGetWCPickDaysQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/sortedwastestations/pickdays`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.sensoneoCode !== undefined) {
            requestQueryParameter['sensoneoCode'] = queryParams.sensoneoCode;
        }

        if (queryParams.ksnkoId !== undefined) {
            requestQueryParameter['ksnkoId'] = queryParams.ksnkoId;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<WasteCollectionPickDay>>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET All Waste Collection Picks

     * @param {WasteCollectionV2InternalApiGetWCPicksQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WasteCollectionV2InternalApi
     */
    
    public async getWCPicks(
        queryParams: WasteCollectionV2InternalApiGetWCPicksQueryParams,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'containerId' is not null or undefined
        assertParamExists('getWCPicks', 'containerId', queryParams.containerId)
        
        const localVarPath = `/v2/sortedwastestations/picks`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.containerId !== undefined) {
            requestQueryParameter['containerId'] = queryParams.containerId;
        }

        if (queryParams.ksnkoId !== undefined) {
            requestQueryParameter['ksnkoId'] = queryParams.ksnkoId;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }

        if (queryParams.from !== undefined) {
            requestQueryParameter['from'] = queryParams.from;
        }

        if (queryParams.to !== undefined) {
            requestQueryParameter['to'] = queryParams.to;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<WasteCollectionPick>>(axiosRequestConfig);
    }
}





/**
 * Query parameters for gETAllWasteCollectionYards operation in WasteCollectionYardsV2Api.
 * @export
 * @interface WasteCollectionYardsV2ApiGETAllWasteCollectionYardsQueryParams
 */
export interface WasteCollectionYardsV2ApiGETAllWasteCollectionYardsQueryParams {
    //latlng
    /**
     * Sorting by location (Latitude and Longitude separated by comma, latitude first).
     * @type {string}
     * @memberof WasteCollectionYardsV2ApiGETAllWasteCollectionYards
     */
    latlng?: string

    //range
    /**
     * Filter by distance from latlng in meters (range query). Depends on the latlng parameter.
     * @type {number}
     * @memberof WasteCollectionYardsV2ApiGETAllWasteCollectionYards
     */
    range?: number

    //districts
    /**
     * Filter by Prague city districts (slug) separated by comma.
     * @type {Array<any>}
     * @memberof WasteCollectionYardsV2ApiGETAllWasteCollectionYards
     */
    districts?: Array<any>

    //limit
    /**
     * Limits number of retrieved items. The maximum is 10000 (default value).
     * @type {number}
     * @memberof WasteCollectionYardsV2ApiGETAllWasteCollectionYards
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped.
     * @type {number}
     * @memberof WasteCollectionYardsV2ApiGETAllWasteCollectionYards
     */
    offset?: number

    //updatedSince
    /**
     * Filters all results with older updated_at than this parameter
     * @type {string}
     * @memberof WasteCollectionYardsV2ApiGETAllWasteCollectionYards
     */
    updatedSince?: string
}












/**
 * WasteCollectionYardsV2Api - object-oriented interface
 * @export
 * @class WasteCollectionYardsV2Api
 * @extends {BaseAPI}
 */
export class WasteCollectionYardsV2Api extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 
     * @summary GET All Waste Collection Yards

     * @param {WasteCollectionYardsV2ApiGETAllWasteCollectionYardsQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WasteCollectionYardsV2Api
     */
    
    public async gETAllWasteCollectionYards(
        queryParams: WasteCollectionYardsV2ApiGETAllWasteCollectionYardsQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/wastecollectionyards`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.latlng !== undefined) {
            requestQueryParameter['latlng'] = queryParams.latlng;
        }

        if (queryParams.range !== undefined) {
            requestQueryParameter['range'] = queryParams.range;
        }

        if (queryParams.districts) {
            requestQueryParameter['districts'] = queryParams.districts;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }

        if (queryParams.updatedSince !== undefined) {
            requestQueryParameter['updatedSince'] = queryParams.updatedSince;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<GETAllWasteCollectionYards200Response>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET All Waste Collection Yards Properties

     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WasteCollectionYardsV2Api
     */
    
    public async gETAllWasteCollectionYardsProperties(
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v2/wastecollectionyards/properties`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<WasteCollectionYardProperty>>(axiosRequestConfig);
    }

    /**
     * 
     * @summary GET Waste Collection Yard

     * @param {string} id Identifier of the Waste Collection Yard.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WasteCollectionYardsV2Api
     */
    
    public async gETWasteCollectionYard(
        id: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'id' is not null or undefined
        assertParamExists('gETWasteCollectionYard', 'id', id)
        
        const localVarPath = `/v2/wastecollectionyards/{id}`
            .replace(`{${"id"}}`, encodeURIComponent(String(id)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<WasteCollectionYard>(axiosRequestConfig);
    }
}





/**
 * Query parameters for getPotHoles operation in WazeV1Api.
 * @export
 * @interface WazeV1ApiGetPotHolesQueryParams
 */
export interface WazeV1ApiGetPotHolesQueryParams {
    //from
    /**
     * Date in ISO8601, limit to pothole alerts published by Waze from this datetime
     * @type {string}
     * @memberof WazeV1ApiGetPotHoles
     */
    from?: string

    //to
    /**
     * Date in ISO8601, limit to pothole alerts published by Waze until this datetime (default 7 days into past)
     * @type {string}
     * @memberof WazeV1ApiGetPotHoles
     */
    to?: string

    //limit
    /**
     * Limits number of retrieved items.
     * @type {number}
     * @memberof WazeV1ApiGetPotHoles
     */
    limit?: number

    //offset
    /**
     * Number of the first items that are skipped
     * @type {number}
     * @memberof WazeV1ApiGetPotHoles
     */
    offset?: number
}




/**
 * WazeV1Api - object-oriented interface
 * @export
 * @class WazeV1Api
 * @extends {BaseAPI}
 */
export class WazeV1Api extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * Provides information about pot holes
     * @summary GET All Pot holes

     * @param {WazeV1ApiGetPotHolesQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WazeV1Api
     */
    
    public async getPotHoles(
        queryParams: WazeV1ApiGetPotHolesQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/v1/potholes/data`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        // authentication ApiKeyAuth required
        await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)

        if (queryParams.from !== undefined) {
            requestQueryParameter['from'] = queryParams.from;
        }

        if (queryParams.to !== undefined) {
            requestQueryParameter['to'] = queryParams.to;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<PotHolesCollection>(axiosRequestConfig);
    }
}


export class SDK {
    AirQualityV2Api: AirQualityV2Api;
    BicycleCountersV2Api: BicycleCountersV2Api;
    BulkyWasteV1Api: BulkyWasteV1Api;
    EnergeticsV2Api: EnergeticsV2Api;
    FloatingCarDataV2Api: FloatingCarDataV2Api;
    GBFSV2Api: GBFSV2Api;
    GardensV2Api: GardensV2Api;
    MVTSApi: MVTSApi;
    MedicalInstitutionsV2Api: MedicalInstitutionsV2Api;
    MicroclimateV2Api: MicroclimateV2Api;
    MunicipalAuthoritiesV2Api: MunicipalAuthoritiesV2Api;
    MunicipalLibrariesV2Api: MunicipalLibrariesV2Api;
    MunicipalPoliceStationsV2Api: MunicipalPoliceStationsV2Api;
    ParkingV1Api: ParkingV1Api;
    ParkingV2Api: ParkingV2Api;
    ParkingV2InternalApi: ParkingV2InternalApi;
    ParkingV3Api: ParkingV3Api;
    PedestriansV2Api: PedestriansV2Api;
    PlaygroundsV2Api: PlaygroundsV2Api;
    PragueCityDistrictsV2Api: PragueCityDistrictsV2Api;
    SharedBikesV2Api: SharedBikesV2Api;
    SharedCarsV2Api: SharedCarsV2Api;
    TrafficRestrictionsV2Api: TrafficRestrictionsV2Api;
    VehiclesharingV2Api: VehiclesharingV2Api;
    WasteCollectionV2Api: WasteCollectionV2Api;
    WasteCollectionV2InternalApi: WasteCollectionV2InternalApi;
    WasteCollectionYardsV2Api: WasteCollectionYardsV2Api;
    WazeV1Api: WazeV1Api;

    constructor(configurationParams: ConfigurationParameters & { basePath: string }, axios?: AxiosInstance) {
        const configuration = new Configuration(configurationParams);

        if(!axios) axios = globalAxios.create();

        this.AirQualityV2Api = new AirQualityV2Api(configuration, axios!);
        this.BicycleCountersV2Api = new BicycleCountersV2Api(configuration, axios!);
        this.BulkyWasteV1Api = new BulkyWasteV1Api(configuration, axios!);
        this.EnergeticsV2Api = new EnergeticsV2Api(configuration, axios!);
        this.FloatingCarDataV2Api = new FloatingCarDataV2Api(configuration, axios!);
        this.GBFSV2Api = new GBFSV2Api(configuration, axios!);
        this.GardensV2Api = new GardensV2Api(configuration, axios!);
        this.MVTSApi = new MVTSApi(configuration, axios!);
        this.MedicalInstitutionsV2Api = new MedicalInstitutionsV2Api(configuration, axios!);
        this.MicroclimateV2Api = new MicroclimateV2Api(configuration, axios!);
        this.MunicipalAuthoritiesV2Api = new MunicipalAuthoritiesV2Api(configuration, axios!);
        this.MunicipalLibrariesV2Api = new MunicipalLibrariesV2Api(configuration, axios!);
        this.MunicipalPoliceStationsV2Api = new MunicipalPoliceStationsV2Api(configuration, axios!);
        this.ParkingV1Api = new ParkingV1Api(configuration, axios!);
        this.ParkingV2Api = new ParkingV2Api(configuration, axios!);
        this.ParkingV2InternalApi = new ParkingV2InternalApi(configuration, axios!);
        this.ParkingV3Api = new ParkingV3Api(configuration, axios!);
        this.PedestriansV2Api = new PedestriansV2Api(configuration, axios!);
        this.PlaygroundsV2Api = new PlaygroundsV2Api(configuration, axios!);
        this.PragueCityDistrictsV2Api = new PragueCityDistrictsV2Api(configuration, axios!);
        this.SharedBikesV2Api = new SharedBikesV2Api(configuration, axios!);
        this.SharedCarsV2Api = new SharedCarsV2Api(configuration, axios!);
        this.TrafficRestrictionsV2Api = new TrafficRestrictionsV2Api(configuration, axios!);
        this.VehiclesharingV2Api = new VehiclesharingV2Api(configuration, axios!);
        this.WasteCollectionV2Api = new WasteCollectionV2Api(configuration, axios!);
        this.WasteCollectionV2InternalApi = new WasteCollectionV2InternalApi(configuration, axios!);
        this.WasteCollectionYardsV2Api = new WasteCollectionYardsV2Api(configuration, axios!);
        this.WazeV1Api = new WazeV1Api(configuration, axios!);
    };
}