/* tslint:disable */
/* eslint-disable */
/**
 * smallhill-skeleton-nestjs
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import type { ConfigurationParameters } from './configuration';
import type { AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CleaningFrequency
 */
export interface CleaningFrequency {
    /**
     * 
     * @type {number}
     * @memberof CleaningFrequency
     */
    'id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CleaningFrequency
     */
    'duration'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CleaningFrequency
     */
    'frequency'?: number | null;
}
/**
 * 
 * @export
 * @interface Container
 */
export interface Container {
    /**
     * 
     * @type {string}
     * @memberof Container
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Container
     */
    'location': string;
    /**
     * 
     * @type {string}
     * @memberof Container
     */
    'district'?: string;
    /**
     * 
     * @type {number}
     * @memberof Container
     */
    'lon'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Container
     */
    'lat'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Container
     */
    'accessibility'?: number;
    /**
     * 
     * @type {Array<ContainerType>}
     * @memberof Container
     */
    'containerTypes'?: Array<ContainerType>;
}
/**
 * 
 * @export
 * @interface ContainerType
 */
export interface ContainerType {
    /**
     * 
     * @type {string}
     * @memberof ContainerType
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerType
     */
    'containerId': string;
    /**
     * 
     * @type {number}
     * @memberof ContainerType
     */
    'type': number;
    /**
     * 
     * @type {CleaningFrequency}
     * @memberof ContainerType
     */
    'cleaning_frequency'?: CleaningFrequency;
    /**
     * 
     * @type {string}
     * @memberof ContainerType
     */
    'container_type'?: string;
    /**
     * 
     * @type {Container}
     * @memberof ContainerType
     */
    'container'?: Container;
}
/**
 * 
 * @export
 * @interface DepartureBoardItem
 */
export interface DepartureBoardItem {
    /**
     * 
     * @type {DepartureBoardItemDelay}
     * @memberof DepartureBoardItem
     */
    'delay'?: DepartureBoardItemDelay;
    /**
     * 
     * @type {DepartureBoardItemArrivalTimestamp}
     * @memberof DepartureBoardItem
     */
    'arrival_timestamp'?: DepartureBoardItemArrivalTimestamp;
    /**
     * 
     * @type {DepartureBoardItemArrivalTimestamp}
     * @memberof DepartureBoardItem
     */
    'departure_timestamp'?: DepartureBoardItemArrivalTimestamp;
    /**
     * 
     * @type {DepartureBoardItemRoute}
     * @memberof DepartureBoardItem
     */
    'route'?: DepartureBoardItemRoute;
    /**
     * 
     * @type {DepartureBoardItemStop}
     * @memberof DepartureBoardItem
     */
    'stop'?: DepartureBoardItemStop;
    /**
     * 
     * @type {DepartureBoardItemTrip}
     * @memberof DepartureBoardItem
     */
    'trip'?: DepartureBoardItemTrip;
}
/**
 * 
 * @export
 * @interface DepartureBoardItemArrivalTimestamp
 */
export interface DepartureBoardItemArrivalTimestamp {
    /**
     * 
     * @type {string}
     * @memberof DepartureBoardItemArrivalTimestamp
     */
    'predicted': string;
    /**
     * 
     * @type {string}
     * @memberof DepartureBoardItemArrivalTimestamp
     */
    'scheduled': string;
}
/**
 * 
 * @export
 * @interface DepartureBoardItemDelay
 */
export interface DepartureBoardItemDelay {
    /**
     * 
     * @type {boolean}
     * @memberof DepartureBoardItemDelay
     */
    'is_available': boolean;
    /**
     * 
     * @type {number}
     * @memberof DepartureBoardItemDelay
     */
    'minutes': number | null;
    /**
     * 
     * @type {number}
     * @memberof DepartureBoardItemDelay
     */
    'seconds': number | null;
}
/**
 * 
 * @export
 * @interface DepartureBoardItemRoute
 */
export interface DepartureBoardItemRoute {
    /**
     * 
     * @type {number}
     * @memberof DepartureBoardItemRoute
     */
    'type': number | null;
    /**
     * 
     * @type {string}
     * @memberof DepartureBoardItemRoute
     */
    'short_name': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof DepartureBoardItemRoute
     */
    'is_night': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DepartureBoardItemRoute
     */
    'is_regional': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DepartureBoardItemRoute
     */
    'is_substitute_transport': boolean;
}
/**
 * 
 * @export
 * @interface DepartureBoardItemStop
 */
export interface DepartureBoardItemStop {
    /**
     * 
     * @type {string}
     * @memberof DepartureBoardItemStop
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DepartureBoardItemStop
     */
    'platform_code': string | null;
}
/**
 * 
 * @export
 * @interface DepartureBoardItemTrip
 */
export interface DepartureBoardItemTrip {
    /**
     * 
     * @type {string}
     * @memberof DepartureBoardItemTrip
     */
    'headsign': string;
    /**
     * 
     * @type {string}
     * @memberof DepartureBoardItemTrip
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof DepartureBoardItemTrip
     */
    'is_canceled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DepartureBoardItemTrip
     */
    'is_wheelchair_accessible': boolean;
    /**
     * 
     * @type {string}
     * @memberof DepartureBoardItemTrip
     */
    'direction': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof DepartureBoardItemTrip
     */
    'is_at_stop': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DepartureBoardItemTrip
     */
    'is_air_conditioned': boolean | null;
    /**
     * 
     * @type {string}
     * @memberof DepartureBoardItemTrip
     */
    'short_name': string | null;
}
/**
 * 
 * @export
 * @interface DepartureBoardResponse
 */
export interface DepartureBoardResponse {
    /**
     * 
     * @type {Array<DepartureBoardItem>}
     * @memberof DepartureBoardResponse
     */
    'departures'?: Array<DepartureBoardItem>;
}
/**
 * 
 * @export
 * @interface Geometry
 */
export interface Geometry {
    /**
     * 
     * @type {string}
     * @memberof Geometry
     */
    'type': GeometryTypeEnum;
    /**
     * 
     * @type {Array<number>}
     * @memberof Geometry
     */
    'coordinates': Array<number>;
}

export const GeometryTypeEnum = {
    Point: 'Point'
} as const;

export type GeometryTypeEnum = typeof GeometryTypeEnum[keyof typeof GeometryTypeEnum];

/**
 * 
 * @export
 * @interface GetHistoryResponse
 */
export interface GetHistoryResponse {
    /**
     * 
     * @type {string}
     * @memberof GetHistoryResponse
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof GetHistoryResponse
     */
    'occupancy'?: number | null;
}
/**
 * 
 * @export
 * @interface Stop
 */
export interface Stop {
    /**
     * 
     * @type {string}
     * @memberof Stop
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Stop
     */
    'name': string;
    /**
     * 
     * @type {Array<StopPlatform>}
     * @memberof Stop
     */
    'platforms': Array<StopPlatform>;
}
/**
 * 
 * @export
 * @interface StopPlatform
 */
export interface StopPlatform {
    /**
     * 
     * @type {string}
     * @memberof StopPlatform
     */
    'id': string;
    /**
     * 
     * @type {Stop}
     * @memberof StopPlatform
     */
    'stop': Stop;
    /**
     * 
     * @type {string}
     * @memberof StopPlatform
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof StopPlatform
     */
    'lat': number;
    /**
     * 
     * @type {number}
     * @memberof StopPlatform
     */
    'lon': number;
}
/**
 * 
 * @export
 * @interface VehiclePositionProperties
 */
export interface VehiclePositionProperties {
    /**
     * 
     * @type {VehiclePositionPropertiesLastPosition}
     * @memberof VehiclePositionProperties
     */
    'last_position': VehiclePositionPropertiesLastPosition;
    /**
     * 
     * @type {VehiclePositionPropertiesTrip}
     * @memberof VehiclePositionProperties
     */
    'trip': VehiclePositionPropertiesTrip;
}
/**
 * 
 * @export
 * @interface VehiclePositionPropertiesLastPosition
 */
export interface VehiclePositionPropertiesLastPosition {
    /**
     * 
     * @type {number}
     * @memberof VehiclePositionPropertiesLastPosition
     */
    'bearing': number | null;
    /**
     * 
     * @type {VehiclePositionPropertiesLastPositionDelay}
     * @memberof VehiclePositionPropertiesLastPosition
     */
    'delay': VehiclePositionPropertiesLastPositionDelay;
    /**
     * 
     * @type {VehiclePositionPropertiesLastPositionLastStop}
     * @memberof VehiclePositionPropertiesLastPosition
     */
    'last_stop': VehiclePositionPropertiesLastPositionLastStop;
    /**
     * 
     * @type {VehiclePositionPropertiesLastPositionLastStop}
     * @memberof VehiclePositionPropertiesLastPosition
     */
    'next_stop': VehiclePositionPropertiesLastPositionLastStop;
    /**
     * 
     * @type {boolean}
     * @memberof VehiclePositionPropertiesLastPosition
     */
    'is_canceled': boolean | null;
    /**
     * 
     * @type {string}
     * @memberof VehiclePositionPropertiesLastPosition
     */
    'origin_timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof VehiclePositionPropertiesLastPosition
     */
    'speed'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof VehiclePositionPropertiesLastPosition
     */
    'shape_dist_traveled'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof VehiclePositionPropertiesLastPosition
     */
    'tracking': boolean;
}
/**
 * 
 * @export
 * @interface VehiclePositionPropertiesLastPositionDelay
 */
export interface VehiclePositionPropertiesLastPositionDelay {
    /**
     * 
     * @type {number}
     * @memberof VehiclePositionPropertiesLastPositionDelay
     */
    'actual'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof VehiclePositionPropertiesLastPositionDelay
     */
    'last_stop_arrival'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof VehiclePositionPropertiesLastPositionDelay
     */
    'last_stop_departure'?: number | null;
}
/**
 * 
 * @export
 * @interface VehiclePositionPropertiesLastPositionLastStop
 */
export interface VehiclePositionPropertiesLastPositionLastStop {
    /**
     * 
     * @type {string}
     * @memberof VehiclePositionPropertiesLastPositionLastStop
     */
    'id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof VehiclePositionPropertiesLastPositionLastStop
     */
    'sequence'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof VehiclePositionPropertiesLastPositionLastStop
     */
    'arrival_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VehiclePositionPropertiesLastPositionLastStop
     */
    'departure_time'?: string | null;
}
/**
 * 
 * @export
 * @interface VehiclePositionPropertiesTrip
 */
export interface VehiclePositionPropertiesTrip {
    /**
     * 
     * @type {VehiclePositionPropertiesTripAgencyName}
     * @memberof VehiclePositionPropertiesTrip
     */
    'agency_name': VehiclePositionPropertiesTripAgencyName;
    /**
     * 
     * @type {VehiclePositionPropertiesTripCis}
     * @memberof VehiclePositionPropertiesTrip
     */
    'cis': VehiclePositionPropertiesTripCis;
    /**
     * 
     * @type {number}
     * @memberof VehiclePositionPropertiesTrip
     */
    'sequence_id': number;
    /**
     * 
     * @type {string}
     * @memberof VehiclePositionPropertiesTrip
     */
    'origin_route_name': string;
    /**
     * 
     * @type {VehiclePositionPropertiesTripGtfs}
     * @memberof VehiclePositionPropertiesTrip
     */
    'gtfs': VehiclePositionPropertiesTripGtfs;
    /**
     * 
     * @type {string}
     * @memberof VehiclePositionPropertiesTrip
     */
    'start_timestamp': string;
    /**
     * 
     * @type {VehiclePositionPropertiesTripVehicleType}
     * @memberof VehiclePositionPropertiesTrip
     */
    'vehicle_type': VehiclePositionPropertiesTripVehicleType;
    /**
     * 
     * @type {number}
     * @memberof VehiclePositionPropertiesTrip
     */
    'vehicle_registration_number': number;
    /**
     * 
     * @type {boolean}
     * @memberof VehiclePositionPropertiesTrip
     */
    'wheelchair_accessible': boolean;
}
/**
 * 
 * @export
 * @interface VehiclePositionPropertiesTripAgencyName
 */
export interface VehiclePositionPropertiesTripAgencyName {
    /**
     * 
     * @type {string}
     * @memberof VehiclePositionPropertiesTripAgencyName
     */
    'real'?: string;
    /**
     * 
     * @type {string}
     * @memberof VehiclePositionPropertiesTripAgencyName
     */
    'scheduled'?: string;
}
/**
 * 
 * @export
 * @interface VehiclePositionPropertiesTripCis
 */
export interface VehiclePositionPropertiesTripCis {
    /**
     * 
     * @type {string}
     * @memberof VehiclePositionPropertiesTripCis
     */
    'line_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof VehiclePositionPropertiesTripCis
     */
    'trip_number'?: number;
}
/**
 * 
 * @export
 * @interface VehiclePositionPropertiesTripGtfs
 */
export interface VehiclePositionPropertiesTripGtfs {
    /**
     * 
     * @type {string}
     * @memberof VehiclePositionPropertiesTripGtfs
     */
    'route_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VehiclePositionPropertiesTripGtfs
     */
    'route_short_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof VehiclePositionPropertiesTripGtfs
     */
    'route_type'?: number;
    /**
     * 
     * @type {string}
     * @memberof VehiclePositionPropertiesTripGtfs
     */
    'trip_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VehiclePositionPropertiesTripGtfs
     */
    'trip_headsign'?: string | null;
}
/**
 * 
 * @export
 * @interface VehiclePositionPropertiesTripVehicleType
 */
export interface VehiclePositionPropertiesTripVehicleType {
    /**
     * 
     * @type {number}
     * @memberof VehiclePositionPropertiesTripVehicleType
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof VehiclePositionPropertiesTripVehicleType
     */
    'description_cs'?: string;
    /**
     * 
     * @type {string}
     * @memberof VehiclePositionPropertiesTripVehicleType
     */
    'description_en'?: string;
}
/**
 * 
 * @export
 * @interface VehiclePositionResponse
 */
export interface VehiclePositionResponse {
    /**
     * 
     * @type {string}
     * @memberof VehiclePositionResponse
     */
    'type': VehiclePositionResponseTypeEnum;
    /**
     * 
     * @type {Geometry}
     * @memberof VehiclePositionResponse
     */
    'geometry': Geometry;
    /**
     * 
     * @type {VehiclePositionProperties}
     * @memberof VehiclePositionResponse
     */
    'properties': VehiclePositionProperties;
}

export const VehiclePositionResponseTypeEnum = {
    Feature: 'Feature'
} as const;

export type VehiclePositionResponseTypeEnum = typeof VehiclePositionResponseTypeEnum[keyof typeof VehiclePositionResponseTypeEnum];





















/**
 * CityVizorApi - object-oriented interface
 * @export
 * @class CityVizorApi
 * @extends {BaseAPI}
 */
export class CityVizorApi extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 

     * @param {string} profile 
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CityVizorApi
     */
    
    public async getPayments(
        profile: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'profile' is not null or undefined
        assertParamExists('getPayments', 'profile', profile)
        
        const localVarPath = `/api/cityvizor/payments/{profile}`
            .replace(`{${"profile"}}`, encodeURIComponent(String(profile)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<object>>(axiosRequestConfig);
    }

    /**
     * 

     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CityVizorApi
     */
    
    public async getProfiles(
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/api/cityvizor/profiles`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<object>>(axiosRequestConfig);
    }

    /**
     * 

     * @param {string} id 
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CityVizorApi
     */
    
    public async getStation(
        id: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'id' is not null or undefined
        assertParamExists('getStation', 'id', id)
        
        const localVarPath = `/api/air-quality/stations/{id}`
            .replace(`{${"id"}}`, encodeURIComponent(String(id)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<object>(axiosRequestConfig);
    }

    /**
     * 

     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CityVizorApi
     */
    
    public async getStations(
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/api/air-quality/stations`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<object>>(axiosRequestConfig);
    }
}









/**
 * Query parameters for getContainers operation in ContainersApi.
 * @export
 * @interface ContainersApiGetContainersQueryParams
 */
export interface ContainersApiGetContainersQueryParams {
    //q
    /**
     * 
     * @type {string}
     * @memberof ContainersApiGetContainers
     */
    q?: string

    //lat
    /**
     * 
     * @type {number}
     * @memberof ContainersApiGetContainers
     */
    lat?: number

    //lon
    /**
     * 
     * @type {number}
     * @memberof ContainersApiGetContainers
     */
    lon?: number
}





/**
 * Query parameters for getHistory operation in ContainersApi.
 * @export
 * @interface ContainersApiGetHistoryQueryParams
 */
export interface ContainersApiGetHistoryQueryParams {
    //since
    /**
     * 
     * @type {string}
     * @memberof ContainersApiGetHistory
     */
    since?: string
}




/**
 * ContainersApi - object-oriented interface
 * @export
 * @class ContainersApi
 * @extends {BaseAPI}
 */
export class ContainersApi extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 

     * @param {string} id 
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    
    public async getContainer(
        id: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'id' is not null or undefined
        assertParamExists('getContainer', 'id', id)
        
        const localVarPath = `/api/containers/{id}`
            .replace(`{${"id"}}`, encodeURIComponent(String(id)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Container>(axiosRequestConfig);
    }

    /**
     * 

     * @param {ContainersApiGetContainersQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    
    public async getContainers(
        queryParams: ContainersApiGetContainersQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/api/containers`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        if (queryParams.q !== undefined) {
            requestQueryParameter['q'] = queryParams.q;
        }

        if (queryParams.lat !== undefined) {
            requestQueryParameter['lat'] = queryParams.lat;
        }

        if (queryParams.lon !== undefined) {
            requestQueryParameter['lon'] = queryParams.lon;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<Container>>(axiosRequestConfig);
    }

    /**
     * 

     * @param {string} id 
     * @param {string} type 
     * @param {ContainersApiGetHistoryQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    
    public async getHistory(
        id: string,
        type: string,
        queryParams: ContainersApiGetHistoryQueryParams,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'id' is not null or undefined
        assertParamExists('getHistory', 'id', id)
        assertParamExists('getHistory', 'type', type)
        
        // verify required parameter 'type' is not null or undefined
        assertParamExists('getHistory', 'id', id)
        assertParamExists('getHistory', 'type', type)
        
        const localVarPath = `/api/containers/{id}/{type}/history`
            .replace(`{${"id"}}`, encodeURIComponent(String(id)))
            .replace(`{${"type"}}`, encodeURIComponent(String(type)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        if (queryParams.since !== undefined) {
            requestQueryParameter['since'] = queryParams.since;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<GetHistoryResponse>>(axiosRequestConfig);
    }
}





/**
 * Query parameters for getClosestDepartureBoard operation in PublicTransportApi.
 * @export
 * @interface PublicTransportApiGetClosestDepartureBoardQueryParams
 */
export interface PublicTransportApiGetClosestDepartureBoardQueryParams {
    //lat
    /**
     * 
     * @type {number}
     * @memberof PublicTransportApiGetClosestDepartureBoard
     */
    lat: number

    //lon
    /**
     * 
     * @type {number}
     * @memberof PublicTransportApiGetClosestDepartureBoard
     */
    lon: number

    //limit
    /**
     * 
     * @type {number}
     * @memberof PublicTransportApiGetClosestDepartureBoard
     */
    limit?: number

    //offset
    /**
     * 
     * @type {number}
     * @memberof PublicTransportApiGetClosestDepartureBoard
     */
    offset?: number
}





/**
 * Query parameters for getClosestStop operation in PublicTransportApi.
 * @export
 * @interface PublicTransportApiGetClosestStopQueryParams
 */
export interface PublicTransportApiGetClosestStopQueryParams {
    //lat
    /**
     * 
     * @type {number}
     * @memberof PublicTransportApiGetClosestStop
     */
    lat: number

    //lon
    /**
     * 
     * @type {number}
     * @memberof PublicTransportApiGetClosestStop
     */
    lon: number
}





/**
 * Query parameters for getDepartureBoard operation in PublicTransportApi.
 * @export
 * @interface PublicTransportApiGetDepartureBoardQueryParams
 */
export interface PublicTransportApiGetDepartureBoardQueryParams {
    //name
    /**
     * 
     * @type {Array<string>}
     * @memberof PublicTransportApiGetDepartureBoard
     */
    name?: Array<string>

    //id
    /**
     * 
     * @type {Array<string>}
     * @memberof PublicTransportApiGetDepartureBoard
     */
    id?: Array<string>

    //limit
    /**
     * 
     * @type {number}
     * @memberof PublicTransportApiGetDepartureBoard
     */
    limit?: number

    //offset
    /**
     * 
     * @type {number}
     * @memberof PublicTransportApiGetDepartureBoard
     */
    offset?: number
}













/**
 * Query parameters for getStops operation in PublicTransportApi.
 * @export
 * @interface PublicTransportApiGetStopsQueryParams
 */
export interface PublicTransportApiGetStopsQueryParams {
    //q
    /**
     * 
     * @type {string}
     * @memberof PublicTransportApiGetStops
     */
    q?: string

    //lat
    /**
     * 
     * @type {number}
     * @memberof PublicTransportApiGetStops
     */
    lat?: number

    //lon
    /**
     * 
     * @type {number}
     * @memberof PublicTransportApiGetStops
     */
    lon?: number

    //offset
    /**
     * 
     * @type {string}
     * @memberof PublicTransportApiGetStops
     */
    offset?: string

    //limit
    /**
     * 
     * @type {string}
     * @memberof PublicTransportApiGetStops
     */
    limit?: string
}








/**
 * PublicTransportApi - object-oriented interface
 * @export
 * @class PublicTransportApi
 * @extends {BaseAPI}
 */
export class PublicTransportApi extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 

     * @param {PublicTransportApiGetClosestDepartureBoardQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicTransportApi
     */
    
    public async getClosestDepartureBoard(
        queryParams: PublicTransportApiGetClosestDepartureBoardQueryParams,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'lat' is not null or undefined
        assertParamExists('getClosestDepartureBoard', 'lat', queryParams.lat)
        assertParamExists('getClosestDepartureBoard', 'lon', queryParams.lon)
        
        // verify required parameter 'lon' is not null or undefined
        assertParamExists('getClosestDepartureBoard', 'lat', queryParams.lat)
        assertParamExists('getClosestDepartureBoard', 'lon', queryParams.lon)
        
        const localVarPath = `/api/departure-boards/closest`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        if (queryParams.lat !== undefined) {
            requestQueryParameter['lat'] = queryParams.lat;
        }

        if (queryParams.lon !== undefined) {
            requestQueryParameter['lon'] = queryParams.lon;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<DepartureBoardResponse>(axiosRequestConfig);
    }

    /**
     * 

     * @param {PublicTransportApiGetClosestStopQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicTransportApi
     */
    
    public async getClosestStop(
        queryParams: PublicTransportApiGetClosestStopQueryParams,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'lat' is not null or undefined
        assertParamExists('getClosestStop', 'lat', queryParams.lat)
        assertParamExists('getClosestStop', 'lon', queryParams.lon)
        
        // verify required parameter 'lon' is not null or undefined
        assertParamExists('getClosestStop', 'lat', queryParams.lat)
        assertParamExists('getClosestStop', 'lon', queryParams.lon)
        
        const localVarPath = `/api/stops/closest`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        if (queryParams.lat !== undefined) {
            requestQueryParameter['lat'] = queryParams.lat;
        }

        if (queryParams.lon !== undefined) {
            requestQueryParameter['lon'] = queryParams.lon;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Stop>(axiosRequestConfig);
    }

    /**
     * 

     * @param {PublicTransportApiGetDepartureBoardQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicTransportApi
     */
    
    public async getDepartureBoard(
        queryParams: PublicTransportApiGetDepartureBoardQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/api/departure-boards`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        if (queryParams.name) {
            requestQueryParameter['name'] = queryParams.name;
        }

        if (queryParams.id) {
            requestQueryParameter['id'] = queryParams.id;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<DepartureBoardResponse>(axiosRequestConfig);
    }

    /**
     * 

     * @param {string} id 
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicTransportApi
     */
    
    public async getPlatform(
        id: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'id' is not null or undefined
        assertParamExists('getPlatform', 'id', id)
        
        const localVarPath = `/api/platforms/{id}`
            .replace(`{${"id"}}`, encodeURIComponent(String(id)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<StopPlatform>(axiosRequestConfig);
    }

    /**
     * 

     * @param {string} name 
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicTransportApi
     */
    
    public async getStop(
        name: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'name' is not null or undefined
        assertParamExists('getStop', 'name', name)
        
        const localVarPath = `/api/stops/{name}`
            .replace(`{${"name"}}`, encodeURIComponent(String(name)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Stop>(axiosRequestConfig);
    }

    /**
     * 

     * @param {PublicTransportApiGetStopsQueryParams} queryParams Query parameters.
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicTransportApi
     */
    
    public async getStops(
        queryParams: PublicTransportApiGetStopsQueryParams = {},
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/api/stops`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;

        if (queryParams.q !== undefined) {
            requestQueryParameter['q'] = queryParams.q;
        }

        if (queryParams.lat !== undefined) {
            requestQueryParameter['lat'] = queryParams.lat;
        }

        if (queryParams.lon !== undefined) {
            requestQueryParameter['lon'] = queryParams.lon;
        }

        if (queryParams.offset !== undefined) {
            requestQueryParameter['offset'] = queryParams.offset;
        }

        if (queryParams.limit !== undefined) {
            requestQueryParameter['limit'] = queryParams.limit;
        }



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<Array<Stop>>(axiosRequestConfig);
    }

    /**
     * 

     * @param {string} tripId 
     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicTransportApi
     */
    
    public async getVehiclePosition(
        tripId: string,
        options: AxiosRequestConfig = {}
    ) {

        // verify required parameter 'tripId' is not null or undefined
        assertParamExists('getVehiclePosition', 'tripId', tripId)
        
        const localVarPath = `/api/vehicle-positions/{trip_id}`
            .replace(`{${"trip_id"}}`, encodeURIComponent(String(tripId)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<VehiclePositionResponse>(axiosRequestConfig);
    }
}
















/**
 * RootApi - object-oriented interface
 * @export
 * @class RootApi
 * @extends {BaseAPI}
 */
export class RootApi extends BaseAPI {

    constructor(protected override configuration: Configuration, protected override axios: AxiosInstance = globalAxios) {
        super(configuration, configuration.basePath, axios);
    }

    /**
     * 
     * @summary The OpenAPI document in JSON

     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RootApi
     */
    
    public async getOpenAPIJSON(
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/api/openapi-json`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<string>(axiosRequestConfig);
    }

    /**
     * 
     * @summary The OpenAPI document in YAML

     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RootApi
     */
    
    public async getOpenAPIYAML(
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/api/openapi-yaml`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<string>(axiosRequestConfig);
    }

    /**
     * 
     * @summary This SwaggerUI page

     * @param {AxiosRequestConfig} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RootApi
     */
    
    public async viewSwaggerUI(
        options: AxiosRequestConfig = {}
    ) {

        const localVarPath = `/api/openapi`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (this.configuration) {
            baseOptions = this.configuration.baseOptions;
        }

        const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
        const requestHeaderParameter = {} as any;
        const requestQueryParameter = {} as any;



        setSearchParams(requestUrlObj, requestQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};

        axiosRequestConfig["url"] = toPathString(requestUrlObj);
        axiosRequestConfig["baseURL"] = this.configuration.basePath;
        
        return this.axios.request<string>(axiosRequestConfig);
    }
}


export class SDK {
    CityVizorApi: CityVizorApi;
    ContainersApi: ContainersApi;
    PublicTransportApi: PublicTransportApi;
    RootApi: RootApi;

    constructor(configurationParams: ConfigurationParameters & { basePath: string }, axios?: AxiosInstance) {
        const configuration = new Configuration(configurationParams);

        if(!axios) axios = globalAxios.create();

        this.CityVizorApi = new CityVizorApi(configuration, axios!);
        this.ContainersApi = new ContainersApi(configuration, axios!);
        this.PublicTransportApi = new PublicTransportApi(configuration, axios!);
        this.RootApi = new RootApi(configuration, axios!);
    };
}